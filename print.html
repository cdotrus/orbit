<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Book of Orbit</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <style>
            dd {
                margin-bottom: 1em;
            }
        </style>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="starting/starting.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="starting/installing.html"><strong aria-hidden="true">1.1.</strong> Installing</a></li><li class="chapter-item expanded "><a href="starting/upgrading.html"><strong aria-hidden="true">1.2.</strong> Upgrading</a></li></ol></li><li class="chapter-item expanded "><a href="tutorials/tutorials.html"><strong aria-hidden="true">2.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/first_project.html"><strong aria-hidden="true">2.1.</strong> First Project: Gates</a></li><li class="chapter-item expanded "><a href="tutorials/dependencies.html"><strong aria-hidden="true">2.2.</strong> Dependencies: Half adder</a></li><li class="chapter-item expanded "><a href="tutorials/gates_revisited.html"><strong aria-hidden="true">2.3.</strong> Gates: Revisited</a></li><li class="chapter-item expanded "><a href="tutorials/final_project.html"><strong aria-hidden="true">2.4.</strong> Final Project: Full adder</a></li></ol></li><li class="chapter-item expanded "><a href="user/user.html"><strong aria-hidden="true">3.</strong> User Guide</a></li><li class="chapter-item expanded "><a href="topic/topic.html"><strong aria-hidden="true">4.</strong> Topic Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="topic/concept.html"><strong aria-hidden="true">4.1.</strong> Key Concepts</a></li><li class="chapter-item expanded "><a href="topic/catalog.html"><strong aria-hidden="true">4.2.</strong> Catalog</a></li><li class="chapter-item expanded "><a href="topic/1_ip.html"><strong aria-hidden="true">4.3.</strong> IP</a></li><li class="chapter-item expanded "><a href="topic/5_orbitlock.html"><strong aria-hidden="true">4.4.</strong> Orbit.lock</a></li><li class="chapter-item expanded "><a href="topic/orbitignore.html"><strong aria-hidden="true">4.5.</strong> .orbitignore</a></li><li class="chapter-item expanded "><a href="topic/planning.html"><strong aria-hidden="true">4.6.</strong> Planning</a></li><li class="chapter-item expanded "><a href="topic/building.html"><strong aria-hidden="true">4.7.</strong> Building</a></li><li class="chapter-item expanded "><a href="topic/protocols.html"><strong aria-hidden="true">4.8.</strong> Protocols</a></li><li class="chapter-item expanded "><a href="topic/caching.html"><strong aria-hidden="true">4.9.</strong> Caching</a></li><li class="chapter-item expanded "><a href="topic/downloading.html"><strong aria-hidden="true">4.10.</strong> Downloading</a></li><li class="chapter-item expanded "><a href="topic/var_sub.html"><strong aria-hidden="true">4.11.</strong> Variable Substitution</a></li><li class="chapter-item expanded "><a href="topic/dst.html"><strong aria-hidden="true">4.12.</strong> Dynamic Symbol Transformation</a></li></ol></li><li class="chapter-item expanded "><a href="reference/reference.html"><strong aria-hidden="true">5.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/manifest.html"><strong aria-hidden="true">5.1.</strong> Manifest</a></li><li class="chapter-item expanded "><a href="reference/packages.html"><strong aria-hidden="true">5.2.</strong> Packages</a></li><li class="chapter-item expanded "><a href="reference/versions.html"><strong aria-hidden="true">5.3.</strong> Versions</a></li><li class="chapter-item expanded "><a href="reference/filesets.html"><strong aria-hidden="true">5.4.</strong> Filesets</a></li><li class="chapter-item expanded "><a href="reference/blueprint.html"><strong aria-hidden="true">5.5.</strong> Blueprint</a></li><li class="chapter-item expanded "><a href="reference/environment_variables.html"><strong aria-hidden="true">5.6.</strong> Environment Variables</a></li><li class="chapter-item expanded "><a href="reference/configuration.html"><strong aria-hidden="true">5.7.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="reference/exporting_interfaces.html"><strong aria-hidden="true">5.8.</strong> Exporting Interfaces</a></li><li class="chapter-item expanded "><a href="reference/command_line.html"><strong aria-hidden="true">5.9.</strong> Command Line</a></li></ol></li><li class="chapter-item expanded "><a href="commands/commands.html"><strong aria-hidden="true">6.</strong> Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/new.html"><strong aria-hidden="true">6.1.</strong> orbit new</a></li><li class="chapter-item expanded "><a href="commands/init.html"><strong aria-hidden="true">6.2.</strong> orbit init</a></li><li class="chapter-item expanded "><a href="commands/show.html"><strong aria-hidden="true">6.3.</strong> orbit show</a></li><li class="chapter-item expanded "><a href="commands/read.html"><strong aria-hidden="true">6.4.</strong> orbit read</a></li><li class="chapter-item expanded "><a href="commands/get.html"><strong aria-hidden="true">6.5.</strong> orbit get</a></li><li class="chapter-item expanded "><a href="commands/tree.html"><strong aria-hidden="true">6.6.</strong> orbit tree</a></li><li class="chapter-item expanded "><a href="commands/plan.html"><strong aria-hidden="true">6.7.</strong> orbit plan</a></li><li class="chapter-item expanded "><a href="commands/build.html"><strong aria-hidden="true">6.8.</strong> orbit build</a></li><li class="chapter-item expanded "><a href="commands/launch.html"><strong aria-hidden="true">6.9.</strong> orbit launch</a></li><li class="chapter-item expanded "><a href="commands/search.html"><strong aria-hidden="true">6.10.</strong> orbit search</a></li><li class="chapter-item expanded "><a href="commands/download.html"><strong aria-hidden="true">6.11.</strong> orbit download</a></li><li class="chapter-item expanded "><a href="commands/install.html"><strong aria-hidden="true">6.12.</strong> orbit install</a></li><li class="chapter-item expanded "><a href="commands/env.html"><strong aria-hidden="true">6.13.</strong> orbit env</a></li><li class="chapter-item expanded "><a href="commands/config.html"><strong aria-hidden="true">6.14.</strong> orbit config</a></li><li class="chapter-item expanded "><a href="commands/remove.html"><strong aria-hidden="true">6.15.</strong> orbit remove</a></li></ol></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">7.</strong> Appendix: Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Book of Orbit</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-book-of-orbit"><a class="header" href="#the-book-of-orbit">The Book of Orbit</a></h1>
<p><img src="./images/orbit_logo_128px.png" alt="" /></p>
<p>Orbit is a package manager for Hardware Description Languages (HDL). Orbit provides a complete frontend package management solution to HDL projects, while allowing users to implement custom backend workflows through a plugin system. Orbit provides commands for every stage of the development cycle, in areas such as exploration, integration, and automation.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<p>The following documentation will be mainly divided into 4 sections:</p>
<ol>
<li><a href="./tutorials/tutorials.html">Tutorials</a> - Step-by-step lessons working with <code>orbit</code></li>
<li><a href="./user/user.html">User Guide</a> - General procedures for &quot;how-to&quot; solve common problems</li>
<li><a href="./topic/topic.html">Topic Guide</a> - Explanations that clarify and provide more detail to particular topics</li>
<li><a href="./reference/reference.html">Reference</a> - Technical information</li>
</ol>
<h2 id="about-the-project"><a class="header" href="#about-the-project">About the Project</a></h2>
<p>The project is open-source under the GPL-3.0 license and is available on <a href="https://github.com/cdotrus/orbit">GitHub</a>.</p>
<h2 id="about-the-documentation"><a class="header" href="#about-the-documentation">About the Documentation</a></h2>
<p>Documentation system and methodology is inspired by <a href="https://documentation.divio.com">Divio</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This section walks you the basic steps to get Orbit up and running on your local computer.</p>
<blockquote>
<h3 id="command-line-notation"><a class="header" href="#command-line-notation">Command Line Notation</a></h3>
<p>Throughout the tutorials and the rest of the book, commands will be shown that are used in the terminal. Lines that are entered in a terminal are denoted by starting with a $. The $ is just a special marker; it is not to be entered with the command. Lines that don't start with a $ are typically the output of the previous command.</p>
</blockquote>
<p>There are two processes to obtaining and maintaining Orbit:</p>
<ol>
<li><a href="starting/./installing.html">Installing</a></li>
<li><a href="starting/./upgrading.html">Upgrading</a></li>
</ol>
<h2 id="seeking-help"><a class="header" href="#seeking-help">Seeking Help</a></h2>
<p>Orbit is a package manager and development tool. With learning new tools there is always a learning curve. Orbit tries to make it less intimidating to use by offering help and information in a variety of ways:</p>
<ul>
<li>To see a list of common commands and options, just use <code>orbit</code> with no arguments.</li>
<li>To view quick summaries on commands, use <code>-h, --help</code> flags.</li>
<li>To view more detailed manual pages and information, use <code>orbit help</code>.</li>
</ul>
<p>But since you are here, complete documentation can be found on this website.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing"><a class="header" href="#installing">Installing</a></h1>
<p>There are two main methods for getting Orbit running on your computer: downloading a precompiled binary or by using Cargo.</p>
<blockquote>
<p><strong>Reminder:</strong> By installing and using Orbit, you accept usage under its GPL-3.0 license.</p>
</blockquote>
<h2 id="1-using-a-precompiled-binary"><a class="header" href="#1-using-a-precompiled-binary">1. Using a precompiled binary</a></h2>
<ol>
<li>Visit Orbit's <a href="https://github.com/cdotrus/orbit/releases">releases</a> page on Github to find all of its official releases. </li>
<li>Download the binary for your computer's architecture and operating system.</li>
<li>Install Orbit. Either run the provided <code>install</code> executable or follow the manual instructions for placing Orbit's executable (<code>orbit</code> for Unix and <code>orbit.exe</code> for Windows) in a location recognized by the PATH environment variable.</li>
</ol>
<p>There are multiple solutions to accomplish step 3. The following outlines one way to manually install Orbit depending on the user's operating system. </p>
<h3 id="unix"><a class="header" href="#unix">Unix</a></h3>
<ol>
<li>Open a new terminal (Bash) to where Orbit was downloaded.</li>
<li>Unzip the prebuilt package.</li>
</ol>
<pre><code>$ unzip orbit-0.13.0-x86_64-macos.zip
</code></pre>
<ol start="3">
<li>Move the executable to a location already set in the PATH environment variable. </li>
</ol>
<pre><code>$ mv ./orbit-0.13.0-x86_64-macos/bin/orbit /usr/local/bin/orbit
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<ol>
<li>
<p>Open a new terminal (Powershell) to where Orbit was downloaded.</p>
</li>
<li>
<p>Unzip the prebuilt package.</p>
</li>
</ol>
<pre><code>$ expand-archive &quot;./orbit-0.13.0-x86_64-windows.zip&quot;
</code></pre>
<ol start="3">
<li>Make a new directory to store this package.</li>
</ol>
<pre><code>$ new-item -path &quot;$env:LOCALAPPDATA/Programs/orbit&quot; -itemtype directory
</code></pre>
<ol start="4">
<li>Move the package to the new directory.</li>
</ol>
<pre><code>$ copy-item &quot;./orbit-0.13.0-x86_64-windows/*&quot; -destination &quot;$env:LOCALAPPDATA/Programs/orbit&quot; -recurse
</code></pre>
<ol start="5">
<li>Edit the user-level PATH environment variable in <em><strong>Control Panel</strong></em> by adding <strong>%LOCALAPPDATA%\Programs\orbit\bin</strong>.</li>
</ol>
<h2 id="2-installing-with-cargo"><a class="header" href="#2-installing-with-cargo">2. Installing with Cargo</a></h2>
<p>To install the latest version through Cargo:</p>
<pre><code>$ cargo install --git https://github.com/cdotrus/orbit.git --tag 0.13.0
</code></pre>
<p>This will build the <code>orbit</code> binary and place it a path already set in the PATH environment variable.</p>
<h2 id="checking-if-orbit-is-installed-correctly"><a class="header" href="#checking-if-orbit-is-installed-correctly">Checking if Orbit is installed correctly</a></h2>
<p>To verify Orbit is working correctly on your system, let's open a new terminal session and print it's current version.</p>
<pre><code>$ orbit --version
</code></pre>
<pre><code>orbit 0.13.0
</code></pre>
<p>This should print out your version of Orbit you installed. Congratulations! You are now ready to begin using Orbit.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrading"><a class="header" href="#upgrading">Upgrading</a></h1>
<p>Once Orbit is installed, it can be self-upgraded to the latest official released version found on its Github repository.</p>
<pre><code>$ orbit --upgrade
</code></pre>
<p>This behavior performs the following strategy:</p>
<ol>
<li>
<p>Removes any executable in the executable's directory starting with <code>orbit-</code> (these are considered stale binaries, such as <code>orbit-0.1.0</code>).</p>
</li>
<li>
<p>Connects to <a href="https://github.com/cdotrus/orbit/releases">https://github.com/cdotrus/orbit/releases</a> to find the most recent released version.</p>
</li>
<li>
<p>Checks if the most recent version online is ahead of the currently installed version.</p>
</li>
</ol>
<blockquote>
<p><strong>Note</strong>: If the version online is newer, a prompt will appear to confirm you wish to install the new version. This prompt can be bypassed by adding the <code>--force</code> flag to the previous command.</p>
</blockquote>
<ol start="4">
<li>
<p>Downloads the checksum file to a temporary directory to see if there is a prebuilt package available for the current architecture and operating system.</p>
</li>
<li>
<p>Downloads the package to a temporary directory and computes the checksum to verify the contents.</p>
</li>
<li>
<p>Renames the current executable by appending its version to the name (marking it as a stale binary, such as <code>orbit-0.1.1</code>).</p>
</li>
<li>
<p>Unzips the package and moves the new executable to the original executable's location.</p>
</li>
</ol>
<blockquote>
<p><strong>Note</strong>: If you wish to remove the newly created stale binary after an upgrade, rerunning <code>orbit --upgrade</code> immediately again will perform step 1 and stop at step 3.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>This section provides step-by-step instructions through examples of basic ways for interacting with <code>orbit</code>.</p>
<blockquote>
<h3 id="command-line-notation-1"><a class="header" href="#command-line-notation-1">Command Line Notation</a></h3>
<p>Throughout the tutorials and the rest of the book, commands will be shown that are used in the terminal. Lines that are entered in a terminal are denoted by starting with a $. The $ is just a special marker; it is not to be entered with the command. Lines that don't start with a $ are typically the output of the previous command.</p>
</blockquote>
<p>Before starting the tutorials, it is assumed you possess basic knowledge of the following topics:</p>
<ul>
<li>sending commands through the command-line</li>
<li>digital logic concepts</li>
<li>navigating your computer's local file system</li>
</ul>
<br>
<blockquote>
<p><strong>Note:</strong> The HDL code used for this section may be very didactic in nature and is not intended to reflect production-level code or any particular coding style.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-project-gates"><a class="header" href="#first-project-gates">First Project: Gates</a></h1>
<p>In this tutorial, you will learn how to:</p>
<p><a href="tutorials/first_project.html#creating-an-ip">1.</a> Create an IP from scratch<br />
<a href="tutorials/first_project.html#integrating-design-units">2.</a> Leverage <code>orbit</code> to integrate an entity into a larger design<br />
<a href="tutorials/first_project.html#building-an-ip-for-a-scripted-workflow">3.</a> Build a design using a simple plugin<br />
<a href="tutorials/first_project.html#making-an-ip-and-its-design-units-reusable">4.</a> Release a version of an IP</p>
<h2 id="creating-an-ip"><a class="header" href="#creating-an-ip">Creating an IP</a></h2>
<p>First, navigate to a directory in your file system where you would like to store the project. From there, let's issue our first <code>orbit</code> command:</p>
<pre><code>$ orbit new gates
</code></pre>
<p>A directory called &quot;gates&quot; should now exist and look like the following tree structure:</p>
<pre><code>gates/
└─ Orbit.toml
</code></pre>
<p>Let's create our first design unit for describing a NAND gate. Feel free to copy the following code into a file called &quot;nand_gate.vhd&quot; that exists in our project directory &quot;gates/&quot;.</p>
<p>Filename: nand_gate.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

entity nand_gate is
  port(
    a, b : in std_logic;
    x : out std_logic
  );
end entity;

architecture rtl of nand_gate is
begin
  x &lt;= a nand b;

end architecture;
</code></pre>
<h2 id="integrating-design-units"><a class="header" href="#integrating-design-units">Integrating design units</a></h2>
<p>Consider for an instant that our HDL only supports the <code>nand</code> keyword and is missing the other logic gates such as <code>or</code>, <code>and</code>, and <code>xor</code>.</p>
<p>Recalling our basic knowledge of digital circuits, we know a NAND gate is a universal gate, so let's compose other gates using our newly created <code>nand_gate</code> entity. Create a new file for our next design unit to describe an AND gate. </p>
<p>Filename: and_gate.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

entity and_gate is
  port(
    a, b : in std_logic;
    y : out std_logic
  );
end entity;

architecture rtl of and_gate is
begin
    -- What to put here?

end architecture;
</code></pre>
<p>After some thinking, we realize we can use two NAND gates together to construct an AND gate. Let's use <code>orbit</code> to help us integrate our <code>nand_gate</code> entity into the <code>and_gate</code>'s architecture.</p>
<pre><code>$ orbit get nand_gate --component --signals --instance
</code></pre>
<pre><code>component nand_gate
  port(
    a : in std_logic;
    b : in std_logic;
    x : out std_logic
  );
end component;

signal a : std_logic;
signal b : std_logic;
signal x : std_logic;

uX : nand_gate
  port map(
    a =&gt; a,
    b =&gt; b,
    x =&gt; x
  );
</code></pre>
<p>With this single command, <code>orbit</code> provided us with:</p>
<ul>
<li>the component declaration</li>
<li>signals for the port interface</li>
<li>an instantiation template</li>
</ul>
<p>Sweet! After some quick copy/pasting and signal renaming, we have our architecture described for an AND gate.</p>
<p>Filename: and_gate.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

entity and_gate is
  port(
    a, b : in std_logic;
    y : out std_logic
  );
end entity;

architecture rtl of and_gate is
  
  component nand_gate
    port(
      a : in std_logic;
      b : in std_logic;
      x : out std_logic
    );
  end component;

  signal x : std_logic;

begin

  u1 : nand_gate
    port map(
      a =&gt; a,
      b =&gt; b,
      x =&gt; x
    );

  u2 : nand_gate
    port map(
      a =&gt; x,
      b =&gt; x,
      x =&gt; y
    );

end architecture;
</code></pre>
<p>Let's make a quick check to verify our <code>and_gate</code> is using our <code>nand_gate</code>.</p>
<pre><code>$ orbit tree
</code></pre>
<pre><code>and_gate
└─ nand_gate
</code></pre>
<p>Cool! We got a hierarchical view of our top-most design unit.</p>
<h2 id="building-an-ip-for-a-scripted-workflow"><a class="header" href="#building-an-ip-for-a-scripted-workflow">Building an IP for a scripted workflow</a></h2>
<p>After all of our hard work, we are excited to show off our latest design on the newest Yilinx FPGA that just arrived in the mail. You realize you need a way to get your HDL code to the Yilinx synthesis tool in order to generate the final bitstream for your FPGA.</p>
<p>To make this possible, <code>orbit</code> breaks down the process into two stages: <em>plan</em> and <em>build</em>.</p>
<h3 id="planning"><a class="header" href="#planning">Planning</a></h3>
<p>Let's create a file that lists all the files we will need to give to the Yilinx synthesis tool.</p>
<pre><code>$ orbit plan
</code></pre>
<p>This command produced a file, called the <em>blueprint</em>, that lists all the required files in a <em>topologically-sorted</em> order for any backend tool that needs to know.</p>
<p>Filename: build/blueprint.tsv</p>
<pre><code class="language-text">VHDL-RTL	work	/Users/chase/tutorials/gates/nand_gate.vhd
VHDL-RTL	work	/Users/chase/tutorials/gates/and_gate.vhd

</code></pre>
<p>Now we just need a way for our Yilinx synthesis tool to be able to interpet and use our blueprint file. Enter <em>plugins</em>.</p>
<h3 id="building"><a class="header" href="#building">Building</a></h3>
<p>A plugin is a script created by us that acts as the layer between our blueprint file and the tool we want to use. Let's make one for our Yilinx synthesis tool using the Python programming language.</p>
<p>Filename: .orbit/yilinx.py</p>
<pre><code class="language-python">synth_order = []
# Read and parse the blueprint file
with open('blueprint.tsv') as blueprint:
    rules = blueprint.readlines()
    for r in rules:
        fileset, lib, path = r.strip().split('\t')
        if fileset == 'VHDL-RTL':
            synth_order += [(lib, path)]
    pass

# Use the Yilinx tool to perform synthesize on the HDL files
for (lib, path) in synth_order:
    print('YILINX:', 'Synthesizing file ' + str(path) +' into ' + str(lib) + '...')

# Use the Yilinx tool to perform placement and routing
print('YILINX:','Performing place-and-route...')

# Use the Yilinx tool to generate the bitstream
print('YILINX:', 'Generating bitstream...')
with open('fpga.bit', 'w') as bitstream:
    bitstream.write('011010101101' * 2)

print('YILINX:','Bitstream saved at: build/fpga.bit')

</code></pre>
<p>In order for <code>orbit</code> to know about our plugin, we need to tell <code>orbit</code> about the plugin in a configuration file. For this project, we edit the project-level configurations.</p>
<p>Filename: .orbit/config.toml</p>
<pre><code class="language-toml">[[plugin]]
name = &quot;yilinx&quot;
description = &quot;Generate bitstreams for Yilinx FPGAs&quot;
command = &quot;python&quot;
args = [&quot;yilinx.py&quot;]
</code></pre>
<p>Okay, all steps are in place! Let's generate a bitsream.</p>
<pre><code>$ orbit build --plugin yilinx
</code></pre>
<pre><code>YILINX: Synthesizing file /Users/chase/tutorials/gates/nand_gate.vhd into work...
YILINX: Synthesizing file /Users/chase/tutorials/gates/and_gate.vhd into work...
YILINX: Performing place-and-route...
YILINX: Generating bitstream...
YILINX: Bitstream saved at: build/fpga.bit
</code></pre>
<p>Typically, we create plugins to interface with EDA tools which will in turn produce desired output files. We see Yilinx saved our bitstream for us to program our FPGA. Cool!</p>
<p>Filename: build/fpga.bit</p>
<pre><code class="language-text">011010101101011010101101
</code></pre>
<h2 id="making-an-ip-and-its-design-units-reusable"><a class="header" href="#making-an-ip-and-its-design-units-reusable">Making an IP and its design units reusable</a></h2>
<p>Now we are ready to move on to more advanced topics, so let's go ahead and store an immutable reference to this project to use in other projects in our developer journey. </p>
<pre><code>$ orbit install --path .
</code></pre>
<p>This command ran a series of steps that packaged our project and placed it into our <em>cache</em>. Internally, <code>orbit</code> knows where our cache is and can reference designs from our cache when we request them. Let's make sure our project was properly installed by viewing our entire IP catalog.</p>
<pre><code>$ orbit search
</code></pre>
<pre><code>Package                     Latest    Status   
--------------------------- --------- ---------- 
gates                       0.1.0     Installed
</code></pre>
<p>And there it is! Let's continue to the next tutorial, where we introduce dependencies across IPs.</p>
<h3 id="additional-notes-on-project-structure"><a class="header" href="#additional-notes-on-project-structure">Additional notes on project structure</a></h3>
<p>Our final project structure looks like the following:</p>
<pre><code>gates/
├─ .orbit/
│  ├─ config.toml
│  └─ yilinx.py
├─ build/
│  ├─ blueprint.tsv
│  └─ fpga.bit
├─ Orbit.toml
├─ Orbit.lock
├─ and_gate.vhd
└─ nand_gate.vhd
</code></pre>
<ul>
<li>
<p>The configurations stored in &quot;.orbit/&quot; exist only for this project; to store configurations that persist across projects make changes to the $ORBIT_HOME directory.</p>
</li>
<li>
<p><code>orbit</code> creates an output directory to store the blueprint and any tool output files during a build. These files should reside in &quot;build/&quot; and may change often during development (probably don't check this directory into version control).</p>
</li>
<li>
<p><code>orbit</code> creates a lock file &quot;Orbit.lock&quot; to store all the information required to manage and recreate the exact state of this project. It is a good idea to always keep it and to not manually edit it (probably be sure to check this file into version control).</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies-half-adder"><a class="header" href="#dependencies-half-adder">Dependencies: Half adder</a></h1>
<p>In this tutorial, you will learn how to:</p>
<p><a href="tutorials/dependencies.html#referencing-external-ips">1.</a> Specify an external IP as a dependency<br />
<a href="tutorials/dependencies.html#learning-about-ips">2.</a> Use <code>orbit</code> to learn more about external IPs and their design units<br />
<a href="tutorials/dependencies.html#integrating-design-units-across-ips">3.</a> Leverage <code>orbit</code> across IPs to integrate an entity into a separate IP</p>
<h2 id="referencing-external-ips"><a class="header" href="#referencing-external-ips">Referencing external IPs</a></h2>
<p>After completing the gates project from the previous tutorial ahead of schedule, you take a well deserved vacation. Now you have returned to work and are tasked with building a half adder.</p>
<p>Let's create a new project. Navigate to a directory in your file system where you would like to store the project.</p>
<pre><code>$ orbit new half-add
</code></pre>
<p>For the rest of this tutorial, we will be working relative to the project directory &quot;half-add/&quot; that was created by the previous command.</p>
<p>Remembering our impressive work with the gates project, we realize we can reuse some of the already designed and tested components from there. Let's make sure it's installed so that we can use it.</p>
<pre><code>$ orbit search gates
</code></pre>
<pre><code>Package                     Latest    Status   
--------------------------- --------- ---------- 
gates                       0.1.0     Installed

</code></pre>
<p>Awesome! Our next step is tell <code>orbit</code> that our current project, half-add, wants to use gates as a dependency.</p>
<p>Add a new entry for gates to the dependencies table in our project's manifest, Orbit.toml.</p>
<p>Filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
name = &quot;half-add&quot;
version = &quot;0.1.0&quot;

# See more keys and their definitions at https://cdotrus.github.io/orbit/reference/manifest.html

[dependencies]
gates = &quot;0.1.0&quot;
</code></pre>
<p>We've referenced it, now we have to use it!</p>
<h2 id="learning-about-ips"><a class="header" href="#learning-about-ips">Learning about IPs</a></h2>
<p>Your memory is a little foggy on what gates actually did, and what entities were available. Luckily, we can query for information through <code>orbit</code> about IPs and their design units.</p>
<p>Let's remember what entities we have at our disposal.</p>
<pre><code>$ orbit show gates --units
</code></pre>
<pre><code>Identifier                          Type          Visibility   
----------------------------------- ------------- ----------- 
and_gate                            entity        public 
nand_gate                           entity        public 
</code></pre>
<p>Okay, how did we implement the NAND gate architecture?</p>
<pre><code>$ orbit read --ip gates nand_gate --start architecture
</code></pre>
<pre><code>architecture rtl of nand_gate is
begin

  x &lt;= a nand b;

end architecture;
</code></pre>
<p>Cool, we used the VHDL keyword. Sometimes it may be insightful to read code snippets and comments from external design units when trying to integrate them into a new project.</p>
<h2 id="integrating-design-units-across-ips"><a class="header" href="#integrating-design-units-across-ips">Integrating design units across IPs</a></h2>
<p>Let's use the NAND gate we previously defined to construct a half adder circuit.</p>
<pre><code>$ orbit get --ip gates nand_gate --signals --instance
</code></pre>
<pre><code>library work;

signal a : std_logic;
signal b : std_logic;
signal x : std_logic;

uX : entity work.nand_gate
  port map(
    a =&gt; a,
    b =&gt; b,
    x =&gt; x
  );
</code></pre>
<p>A half adder can be constructed with 5 NAND gates. It's time to copy/paste our NAND gate instances into our new file &quot;half_add.vhd&quot;.</p>
<p>Filename: half_add.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

library work;

entity half_add is
  port(
    a, b : in std_logic;
    c, s : out std_logic
  );
end entity;

architecture rtl of half_add is
  
  signal x4, x1, x2 : std_logic;

begin

  -- 1st layer: This gate creates the first NAND intermediate output.
  u4 : entity work.nand_gate
    port map(
      a =&gt; a,
      b =&gt; b,
      x =&gt; x4
    );
  
  -- 2nd layer: Perform NAND with input 'a' and the 1st layer's output.
  u1 : entity work.nand_gate
    port map(
      a =&gt; a,
      b =&gt; x4,
      x =&gt; x1
    );

  -- 2nd layer: Perform NAND with input 'b' and the 1st layer's output.
  u2 : entity work.nand_gate
    port map(
      a =&gt; x4,
      b =&gt; b,
      x =&gt; x2
    );

  -- 3rd layer: This gate produces the final sum signal ('a' XOR 'b').
  u3 : entity work.nand_gate
    port map(
      a =&gt; x1,
      b =&gt; x2,
      x =&gt; s
    );

  -- 3rd layer: This gate produces the final carry out signal ('a' AND 'b').
  u5 : entity work.nand_gate
    port map(
      a =&gt; x4,
      b =&gt; x4,
      x =&gt; c
    );

end architecture;
</code></pre>
<p>Let's inspect the design hierarchy to make sure our circuit and its components are identified by <code>orbit</code>.</p>
<pre><code>$ orbit tree --format long
</code></pre>
<pre><code>half_add (half-add:0.1.0)
└─ nand_gate (gates:0.1.0)
</code></pre>
<p>Finally, let's install this IP to the cache for future reuse as well.</p>
<pre><code>$ orbit install --path .
</code></pre>
<p>Nice, now we have successfully reused designs across IPs! However, maybe we should have designed all the logic gates in the gates IP...</p>
<h3 id="additional-notes-on-dependencies"><a class="header" href="#additional-notes-on-dependencies">Additional notes on dependencies</a></h3>
<p>Before integrating a design unit from an external IP into a separate project, it's important to first update the Orbit.toml file. This manifest file has a dependencies section, which allows you to tell <code>orbit</code> which IPs to bring into the current project scope. Without the IPs in scope, <code>orbit</code> may be unable to identify where you got a reference for a particular design unit. <code>orbit</code> denotes an unknown design unit with a ? when displaying the design hierarchy.</p>
<pre><code>half_add (half-add:0.1.0)
└─ nand_gate ?
</code></pre>
<p>After introducing dependencies at the project level, it's also important to maintain an up-to-date lockfile Orbit.lock.</p>
<pre><code>$ orbit plan --lock-only
</code></pre>
<p>The lockfile saves information for <code>orbit</code> to use later when needing to reconstruct the state of an IP. This includes saving information about all IP dependencies, their checksums, and potential sources of retrieval. Remember, the Orbit.lock file is automatically managed by <code>orbit</code> and does not require direct user editing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gates-revisited"><a class="header" href="#gates-revisited">Gates: Revisited</a></h1>
<p>In this tutorial, you will learn how to:</p>
<p><a href="tutorials/gates_revisited.html#updating-the-gates-ip">1.</a> Edit an existing IP<br />
<a href="tutorials/gates_revisited.html#extending-the-yilinx-plugin">2.</a> Use environment variables and command-line arguments to create more robust plugins<br />
<a href="tutorials/gates_revisited.html#rereleasing-the-gates-ip">3.</a> Release the next version for an existing IP</p>
<h2 id="editing-the-gates-ip"><a class="header" href="#editing-the-gates-ip">Editing the gates IP</a></h2>
<p>It seems we left out some logic gates when we last worked on the gates project, so let's implement them now. Navigate to the directory in your file system where you currently store the gates project.</p>
<p>For the rest of this tutorial, we will be working relative to the project directory &quot;gates/&quot; that currently stores the gates project.</p>
<p>Let's implement the OR gate while restricting our design to only NAND gates like before. </p>
<pre><code>$ orbit get nand_gate --signals --instance
</code></pre>
<pre><code>library work;

signal a : std_logic;
signal b : std_logic;
signal x : std_logic;

uX : entity work.nand_gate
  port map(
    a =&gt; a,
    b =&gt; b,
    x =&gt; x
  );
</code></pre>
<p>An OR gate can be constructed using 3 NAND gates. Let's copy/paste our NAND gate instances into our new file &quot;or_gate.vhd&quot;.</p>
<p>Filename: or_gate.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

library work;

entity or_gate is
  port(
    a, b : in std_logic;
    y : out std_logic
  );
end entity;

architecture rtl of or_gate is

  signal x1, x2 : std_logic;

begin
  -- 1st layer: This gate negates the first input 'a'.
  u1 : entity work.nand_gate
    port map(
      a =&gt; a,
      b =&gt; a,
      x =&gt; x1
    );

  -- 1st layer: This gate negates the second input 'b'.
  u2 : entity work.nand_gate
    port map(
      a =&gt; b,
      b =&gt; b,
      x =&gt; x2
    );
    
  -- 2nd layer: This gate produces the final output ('a' OR 'b').
  u3 : entity work.nand_gate
    port map(
      a =&gt; x1,
      b =&gt; x2,
      x =&gt; y
    );

end architecture;
</code></pre>
<p>Showing the list of possible design units for the current project should now include the OR gate entity.</p>
<pre><code>$ orbit show --units
</code></pre>
<pre><code>Identifier                          Type          Visibility   
----------------------------------- ------------- ----------- 
and_gate                            entity        public
nand_gate                           entity        public 
or_gate                             entity        public 
</code></pre>
<h2 id="extending-the-yilinx-plugin"><a class="header" href="#extending-the-yilinx-plugin">Extending the Yilinx plugin</a></h2>
<p>Next, we want to program our Yilinx FPGA with the OR gate design to test it on the board. However, there are some quick updates we first want to apply to the &quot;.orbit/yilinx.py&quot; script.</p>
<ul>
<li>We want a way to specify which I/O pins of the FPGA will be used during placement and routing</li>
<li>We want a way to specify whether to program the FPGA bitstream to SRAM storage (volatile) or flash storage (nonvolatile).</li>
</ul>
<p>After searching through Yilinx documentation for hours, you learn that the Yilinx design tool can accept .ydc files for FPGA pin assignments. Let's edit our yilinx plugin to collect any .ydc files our project may have during <code>orbit</code>'s planning step.</p>
<p>Filename: .orbit/config.toml</p>
<pre><code class="language-toml">[[plugin]]
name = &quot;yilinx&quot;
command = &quot;python&quot;
description = &quot;Generate bitstreams for Yilinx FPGAs&quot;
args = [&quot;yilinx.py&quot;]
# Define the type of extra file(s) to collect during planning
fileset.pin-file = &quot;*.ydc&quot;
</code></pre>
<p>Now let's create our pin assignment file for our OR gate design.</p>
<p>Filename: pins.ydc</p>
<pre><code class="language-text">A1=a
A2=b
C7=y
</code></pre>
<p>Next, let's edit the Python script for the yilinx plugin to allow the Yilinx tool to use our .ydc file if we ever collect one into our blueprint file. We also want to accept command-line arguments to optionally program our FPGA using SRAM or flash storage.</p>
<p>Filename: .orbit/yilinx.py</p>
<pre><code class="language-Python">import sys, os

# Handle command-line arguments
PROG_SRAM = bool(sys.argv.count('--sram') &gt; 0)
PROG_FLASH = bool(sys.argv.count('--flash') &gt; 0)

# Get environment variables set by orbit for this particular build
BLUEPRINT = os.environ.get(&quot;ORBIT_BLUEPRINT&quot;)
BUILD_DIR = os.environ.get(&quot;ORBIT_BUILD_DIR&quot;)
TOP_LEVEL = os.environ.get(&quot;ORBIT_TOP&quot;)

synth_order = []
constraints_file = None

# Parse the blueprint file created by orbit
with open(BLUEPRINT) as blueprint:
    rules = blueprint.readlines()
    for r in rules:
        fileset, lib, path = r.strip().split('\t')
        if fileset == 'VHDL-RTL':
            synth_order += [(lib, path)]
        if fileset == 'PIN-FILE':
            constraints_file = path
    pass

# Run the Yilinx tool from synthesis to bistream generation
for (lib, path) in synth_order:
    print('YILINX:', 'Synthesizing file ' + str(path) + ' into ' + str(lib) + '...')

print('YILINX:','Performing place-and-route...')

# Read the Yilinx design constraints file to map pins to I/O top-level ports.
if constraints_file != None:
    with open(constraints_file, 'r') as ydc:
        mapping = [x.strip().split('=') for x in ydc.readlines()]
    for pin, port in mapping:
        print('YILINX:', 'Mapping pin ' + str(pin) + ' to port ' + str(port) + '...')
    pass

print('YILINX:', 'Generating bitstream...')

BIT_FILE = TOP_LEVEL + '.bit'
with open(BIT_FILE, 'w') as bitstream:
    for byte in [bin(b)[2:] for b in bytes(TOP_LEVEL, 'utf-8')]:
        bitstream.write(byte)

print('YILINX:','Bitstream saved at: '+ str(BUILD_DIR + '/' + BIT_FILE))

# Optionally allow the user to program the FPGA using flash or SRAM configuration
if PROG_FLASH == True and PROG_SRAM == False:
    print('YILINX:', 'Programming bitstream to flash...')
elif PROG_SRAM == True:
    print('YILINX:', 'Programming bitstream to SRAM...')

</code></pre>
<p>With all these changes, we can now go ahead and program our FPGA as we want!</p>
<p>First, let's plan the OR gate design. We can specify which entity is the top level by using the &quot;--top&quot; command-line option. The &quot;--plugin&quot; command-line option tells <code>orbit</code> what additional files to collect for a future build with that plugin.</p>
<pre><code>$ orbit plan --plugin yilinx --top or_gate 
</code></pre>
<p>Let's take a look at the blueprint file <code>orbit</code> just created.</p>
<p>Filename: build/blueprint.tsv</p>
<pre><code class="language-text">PIN-FILE	work	/Users/chase/tutorials/gates/pins.ydc
VHDL-RTL	work	/Users/chase/tutorials/gates/nand_gate.vhd
VHDL-RTL	work	/Users/chase/tutorials/gates/or_gate.vhd

</code></pre>
<p>Inspecting our latest blueprint file reveals our .ydc file was successfully collected.</p>
<p>Finally, let's build our design. We can pass command-line arguments directly to the plugin by entering them after the &quot;--&quot; argument.</p>
<pre><code>$ orbit build --plugin yilinx -- --flash
</code></pre>
<pre><code>YILINX: Synthesizing file /Users/chase/tutorials/gates/nand_gate.vhd into work...
YILINX: Synthesizing file /Users/chase/tutorials/gates/or_gate.vhd into work...
YILINX: Performing place-and-route...
YILINX: Mapping pin A1 to port a...
YILINX: Mapping pin A2 to port b...
YILINX: Mapping pin C7 to port y...
YILINX: Generating bitstream...
YILINX: Bitstream saved at: build/or_gate.bit
YILINX: Programming bitstream to flash...
</code></pre>
<p>As expected, the bitstream is written and saved in our build directory.</p>
<p>Filename: build/or_gate.bit</p>
<pre><code class="language-text">1101111111001010111111100111110000111101001100101
</code></pre>
<p>Awesome! We added some pretty advanced settings to our yilinx plugin to make it more robust for future use. Let's configure this plugin to be used with any of our ongoing projects by editing the global configuration file through the command-line.</p>
<pre><code>$ orbit config --global --append include=&quot;$(orbit env ORBIT_IP_PATH)/.orbit/config.toml&quot;
</code></pre>
<p>Now when we call <code>orbit</code> from any directory, we can see our yilinx plugin is available to use.</p>
<pre><code>$ orbit plan --list
</code></pre>
<pre><code>Plugins:
  yilinx          Generate bitstreams for Yilinx FPGAs
</code></pre>
<h2 id="rereleasing-the-gates-ip"><a class="header" href="#rereleasing-the-gates-ip">Rereleasing the gates IP</a></h2>
<p>We made changes to the gates IP, and now we want to have the ability to use these new updates or continue using the old changes. To do this, we want to update the version number in the manifest file. Let's edit the Orbit.toml file's version field to contain version &quot;1.0.0&quot;.</p>
<p>Filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
name = &quot;gates&quot;
version = &quot;1.0.0&quot;

# See more keys and their definitions at https://cdotrus.github.io/orbit/reference/manifest.html

[dependencies]

</code></pre>
<p>Finally, let's release version 1.0.0 for the gates IP by installing it to our cache.</p>
<pre><code>$ orbit install --path .
</code></pre>
<p>One last look at the catalog shows the latest version of gates we have installed is indeed 1.0.0. Nice work!</p>
<pre><code>$ orbit search gates
</code></pre>
<pre><code>Package                     Latest    Status   
--------------------------- --------- ---------- 
gates                       1.0.0     Installed
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-project-full-adder"><a class="header" href="#final-project-full-adder">Final Project: Full adder</a></h1>
<p>In this tutorial, you will learn how to:</p>
<p><a href="tutorials/final_project.html#specifying-multiple-dependencies-for-an-ip">1.</a> Depend on multiple IPs for a single project<br />
<a href="tutorials/final_project.html#overcoming-hdl-problems-namespace-pollution">2.</a> Use <code>orbit</code> to overcome namespace pollution<br />
<a href="tutorials/final_project.html#reusing-plugins-that-are-globally-configured">3.</a> Build a project with a globally-configured plugin</p>
<h2 id="specifying-multiple-dependencies-for-an-ip"><a class="header" href="#specifying-multiple-dependencies-for-an-ip">Specifying multiple dependencies for an IP</a></h2>
<p>After the quick detour back to the gates IP, we are ready to tackle our final challenge in this mini tutorial series: the full adder. Like our previous projects, navigate to a directory in your file system where you would like to store the project.</p>
<pre><code>orbit new full-add
</code></pre>
<p>For the rest of this tutorial, we will be working relative to the project directory &quot;full-add/&quot; that currently stores our new full-add project. </p>
<p>For this final project, we will need circuits described in both the gate IP and half-add IP. Let's quickly recall if version 1.0.0 of gates has the OR gate we will need.</p>
<pre><code>$ orbit show gates:1.0.0 --units
</code></pre>
<pre><code>Identifier                          Type          Visibility   
----------------------------------- ------------- ----------- 
and_gate                            entity        public 
nand_gate                           entity        public 
or_gate                             entity        public 
</code></pre>
<p>Yup! It's there, and we know we will need some half adders as well. Let's add both IPs to our manifest file.</p>
<p>filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
name = &quot;full-add&quot;
version = &quot;0.1.0&quot;

# See more keys and their definitions at https://cdotrus.github.io/orbit/reference/manifest.html

[dependencies]
gates = &quot;1.0.0&quot;
half-add = &quot;0.1.0&quot;

</code></pre>
<p>Okay, time to start coding!</p>
<h2 id="overcoming-hdl-problems-namespace-pollution"><a class="header" href="#overcoming-hdl-problems-namespace-pollution">Overcoming HDL problems: Namespace pollution</a></h2>
<p>Our full adder circuit will be constructed of 2 half adders and an OR gate. Let's collect some HDL code snippets to use for our full adder circuit.</p>
<pre><code>$ orbit get half_add --ip half-add --instance
</code></pre>
<pre><code>library work;

uX : entity work.half_add
  port map(
    a =&gt; a,
    b =&gt; b,
    c =&gt; c,
    s =&gt; s
  );
</code></pre>
<p>And let's get the code snippet for the OR gate as well.</p>
<pre><code>orbit get or_gate --ip gates:1.0.0 --instance
</code></pre>
<pre><code>library work;

uX : entity work.or_gate
  port map(
    a =&gt; a,
    b =&gt; b,
    y =&gt; y
  );
</code></pre>
<p>Let's combine these circuits together into our new file for our full adder implementation.</p>
<p>Filename: full_add.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

library work;

entity full_add is
  port(
    a, b, cin : in std_logic;
    cout, s : out std_logic
  );
end entity;

architecture rtl of full_add is
  
  signal c_ha0, s_ha0, c_ha1 : std_logic;

begin

  -- 1st layer: Peform half of the addition operation.
  u_ha0 : entity work.half_add
    port map(
      a =&gt; a,
      b =&gt; b,
      c =&gt; c_ha0,
      s =&gt; s_ha0
    );

  -- 2nd layer: Compute the final sum term.
  u_ha1 : entity work.half_add
    port map(
      a =&gt; s_ha0,
      b =&gt; cin,
      c =&gt; c_ha1,
      s =&gt; s
    );

  -- 3rd layer: Check both c terms from the half adders for the final cout term.
  u_or0 : entity work.or_gate
    port map(
      a =&gt; c_ha0,
      b =&gt; c_ha1,
      y =&gt; cout
    );

end architecture;
</code></pre>
<p>Our design heirarchy is getting more complex; we have full adders constructed of half adders and OR gates, half adders constructed of NAND gates, OR gates constructed of... uh-oh. More NAND gates. </p>
<p>The NAND gate design unit used in the OR gates is different from NAND gates used in the half adders because they reside in different versions of the gates IP (essentially different IPs). So did we just define an NAND gate entity twice with the same identifier? Yes, and thanks to <code>orbit</code>, this situation is okay.</p>
<h3 id="huh"><a class="header" href="#huh">Huh?</a></h3>
<p>Typical EDA tools will complain and error out when primary design units share the same name. How would they know which one is being used where? Fortunately, <code>orbit</code> is one step ahead of these tools due to implementing an algorithm called <em>dynamic symbol transformation</em>.</p>
<p>Let's take a look at the design tree hierarchy. You may notice something interesting.</p>
<pre><code>$ orbit tree --format long
</code></pre>
<pre><code>full_add (full-add:0.1.0)
├─ or_gate (gates:1.0.0)
│  └─ nand_gate (gates:1.0.0)
└─ half_add (half-add:0.1.0)
   └─ nand_gate_8108cfb282 (gates:0.1.0)
</code></pre>
<p>The entities from gates version 0.1.0 and version 1.0.0 are allowed to co-exist in this design. To circumvent EDA tool problems during builds, <code>orbit</code> appends the beginning checksum digits from the IP of the unit in conflict to the design unit's identifier. Any design units that referenced the unit in conflict will also be updated to properly reference the new identifier for the unit in conflict. </p>
<p>To us though, these slight identifier renamings remain hidden because they occur among indirect dependencies in relation to our current project. When deciding which design unit to rename, <code>orbit</code> will always choose to rename the unit that is used as an indirect dependency. This key choice allows us to keep using the original unit name when integrating design units into the current project.</p>
<h3 id="okay-so-what"><a class="header" href="#okay-so-what">Okay, so what?</a></h3>
<p>This may be a silly example, but there is a key takeaway here. Designs are constantly evolving. When creating the latest module, you never know what will come next. By allowing the state of a design to live on while also providing support for new growth, a user no longer spends their time trying to manage compatibility among the increasingly interconnected dependencies. Instead, there exists a freedom to continue to innovate.</p>
<h2 id="reusing-plugins-that-are-globally-configured"><a class="header" href="#reusing-plugins-that-are-globally-configured">Reusing plugins that are globally-configured</a></h2>
<p>To conclude this mini tutorial series, let's generate a bitstream for the Yilinx FPGA with our full adder implementation. </p>
<p>First, let's verify our yilinx plugin is available to us after appending it to our global configuration file in the previous tutorial.</p>
<pre><code>$ orbit plan --list
</code></pre>
<pre><code>Plugins:
  yilinx          Generate bitstreams for Yilinx FPGAs
</code></pre>
<p>We can review more details about a particular plugin by specifying it with the &quot;--plugin&quot; command-line option while providing &quot;--list&quot; as well.</p>
<pre><code>$ orbit plan --list --plugin yilinx
</code></pre>
<pre><code>Name:    yilinx
Command: python &quot;yilinx.py&quot; 
Root:    /Users/chase/tutorials/gates/.orbit
Filesets:
    PIN-FILE        **/*.ydc

Generate bitstreams for Yilinx FPGAs
</code></pre>
<p>Let's plan with the intention to build using the yilinx plugin for our full adder.</p>
<pre><code>$ orbit plan --plugin yilinx --top full_add
</code></pre>
<p>Opening the blueprint file shows we are indeed using different files for the different NAND gate design units, and the files are in a topologically-sorted order.</p>
<p>Filename: build/blueprint.tsv</p>
<pre><code class="language-text">VHDL-RTL	work	/Users/chase/.orbit/cache/gates-0.1.0-fe9ec9d99e/nand_gate.vhd
VHDL-RTL	work	/Users/chase/.orbit/cache/half-add-0.1.0-1c537df196/half_add.vhd
VHDL-RTL	work	/Users/chase/.orbit/cache/gates-1.0.0-4cb065a539/nand_gate.vhd
VHDL-RTL	work	/Users/chase/.orbit/cache/gates-1.0.0-4cb065a539/or_gate.vhd
VHDL-RTL	work	/Users/chase/tutorials/full-add/full_add.vhd

</code></pre>
<p>If a plugin is specified during the most recent planning step, it can be inferred to be used in the building step and therefore we can omit the &quot;--plugin&quot; command-line option for our convenience.</p>
<pre><code>$ orbit build
</code></pre>
<pre><code>YILINX: Synthesizing file /Users/chase/.orbit/cache/gates-0.1.0-fe9ec9d99e/nand_gate.vhd into work...
YILINX: Synthesizing file /Users/chase/.orbit/cache/half-add-0.1.0-1c537df196/half_add.vhd into work...
YILINX: Synthesizing file /Users/chase/.orbit/cache/gates-1.0.0-4cb065a539/nand_gate.vhd into work...
YILINX: Synthesizing file /Users/chase/.orbit/cache/gates-1.0.0-4cb065a539/or_gate.vhd into work...
YILINX: Synthesizing file /Users/chase/tutorials/full-add/full_add.vhd into work...
YILINX: Performing place-and-route...
YILINX: Generating bitstream...
YILINX: Bitstream saved at: build/full_add.bit
</code></pre>
<p>Great work! This marks the end to this tutorial series, but the beginning of your experience with <code>orbit</code>, an HDL package manager.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-guide"><a class="header" href="#user-guide">User Guide</a></h1>
<p>This section provides general solutions to common questions when working with <code>orbit</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topic-guide"><a class="header" href="#topic-guide">Topic Guide</a></h1>
<p>This section provides explanations and clarity to the various systems operated by <code>orbit</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h1>
<p>Orbit is a frontend package manager for HDL development that supports any backend tooling and workflow.</p>
<p><img src="topic/./../images/concept-view.svg" alt="" /></p>
<h2 id="key-points"><a class="header" href="#key-points">Key points</a></h2>
<ul>
<li>
<p>Every IP requires a manifest file (<code>Orbit.toml</code>). This is maintained by the developer. The manifest file documents basic metadata and the project's list of direct dependencies.</p>
</li>
<li>
<p>Backend tools and workflows (makefiles, TCL scripts, etc.) are able to be decoupled from IP and can be reused across projects by defining plugins in the configuration file (<code>config.toml</code>).</p>
</li>
<li>
<p>Orbit does not require a version control system (VCS). Orbit is intended to work with any VCS (git, mercurial, svn, etc.).</p>
</li>
<li>
<p>Orbit solves the namespace collision problem by a form of name mangling when primary design unit identifiers conflict in the dependency tree (<em>dynamic symbol transformation</em>).</p>
</li>
<li>
<p>Download an IP to store a compressed snapshot of a particular version to install later. Downloads are placed in a hidden directory abstracted away from the user and maintained by Orbit.</p>
</li>
<li>
<p>Install an IP to the cache to reuse it in another project (<code>orbit install</code>). The cache is a hidden directory abstracted away from the user and maintained by Orbit.</p>
</li>
<li>
<p>Orbit generates a lock file (<code>Orbit.lock</code>) during the planning phase (<code>orbit plan</code>) after resolving the dependency tree to store all the data required to reproduce the build. The lock file is maintained by Orbit and must be checked into version control.</p>
</li>
<li>
<p>Orbit generates a blueprint file (<code>blueprint.tsv</code>) during the planning phase which lists the in-order HDL files required to build the design. The blueprint may also list other user-defined filesets. The blueprint file is maintained by Orbit. It changes frequently and is placed in the build directory, so it should not be checked into version control.</p>
</li>
<li>
<p>In general, plugins will read the blueprint file to analyze the source files and then perform some action using a particular backend tool.</p>
</li>
<li>
<p>It is required to plan a design (<code>orbit plan</code>) before building a design (<code>orbit build</code>).</p>
</li>
<li>
<p>Launching a new version (<code>orbit launch</code>) performs a series of checks to make sure the version will work with Orbit when being referenced in other projects.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="ip"><a class="header" href="#ip">IP</a></h1>
<!-- Orbit refers to the packages it manages as _IP_. Orbit recognizes a directory to be an IP by finding the `Orbit.toml` manifest file at the IP's root.

Here is an example IP directory structure:
```
/gates
├─ /rtl
│   └─ and_gate.vhd
├─ /sim
│   ├─ test_vectors.txt
│   └─ and_gate_tb.vhd
└─ Orbit.toml 
```

## IP Levels

An IP can exist at 3 different levels:
1. __developing___: the IP is in-progress/mutable and its location on disk is known (DEV_PATH).
2. __installed__: the IP is immutable and its location on disk is abstracted away from the user (CACHE).
3. __available__: the IP is not stored on disk but has the ability to be pulled from a git remote. Only the IP's manifest is stored locally on disk through a _vendor_.

## Inside an IP

An IP is a HDL project recognized by Orbit. Therefore, an IP's files can be grouped into 3 sections.

- HDL source code files
- manifest file (`Orbit.toml`)
- Supportive files

Supportive files are the files needed within particular HDL workflows. This is a very generic term because there are a lot of different workflows, some require constraints files, python scripts, text files, configuration files, etc.

## Current Working IP (CWIP)

The current working IP (CWIP) is the IP project currently being developed. It is detected within the path from where Orbit was invoked. Some commands, such as `orbit plan` and `orbit build`, require you to call Orbit from within a working IP. --><div style="break-before: page; page-break-before: always;"></div><h1 id="orbitlock"><a class="header" href="#orbitlock">Orbit.lock</a></h1>
<p><code>Orbit.lock</code> is a special file automatically created and updated by Orbit. It is not intended to be manually edited. Orbit writes this file every time <code>orbit plan</code> is called. The purpose of the lock file is store the necessary information to reproduce the build. Ideally, if a project has a lock file, then the project can be rebuilt on any machine and reproduce identical results on all machines.</p>
<p>Orbit uses the lock file when it determines the current ip's <code>Orbit.toml</code> manifest data matches with the lock file entry written for the current ip. When this comparison is true it signals that there has been no change to the state of the system. Any change to <code>Orbit.toml</code> may result in an updated <code>Orbit.lock</code> file.</p>
<p>It is recommended to check in the lock file to version control to ensure the project can be rebuilt on other machines when the repository is cloned.</p>
<blockquote>
<p><strong>Note:</strong> An IP will only read its own lock file and not the lock file of any of its dependencies when needing data to reproduce a build.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbitignore"><a class="header" href="#orbitignore">.orbitignore</a></h1>
<p>A <em>.orbitignore</em> is a file that lists user-defined file patterns to ignore during the execution of <code>orbit</code>. Orbit recognizes .orbitignore files that match &quot;.orbitignore&quot; with case-sensitivity.</p>
<p>.orbitignore files are typically encouraged to be checked into version control.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>.orbitignore files follow the same syntax as .gitignore files. See the pattern format for more information: </p>
<ul>
<li><a href="https://git-scm.com/docs/gitignore#_pattern_format">.gitignore pattern format</a></li>
</ul>
<h2 id="resolving-errors"><a class="header" href="#resolving-errors">Resolving errors</a></h2>
<p>Orbit prevents duplicate primary design units to be identified within certain situations. For example, duplicate design unit names are not allowed within the same project because Orbit cannot resolve ambiguity in which unit is used where.</p>
<p>An error may look like the following:</p>
<pre><code>error: Duplicate primary design units identified as 'my_entity'

location 1: rtl/my_entity_file1.vhd:20:1
location 2: rtl/my_entity_file2.vhd:1:1

hint: To resolve this error, either
    1) Rename one of the units to a unique identifier
    2) Add one of the file paths to a .orbitignore file
</code></pre>
<p>A .orbitignore file can be used in this scenario to tell Orbit to ignore reading a particular file during HDL analysis.</p>
<p>Filename: .orbitignore</p>
<pre><code>rtl/my_entity_file2.vhd

</code></pre>
<p>The .orbitignore will prevent Orbit from seeing the file &quot;rtl/my_entity_file2.vhd&quot; during program execution, which circumvents the previous error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="planning-1"><a class="header" href="#planning-1">Planning</a></h1>
<p>The <em>plan stage</em> is the first step (1/2) in <code>orbit</code>'s run system. Planning refers to the process of collecting the necessary files to write to a blueprint file for a particular workflow. This step occurs before the building step.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-1"><a class="header" href="#building-1">Building</a></h1>
<p>The <em>build stage</em> is the final step (2/2) in <code>orbit</code>'s run system. Building refers to the process of calling a plugin within <code>orbit</code> to perform a workflow. This step occurs after the planning step. </p>
<h2 id="plugin-execution"><a class="header" href="#plugin-execution">Plugin execution</a></h2>
<p>A plugin starts its execution within the build directory. Therefore, all relative file paths inside the plugin's script will always be relative to the build directory. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocols"><a class="header" href="#protocols">Protocols</a></h1>
<p>A <em>protocol</em> is a series of steps requried to get a package from the internet. Protocols exist because there are numerous ways to access data from the internet depending on your development environment. Orbit tries to be as modular and flexible as possible by introducing protocols. </p>
<p>Protocols are required during the download process to acquire a package for potential cache installation.</p>
<h2 id="default-protocol"><a class="header" href="#default-protocol">Default protocol</a></h2>
<p>Orbit has a default protocol that relies on the Rust <a href="https://crates.io/crates/curl"><code>curl</code></a> crate to make HTTP requests. This protocol assumes the provided URLs point to a zip archive containing the targeted package. The protocol will extract the zip file to the <em>queue</em>, which is a special temporary directory handled by Orbit. Orbit generates and manages a different queue directory for each package that must be downloaded.</p>
<h3 id="using-the-default-protocol"><a class="header" href="#using-the-default-protocol">Using the default protocol</a></h3>
<p>To use the default protocol, modify the desired project's manifest to only specify the URL as the source. The default protocol assumes the URL points to a publicly accessible zip archive.</p>
<p>Filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
name = &quot;orbit&quot;
version = &quot;1.0.0&quot;
source = &quot;https://github.com/cdotrus/orbit/archive/refs/tags/1.0.0.zip&quot;
# ...
</code></pre>
<h2 id="custom-protocols"><a class="header" href="#custom-protocols">Custom protocols</a></h2>
<p>A user can define a custom protocol for accessing packages from the internet by modifying the configuration file.</p>
<p>Orbit sets the current directory for the custom protocol execution to already be the queue directory.
This means when a custom protocol is executed, whatever files it downloads and extracts to the current directory is the directory Orbit expects to find the IP.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>One possible protocol relies on using the <code>git</code> command-line tool.</p>
<p>Filename: config.toml</p>
<pre><code class="language-toml">[[protocol]]
name = &quot;gitit&quot;
summary = &quot;Access packages through git to handle remote repositories&quot;
command = &quot;git&quot;
args = [&quot;clone&quot;, &quot;-b&quot;, &quot;{{ orbit.ip.version }}&quot;, &quot;{{ orbit.ip.source.url }}&quot;]
</code></pre>
<p>This protocol calls <code>git</code> and clones from the IP's URL while checking out the branch/tag that matches the IP's version number. These values are resolved at runtime by Orbit through variable substitution.</p>
<p>More complex protocols may require using a scripting language such as Python to perform the necessary steps.</p>
<h3 id="using-a-custom-protocol"><a class="header" href="#using-a-custom-protocol">Using a custom protocol</a></h3>
<p>To use a custom protocol, modify the desired project's manifest file to specify the URL as well as the defined protocol's name. It is each user of the package's responsibility to ensure the necessary protocol(s) are properly configured in their settings.</p>
<p>Filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
name = &quot;orbit&quot;
version = &quot;1.0.0&quot;
source = { url = &quot;https://github.com/cdotrus/orbit.git&quot;, protocol = &quot;gitit&quot; }
# ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caching"><a class="header" href="#caching">Caching</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="downloading"><a class="header" href="#downloading">Downloading</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variable-substitution"><a class="header" href="#variable-substitution">Variable Substitution</a></h1>
<p><em>Variable substitution</em> is the process of injecting runtime information into specific locations. </p>
<p>To have a variable be substituted with its value, use double opening curly brackets <code>{{</code> to denote the beginning of a variable key and double closing curly brackets <code>}}</code> to end the variable key. Whitespace is ignored around the variable key within the curly bracket sequences.</p>
<p>When Orbit gets a string in a context supported by variable substitution, it will parse the characters to check if a variable should be substituted. If it finds a valid variable with the same name, then it replaces everything from and within the curly bracket sequences with the variable's value. If it cannot find a valid variable that matches the name, it leaves that sequence of the string unmodified.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>Consider a plugin with the following fileset defined.</p>
<pre><code class="language-toml">fileset.python-model = &quot;{{ orbit.bench }}.py&quot;
</code></pre>
<p>Given the context that the testbench name is &quot;add_tb&quot;, then at runtime the fileset &quot;PYTHON-MODEL&quot; will resolve its file pattern to look for files that match &quot;add_tb.py&quot;.</p>
<p>Now given a different context when the testbench name is called &quot;mult_tb&quot;, then at runtime the same fileset &quot;PYTHON-MODEL&quot; will resolve its file pattern to look for files that match &quot;mult_tb.py&quot;.</p>
<h2 id="supported-variables"><a class="header" href="#supported-variables">Supported variables</a></h2>
<p>Variable substitution is currently supported in the following contexts:</p>
<h3 id="fileset-patterns"><a class="header" href="#fileset-patterns">Fileset patterns</a></h3>
<p>The string pattern for a plugin's fileset configuration is allowed to contain any of the following substitution variables:</p>
<ul>
<li><code>orbit.top</code>: The top-level design unit name.</li>
<li><code>orbit.bench</code>: The testbench design unit name.</li>
<li><code>orbit.env.*</code>: Any environment variables loaded from configuration files.</li>
</ul>
<h3 id="protocol-arguments"><a class="header" href="#protocol-arguments">Protocol arguments</a></h3>
<p>The arguments set in a protocol's configuration are allowed to contain any of the following substitution variables:</p>
<ul>
<li><code>orbit.queue</code>: The directory that Orbit expects the IP to be downloaded to.</li>
<li><code>orbit.ip.name</code>: The name of the IP being downloaded.</li>
<li><code>orbit.ip.version</code>: The version of the IP being downloaded.</li>
<li><code>orbit.ip.source.url</code>: The URL for the IP being downloaded.</li>
<li><code>orbit.ip.source.protocol</code>: The protocol specified by the IP being downloaded</li>
<li><code>orbit.ip.source.tag</code>: The tag (if provided) specified by the IP being downloaded.</li>
<li><code>orbit.env.*</code>: Any environment variables loaded from configuration files.</li>
</ul>
<h2 id="environment-variable-translation-examples"><a class="header" href="#environment-variable-translation-examples">Environment variable translation examples</a></h2>
<p>A substitution variable key is the environment variable key but converted to lowercase with each &quot;_&quot; character replaced by a &quot;.&quot; character.</p>
<p>Environment variables can be set in the configuration file like so.</p>
<pre><code class="language-toml">[env]
foo = &quot;bar&quot;
github-user = &quot;cdotrus&quot;
Yilinx_Path = &quot;/Users/chase/fpga/bin/yilinx&quot;
</code></pre>
<p>This configuration translates to the following variables:</p>
<div class="table-wrapper"><table><thead><tr><th>TOML <code>[env]</code> entry</th><th>Environment variable</th><th>Substitution variable</th></tr></thead><tbody>
<tr><td>foo</td><td>ORBIT_ENV_FOO</td><td>orbit.env.foo</td></tr>
<tr><td>github-user</td><td>ORBIT_ENV_GITHUB_USER</td><td>orbit.env.github.user</td></tr>
<tr><td>Yilinx_Path</td><td>ORBIT_ENV_YILINX_PATH</td><td>orbit.env.yilinx.path</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-symbol-transformation"><a class="header" href="#dynamic-symbol-transformation">Dynamic Symbol Transformation</a></h1>
<p>This technique is related to <em>name mangling</em> in programming languages. <em>Name mangling</em> is a technique used to solve problems regarding the need to resolve unique names for programming entities. You can learn more about name mangling <a href="https://en.wikipedia.org/wiki/Name_mangling">here</a>.</p>
<h2 id="problem-statement"><a class="header" href="#problem-statement">Problem Statement</a></h2>
<p>Before we begin, it is important to understand the problem we are trying to solve. An issue inherent to VHDL and many other languages is <em>namespace pollution</em>, which is when many programming language variables/identifiers/units/classes are defined at the global level. To learn more about namespace pollution, <a href="https://stackoverflow.com/questions/8862665/what-does-it-mean-global-namespace-would-be-polluted/13352212">here</a> is a StackOverflow post that explains it in relation to Javascript.</p>
<p>Namespace pollution can lead to <em>namespace clashes</em>. As you define more primary design units at the same scope, you are more likely to have two things that accidently have the same name. This is at the core the problem we are going to solve, because VHDL compilers and synthesizers are not built to gracefully handle clashes and will error out when a primary design unit at the same scope has multiple definitions.</p>
<p>In VHDL, a common example of a namespace clash is when different files define an entity by the same name, which may have different behaviors. Namespace clashes may start to appear when a higher-level IP requires the same entity from an IP but as different versions throughout its dependency tree.</p>
<h2 id="solution---dynamic-symbol-transformation"><a class="header" href="#solution---dynamic-symbol-transformation">Solution - Dynamic Symbol Transformation</a></h2>
<p>The proposed algorithm solves the namespace clashing problem by rewriting conflicts with a new unique identifier without losing information in the original identifier.</p>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p>Orbit automatically handles resolving duplicate identifiers for primary design units due to two design contraints. The limitations are:</p>
<ol>
<li>All primary design unit identifiers in the current IP must be unique within the scope of the IP.</li>
<li>All primary design units identifiers in the current IP must be unique within the scope of the IP's direct dependencies. An identifier can be duplicated for primary design units across indirect dependencies.</li>
</ol>
<h2 id="example-demonstration"><a class="header" href="#example-demonstration">Example Demonstration</a></h2>
<p>This section walks through a basic demonstration of the dynamic symbol transformation (DST) algorithm. First, it defines some terminology, and then walks through the algorithm's functionality.</p>
<h3 id="symbols"><a class="header" href="#symbols">Symbols</a></h3>
<p>Within the context of VHDL, let's consider a <em>symbol</em> to be the identifier of a <em>primary design unit</em>. A primary design unit is a VHDL construct that exists at the global namespace. There are four primary design units:</p>
<ul>
<li>entity</li>
<li>package</li>
<li>configuration</li>
<li>context</li>
</ul>
<blockquote>
<p><strong>Note:</strong> VHDL does support the concept of <em>libraries</em>, which can add 1 level of nested scope to a primary design unit, but for this example we will assume the primary design units are defined within the same library/scope.</p>
</blockquote>
<p>In the following code, the symbol <code>and_gate</code> corresponds to an entity.</p>
<p>Filename: lab1/and_gate.vhd</p>
<pre><code class="language-vhdl">entity and_gate is
  port(
    a, b : in bit;
    c : out bit
  );
end entity;
</code></pre>
<p>Remember that this identifier could appear again at the same namespace level as this exsiting entity in a different VHDL file.</p>
<p>Now imagine you are integrating VHDL code from various existing IPs. As you instantiate entities within larger entities, you realize there exists another entity named <code>and_gate</code> further down in the hierarchy, but this one has a different behavior and port interface than the previously defined <code>and_gate</code> circuit from the &quot;lab1/&quot; directory.</p>
<p>Filename: lab3/and_gate.vhd</p>
<pre><code class="language-vhdl">entity and_gate is
  port(
    a, b : in bit_vector(3 downto 0);
    c : out bit_vector(3 downto 0)
  );
end entity;
</code></pre>
<p>Since the current IP requires both code segments, then traditionally your EDA tool would complain to you and be unable to resolve which <code>and_gate</code> to be used where. It then falls on the developer to rename one of the entities where it is defined and everywhere it is referenced, which introduces additional overhead in time and possibilities for errors. This problem is solved with DST.</p>
<h3 id="walkthrough"><a class="header" href="#walkthrough">Walkthrough</a></h3>
<p>We present an example project-level IP dependency tree.</p>
<pre><code>final-project
├─ lab3
│  └─ lab2
|     └─ lab1
└─ lab2
</code></pre>
<p>Imagine the <code>final-project</code> IP has an entity called <code>top_level</code> which is the root of circuit hierarchy. From there, it reuses entities from the other IP.</p>
<p>Let's look at the VHDL design tree hierarchy across the IPs.</p>
<pre><code>top_level (final-project)
├─ and_gate (lab3)
│  └─ adder (lab2)
|     └─ and_gate (lab1)
└─ mux (lab2)
</code></pre>
<p>Notice lab1 and lab3 both have the <code>and_gate</code> entity, but their interfaces and functionality are different as previously mentioned. How can we allow both units in the hierarchy while resolving the namespace clash?</p>
<p>DST identifies namespace clashes within the current dependency graph and automatically resolve the conflicts to produce a clean unambiguous graph.</p>
<pre><code>top_level (final-project)
├─ and_gate (lab3)
│  └─ adder (lab2)*
|     └─ and_gate_fbe4720d0 (lab1)*
└─ mux (lab2)
</code></pre>
<p>Let's dive into what happened here. DST handled the namespace clash by <em>transforming</em>, or renaming, the entity related to lab1. The entity's identifier in lab1 was appended with the first 10 digits of the original lab1 IP's checksum. This transformation occurred at that IP's source code level (lab1), and in the source code for all dependents of that entity (lab2). Therefore, DST produced new dynamic variants of the lab1 and lab2 IPs that properly reference and associate with <code>and_gate_fbe4720d0</code>.</p>
<p>DST specifically chose not to rename the <code>and_gate</code> from lab3, or else the user would have to be burdened with trying to track and maintain the new unique identifier in the currently developed IP (final-project). As a result, DST has no additional overhead to the user and is kept abstracted away by Orbit. Direct dependencies are never chosen for DST.</p>
<h2 id="emphasis"><a class="header" href="#emphasis">Emphasis</a></h2>
<p>Dynamic symbol transformation lets Orbit avoid the major issues and frustrations of package management that stem from dependency incompatibility. As projects grow in complexity and the number of dependencies increases, Orbit can continue to allow users to integrate different verisons of the same package throughout the overall design while retaining dependency compatibility. Conflicts in incompatible versions are avoided within the dependency graph through DST. You can learn more about dependency incompatibility <a href="https://en.wikipedia.org/wiki/Dependency_hell">here</a>.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li>https://stephencoakley.com/2019/04/24/how-rust-solved-dependency-hell</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>This section provides technical information for the various components used throughout <code>orbit</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manifest"><a class="header" href="#manifest">Manifest</a></h1>
<p>The <code>Orbit.toml</code> file for each IP is called its manifest. It is written in the <a href="https://toml.io/en/">TOML</a> format. It is maintained by the developer and contains metadata that is needed to build the IP.</p>
<blockquote>
<p><strong>Note:</strong> The manifest's file name is &quot;Orbit.toml&quot;, with respect to case-sensitivity.</p>
</blockquote>
<p>Every manifest file consists of the following sections:</p>
<ul>
<li><a href="reference/manifest.html#the-ip-section">[ip]</a> - Defines an IP.
<ul>
<li><a href="reference/manifest.html#the-name-field">name</a> - The name of the IP.</li>
<li><a href="reference/manifest.html#the-version-field">version</a> - The version of the IP.</li>
<li><a href="reference/manifest.html#the-authors-field">authors</a> - The authors of the IP.</li>
<li><a href="reference/manifest.html#the-library-field">library</a> - The HDL library for the design units within the IP.</li>
<li><a href="reference/manifest.html#the-description-field">description</a> - A short description of the IP.</li>
<li><a href="reference/manifest.html#the-keywords-field">keywords</a> - A list of simple words categorizing the IP.</li>
<li><a href="reference/manifest.html#the-source-field">source</a> - The URL for remotely retrieving the IP.</li>
<li><a href="reference/manifest.html#the-public-field">public</a> - The list of files to be visible to other IP.</li>
<li><a href="reference/manifest.html#the-readme-field">readme</a> - The path to the README file.</li>
<li><a href="reference/manifest.html#the-metadata-section">[metadata]</a> - An unchecked section for custom fields.</li>
</ul>
</li>
<li><a href="reference/manifest.html#the-dependencies-section">[dependencies]</a> - IP dependencies.</li>
<li><a href="reference/manifest.html#the-dev-dependencies-section">[dev-dependencies]</a> - IP dependencies only used for ongoing development.</li>
</ul>
<h3 id="the-ip-section"><a class="header" href="#the-ip-section">The <code>[ip]</code> section</a></h3>
<p>The first section in a <code>Orbit.toml</code> file is <code>[ip]</code>.</p>
<pre><code class="language-toml">[ip]
name = &quot;my-ip&quot; # the name of the package
version = &quot;0.1.0&quot; # the current version
</code></pre>
<p>The only fields required by <code>orbit</code> are name and version.</p>
<h3 id="the-name-field"><a class="header" href="#the-name-field">The <code>name</code> field</a></h3>
<pre><code class="language-toml">[ip]
name = &quot;my-ip&quot;
# ...
</code></pre>
<h3 id="the-version-field"><a class="header" href="#the-version-field">The <code>version</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
version = &quot;0.1.0&quot;
</code></pre>
<h3 id="the-authors-field"><a class="header" href="#the-authors-field">The <code>authors</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
authors = [&quot;Duncan Idaho&quot;, &quot;Gurney Halleck&quot;]

</code></pre>
<h3 id="the-library-field"><a class="header" href="#the-library-field">The <code>library</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
library = &quot;work&quot;
</code></pre>
<h3 id="the-description-field"><a class="header" href="#the-description-field">The <code>description</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
description = &quot;A short description of the ip&quot;
</code></pre>
<h3 id="the-keywords-field"><a class="header" href="#the-keywords-field">The <code>keywords</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
keywords = [&quot;cpu&quot;, &quot;risc&quot;]
</code></pre>
<h3 id="the-source-field"><a class="header" href="#the-source-field">The <code>source</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
source = &quot;https://github.com/cdotrus/orbit/archive/refs/tags/1.0.0.zip&quot;
</code></pre>
<h3 id="the-public-field"><a class="header" href="#the-public-field">The <code>public</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
public = [&quot;/rtl&quot;]
</code></pre>
<p>The <code>public</code> field can be used to explicitly specify which files are visible to other IP when being when being referenced as a dependency. The list contains glob-style patterns that conform to .gitignore file semantics, and are always compared relative that IP's root directory.</p>
<p>If no <code>public</code> field is present, then all files are implicitly specified as visible (public) to other IP when being referenced as a dependency.</p>
<pre><code class="language-toml">[ip]
# ...
source = { url = &quot;https://github.com/cdotrus/orbit.git&quot;, protocol = &quot;p-git&quot;, tag = &quot;1.0.0&quot; }
</code></pre>
<h3 id="the-readme-field"><a class="header" href="#the-readme-field">The <code>readme</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
readme = &quot;README.md&quot;
</code></pre>
<h3 id="the-metadata-section"><a class="header" href="#the-metadata-section">The <code>[metadata]</code> section</a></h3>
<pre><code class="language-toml">[ip.metadata]
my-field-1 = true
my-field-2 = &quot;hello world&quot;
# ...
</code></pre>
<h3 id="the-dependencies-section"><a class="header" href="#the-dependencies-section">The <code>[dependencies]</code> section</a></h3>
<p>The <code>[dependencies]</code> section is a table of direct dependencies required for the current IP.</p>
<pre><code class="language-toml">[dependencies]
gates = &quot;1.0.0&quot;
uart = &quot;2.3.1&quot;
</code></pre>
<p>If the IP has no dependencies, the section can be omitted from the manifest. The IPs listed in this section will always be included in the build graph.</p>
<h3 id="the-dev-dependencies-section"><a class="header" href="#the-dev-dependencies-section">The <code>[dev-dependencies]</code> section</a></h3>
<p>The <code>[dev-dependencies]</code> section is a table of direct dependencies required for the current IP.</p>
<pre><code class="language-toml">[dev-dependencies]
testkit = &quot;1.3.7&quot;
logic-analyzer = &quot;4.8.0&quot;
</code></pre>
<p>If the IP has no development dependencies, the section can be omitted from the manifest. The IPs listed in this section will not be included in the build graph for when this IP is used as a dependency itself.</p>
<!-- 
## Entries

The following is a list of acceptable entries (key/value pairs) recognized by Orbit in manifest files (`Orbit.toml`).

### `ip.name` : _string_
- project name identifier, third component in the PKGID
- required for every manifest

``` toml
[ip]
name = "gates"
# ...
```

### `ip.library` : _string_
- project library identifier, second component in the PKGID
- required for every manifest

``` toml
[ip]
library = "rary"
# ...
```

### `ip.vendor` : _string_
- project vendor/organization identifier, first component in the PKGID
- required for every manifest

``` toml
[ip]
vendor = "ks-tech"
# ...
```

### `ip.version` : _string_
- semver for the project's current status
- required for every manifest

``` toml
[ip]
version = "1.0.0"
# ...
```

### `ip.repository` : _string_
- remote repository git url
- required to launch an ip to a vendor repository

``` toml
[ip]
repository = "https://github.com/kepler-space-tech/gates.git"
# ...
```

### `ip.summary` : _string_
- short description about the ip

``` toml
[ip]
summary = "a collection of low-level logic gates"
# ...
```

### `ip.changelog` : _string_
- relative path to the ip's CHANGELOG
- auto-detects files named "CHANGELOG.md" in ip's directory
``` toml
[ip]
changelog = "CHANGELOG.md"
# ...
```

### `ip.readme` : _string_
- relative path to the ip's README
- auto-detects files named "README.md" in ip's directory
``` toml
[ip]
readme = "README.md"
# ...
```

### `[dependencies]` : _table_
- user-defined additional keys that specify the minimum version of external ip directly used in the current project
- the complete PKGID is entered as a key, while the minimum required version is entered as the value 

``` toml
[dependencies]
ks-tech.rary.memory = "1.2"
ks-tech.util.toolbox = "3.0.4"
```
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages"><a class="header" href="#packages">Packages</a></h1>
<p>Packages are a group of related files that fall within the same scope. Packages are more commonly called <em>intellectual property</em>, or IP, in the hardware design space.</p>
<h2 id="package-identifier"><a class="header" href="#package-identifier">Package Identifier</a></h2>
<p>The package identifier is a project's unique string of characters following a specification. It is a single name and is defined under the &quot;name&quot; field in the IP's manifest. Every IP is required to have a name.</p>
<h3 id="rules"><a class="header" href="#rules">Rules</a></h3>
<p>The following rules currently apply to a package identifier:</p>
<ul>
<li>begins with an ASCII letter (<code>a-z</code>, <code>A-Z</code>)</li>
<li>contains only ASCII letters (<code>a-z</code>, <code>A-Z</code>), ASCII digits (<code>0-9</code>), dashes <code>-</code>, and underscores <code>_</code></li>
</ul>
<h2 id="package-specification"><a class="header" href="#package-specification">Package Specification</a></h2>
<p>A package specification, or <em>spec</em>, is the total unambiguous reference to a particular IP at a particular version.</p>
<pre><code>spec ::= &lt;name&gt;[:version]
</code></pre>
<h3 id="example-specifications"><a class="header" href="#example-specifications">Example Specifications</a></h3>
<p>The following provides various valid inputs when defining an IP's spec value and how it decomposes into its parts.</p>
<div class="table-wrapper"><table><thead><tr><th>Spec</th><th>Name</th><th>Version</th></tr></thead><tbody>
<tr><td>gates:1.0.0</td><td>gates</td><td>1.0.0</td></tr>
<tr><td>ram</td><td>ram</td><td>latest</td></tr>
<tr><td>fifo:2.3</td><td>fifo</td><td>2.2.X</td></tr>
</tbody></table>
</div>
<h3 id="namespace-collisions"><a class="header" href="#namespace-collisions">Namespace Collisions</a></h3>
<p>Within a user's <em>catalog</em>, two different specs may share common identifiers. Two identifiers are considered equivalent if their lowercase mapping is identical, where dashes (<code>-</code>) also map to underscores (<code>_</code>).</p>
<div class="table-wrapper"><table><thead><tr><th>Spec 1</th><th>Spec 2</th><th>Collision</th></tr></thead><tbody>
<tr><td>gates</td><td>GATES</td><td>true</td></tr>
<tr><td>ram</td><td>rom</td><td>false</td></tr>
<tr><td>fifo_cdc</td><td>Fifo-CDC</td><td>true</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Note:</strong> A resolution to this problem is to add an IP's UUID to the package specification. While each IP already has a UUID auto-assigned in their lock file, this is a proposed feature that has yet to be implemented.</p>
</blockquote>
<h2 id="package-library"><a class="header" href="#package-library">Package Library</a></h2>
<p>A package can optionally belong to a <em>library</em>. A library is defined under the &quot;library&quot; field in the IP's manifest and follows the same rules as the package identifier. When producing a blueprint file, it will choose to associate all HDL files within a particular package with the provided library. If no library is defined in the package's manifest, then the default <code>work</code> library is provided. </p>
<p>The library for the current working package will always be <code>work</code>, regardless of the value of the &quot;library&quot; field in the manifest file. It's &quot;library&quot; field value will be in effect when the package is referenced as a dependency.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="versions"><a class="header" href="#versions">Versions</a></h1>
<p>Code evolves over time, and versions provide a method for capturing a project's state at a given time stamp.</p>
<p>Orbit uses the <em>semantic versioning</em> scheme for capturing project's state at given time periods. Semantic versioning uses 3 numeric values to signify different levels of change.</p>
<pre><code>version ::= &lt;major&gt;.&lt;minor&gt;.&lt;micro&gt;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Level</th><th>Explanation</th></tr></thead><tbody>
<tr><td>Major</td><td>Incompatible API changes</td></tr>
<tr><td>Minor</td><td>Adding functionality in backward-compatible way</td></tr>
<tr><td>Micro</td><td>Fixing bugs in backward-compatible way</td></tr>
</tbody></table>
</div>
<p>To learn more about semantic versioning, visit the official <a href="https://semver.org">website</a>. </p>
<p>Since everyone's stance on what code changes affect which version level may differ, it's important to keep a changelog highlighting differences among versions.</p>
<blockquote>
<p><strong>Note:</strong> An alternative to <em>semantic versioning</em> is <em>calender versioning</em>, which
also operates on the basis of using 3 digits. To learn more about <em>calender versioning</em> visit the official <a href="https://calver.org">website</a>.</p>
</blockquote>
<h3 id="rules-1"><a class="header" href="#rules-1">Rules</a></h3>
<ul>
<li>Each level may only contain ASCII digits (<code>0-9</code>).</li>
</ul>
<p>All 3 levels must be given a numeric value consisting of only digits separated by a dot (<code>.</code>) character. This is considered a <em>fully qualified</em> version.</p>
<pre><code>1.0.0
</code></pre>
<p>In some scenarios a <em>partially qualified</em> version can be accepted. This means one or more of the version's levels are omitted. </p>
<pre><code>1
1.0
</code></pre>
<p>When given a partially qualified version, Orbit references the maximum version available that satifies the partially qualified version. If no version is specified, it assumes the request is for the latest known version. The latest known version can also be explicitly requested by inputting <code>latest</code> as the version. Assume the known released versions for a given IP are as listed: </p>
<div class="table-wrapper"><table><thead><tr><th>Versions</th></tr></thead><tbody>
<tr><td>2.1.0</td></tr>
<tr><td>1.5.0</td></tr>
<tr><td>1.2.1</td></tr>
<tr><td>1.2.0</td></tr>
<tr><td>1.0.0</td></tr>
</tbody></table>
</div>
<p>The following illustrates the mapping from the partially specified requested version to its fully specified known version that would be returned:</p>
<div class="table-wrapper"><table><thead><tr><th>Requested</th><th>Returned</th></tr></thead><tbody>
<tr><td>1</td><td>1.5.0</td></tr>
<tr><td>1.1</td><td>NOT FOUND</td></tr>
<tr><td>1.2</td><td>1.2.1</td></tr>
<tr><td>2</td><td>2.1.0</td></tr>
<tr><td>1.2.0</td><td>1.2.0</td></tr>
<tr><td>latest</td><td>2.1.0</td></tr>
<tr><td>(omitted)</td><td>2.1.0</td></tr>
</tbody></table>
</div>
<h3 id="example-scenarios"><a class="header" href="#example-scenarios">Example Scenarios</a></h3>
<p>A fully qualified version must be written in every project's manifest file.</p>
<pre><code class="language-toml">[ip]
# ...
version = &quot;1.5.4&quot;
# ...
</code></pre>
<p>A specific (or partially speific) version can be requested for an IP on the command-line by placing a colon <code>:</code> character between the package's name and the requested version.</p>
<pre><code>$ orbit install gates:1.5.4
$ orbit get nor_gate --ip gates:1.5
</code></pre>
<h3 id="comparing-versions"><a class="header" href="#comparing-versions">Comparing versions</a></h3>
<p>The following pseudocode provides additional help in learning about how versions are compared (selecting a &quot;higher&quot; version).</p>
<pre><code>IF major levels are not equal:
    RETURN version with larger major level value.
ELSE IF minor levels are not equal:
    RETURN version with larger minor level value.
ELSE:
    RETURN version with larger patch level value. 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filesets"><a class="header" href="#filesets">Filesets</a></h1>
<p>A <em>fileset</em> is group of files identified by a common file pattern. Typically they are denoted by a common file extension, such as <code>.txt</code>, but a fileset can more broadly be grouped under any glob-style pattern.</p>
<p>A fileset itself consists of a name and a pattern. </p>
<ul>
<li>The name is a string that is normalized to ALL-UPPERCASE-WITH-HYPENS. It is used to identify which fileset a file belongs to.</li>
<li>The pattern is a glob-style pattern. It is used to perform glob-style matching when searching the file system for files to add to a fileset.</li>
</ul>
<h2 id="built-in-filesets"><a class="header" href="#built-in-filesets">Built-in filesets</a></h2>
<p>There are built-in filesets that <code>orbit</code> uses that have special rules and work across all IP, including dependencies. The filesets built into <code>orbit</code> that are currently supported are:</p>
<ul>
<li><code>VHDL-RTL</code>: VHDL files (.vhd, .vhdl) that contain zero entities without a port interface. </li>
<li><code>VHDL-SIM</code>: VHDL files (.vhd, .vhdl) that contain at least one entity without a port interface.</li>
</ul>
<h2 id="reserved-filesets"><a class="header" href="#reserved-filesets">Reserved filesets</a></h2>
<p>Filesets that are planned to be built into <code>orbit</code> at a later date are:</p>
<ul>
<li><code>VLOG-RTL</code>: SytemVerilog/Verilog files (.v, .sv) that contain zero modules without a port interface.</li>
<li><code>VLOG-SIM</code>: SystemVerilog/Verilog files (.v, .sv) that contain at least one module without a port interface.</li>
</ul>
<h2 id="custom-filesets"><a class="header" href="#custom-filesets">Custom filesets</a></h2>
<p>Custom filesets are filesets that are be defined by the user either for a specific plugin or on the command-line. These filesets are only searched for in the current working IP and do not extend to its dependencies.</p>
<p>If the pattern does not start with an explicit relative path symbol (<code>.</code>), then <code>orbit</code> assumes to look for the fileset across every possible path in the current working IP by implicitly prepending the pattern with <code>**/</code>.</p>
<h2 id="name-normalization-examples"><a class="header" href="#name-normalization-examples">Name normalization examples</a></h2>
<div class="table-wrapper"><table><thead><tr><th>User-defined Fileset</th><th>Normalized Fileset</th></tr></thead><tbody>
<tr><td>GOOD-SET</td><td>GOOD-SET</td></tr>
<tr><td>Set-1</td><td>SET-1</td></tr>
<tr><td>set_2</td><td>SET-2</td></tr>
<tr><td>set_three</td><td>SET-THREE</td></tr>
</tbody></table>
</div>
<p>The normalized fileset name is the name that will be written to the blueprint file when collecting filesets. This design choice is for consistency across plugins when reading and parsing the blueprint.</p>
<h2 id="custom-pattern-assumption-examples"><a class="header" href="#custom-pattern-assumption-examples">Custom pattern assumption examples</a></h2>
<div class="table-wrapper"><table><thead><tr><th>User-defined pattern</th><th>Interpreted pattern</th></tr></thead><tbody>
<tr><td>*.txt</td><td>**/*.txt</td></tr>
<tr><td>Boards/*.toml</td><td>**/Boards/*.toml</td></tr>
<tr><td>./specific/path.log</td><td>./specific/path.log</td></tr>
</tbody></table>
</div>
<p>The custom patterns begin their search for files at the root directory of the current working IP. The interpreted pattern is the actual glob-style pattern used when collecting files for custom filesets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blueprint"><a class="header" href="#blueprint">Blueprint</a></h1>
<p>The <em>blueprint</em> is a file containing a list of files required for a particular backend. It is the main way <code>orbit</code> communicates to a backend system. </p>
<p>When the blueprint is created, it is saved to the current working IP's build directory.</p>
<h2 id="formats"><a class="header" href="#formats">Formats</a></h2>
<p>The currently supported formats are:</p>
<ul>
<li><a href="reference/blueprint.html#tab-separated-values">Tab-separated values</a>: <code>blueprint.tsv</code></li>
</ul>
<h2 id="specifications"><a class="header" href="#specifications">Specifications</a></h2>
<p>Each blueprint format may contain different information and store it in a different way. Refer to each specification to see exactly how the data is communicated through their blueprint.</p>
<h3 id="tab-separated-values"><a class="header" href="#tab-separated-values">Tab-separated values</a></h3>
<ul>
<li>Advantages
<ul>
<li>Simple and easy to parse for backends</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>Limited information is sent</li>
</ul>
</li>
</ul>
<p>The file is divided into a series of <em>rules</em>, each separated by a newline character (<code>\n</code>).</p>
<pre><code>RULE
RULE
...
</code></pre>
<p>A rule contains information about a particular file. Every rule always has 3 components: a fileset, an identifier, and a filepath. Each component in a rule is separated by a tab character (<code>\t</code>).</p>
<pre><code>FILESET	IDENTIFIER	FILEPATH
</code></pre>
<p>The <em>fileset</em> is the group name for the file pattern that matched the given rule's file.</p>
<p>The <em>identifier</em> is the library for the IP which the given rule's file belongs to.</p>
<p>The <em>filepath</em> is the absolute file system path to the given rule's file.</p>
<h4 id="examples"><a class="header" href="#examples">Examples</a></h4>
<pre><code class="language-text">PY-MODEL	work	/Users/chase/projects/lc3b/sim/models/alu_tb.py
VHDL-RTL	work	/Users/chase/projects/lc3b/rtl/const_pkg.vhd
VHDL-RTL	math	/Users/chase/.orbit/cache/base2-1.0.0-aac9159285/pkg/base2.vhd
VHDL-RTL	work	/Users/chase/projects/lc3b/rtl/alu.vhd
VHDL-SIM	work	/Users/chase/projects/lc3b/sim/alu_tb.vhd

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h1>
<p>Orbit's configuration can be customized with the setting of specific environment variables. </p>
<ul>
<li>
<p><code>ORBIT_HOME</code> - directory where orbit stores its data. By default it is <code>$HOME/.orbit</code> on Unix systems and <code>%USERPROFILE%/.orbit</code> on Windows systems.</p>
</li>
<li>
<p><code>ORBIT_CACHE</code> - directory where orbit caches installed IP. By default it is <code>$ORBIT_HOME/cache</code>.</p>
</li>
<li>
<p><code>ORBIT_DOWNLOADS</code> - directory where orbit saves archived snapshots of IP at a particular version. By default it is <code>$ORBIT_HOME/downloads</code></p>
</li>
<li>
<p><code>NO_COLOR</code> - does not print colorized output when set to a value.</p>
</li>
<li>
<p><code>EDITOR</code> - chooses this value as the default text editor when no <code>core.editor</code> key is present in the config.toml.</p>
</li>
<li>
<p><code>ORBIT_WIN_LITERAL_CMD</code> - disables default behavior of checking for programs ending with .exe then .bat when a program name without extension is not found on a windows operating system</p>
</li>
</ul>
<h2 id="runtime-environment-variables"><a class="header" href="#runtime-environment-variables">Runtime environment variables</a></h2>
<p>Orbit also sets environment variables during runtime so a plugin has access to runtime information. </p>
<ul>
<li>
<p><code>ORBIT_BUILD_DIR</code> - directory to place the <code>blueprint.tsv</code> file relative to the current IP path. Default is <code>build</code>.</p>
</li>
<li>
<p><code>ORBIT_IP_PATH</code> - path to the IP that is detected under the current working directory. If its not immediately detected at the current directory, it will continue to search the parent directory until it finds a <code>Orbit.toml</code> manifest file.</p>
</li>
<li>
<p><code>ORBIT_PLUGIN</code> - last referenced plugin from the planning phase</p>
</li>
<li>
<p><code>ORBIT_TOP</code> - toplevel design unit identifier</p>
</li>
<li>
<p><code>ORBIT_BENCH</code> - toplevel design's testbench identifier</p>
</li>
<li>
<p><code>ORBIT_IP_NAME</code> - name field of the manifest for the IP package</p>
</li>
<li>
<p><code>ORBIT_IP_LIBRARY</code> - optional HDL library defined in the manifest for the IP package</p>
</li>
<li>
<p><code>ORBIT_IP_VERSION</code> - specific version of current working directory's IP</p>
</li>
<li>
<p><code>ORBIT_BLUEPRINT</code> - the filename for the blueprint: <code>blueprint.tsv</code></p>
</li>
</ul>
<h2 id="checking-the-environment"><a class="header" href="#checking-the-environment">Checking the environment</a></h2>
<p>You can review the known environment variables within Orbit with <code>orbit env</code>.</p>
<!--Note about environment variables vs. settings file vs. arguments

precedence:
3. config file
2. env vars
1. command-line
--><div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>The <code>config.toml</code> file stores settings and extends <code>orbit</code>'s functionality. It is written in the <a href="https://toml.io/en/">TOML</a> format. It is maintained by the developer and can be shared across teams for consistent development environments.</p>
<blockquote>
<p><strong>Note:</strong> The configuration's file name is &quot;config.toml&quot;, with respect to case-sensitivity.</p>
</blockquote>
<h2 id="paths"><a class="header" href="#paths">Paths</a></h2>
<p>When a field is expected to be a filesystem path, <code>orbit</code> has the ability to resolve relative paths. The path is determined in relation to the currently processed <code>config.toml</code>'s parent directory. This design choice was implemented in order to allow for path definitions to be valid across developer machines when sharing configurations. It is recommended to use relative paths when setting a path to a field in a <code>config.toml</code>.</p>
<h2 id="precedence"><a class="header" href="#precedence">Precedence</a></h2>
<p>Orbit supports multiple levels of configuration. Each level has its own order of precedence:</p>
<ol>
<li>
<p>Local configuration file (location: current working IP)</p>
</li>
<li>
<p>Global configuration file (location: <code>$ORBIT_HOME</code>)</p>
</li>
<li>
<p>Configuration files listed in the global <code>config.toml</code>'s <a href="reference/configuration.html#the-include-field"><code>include</code></a> (items in the array are processed in order; first-to-last)</p>
</li>
</ol>
<p>The configuration files are processed in the order defined above. When a configuration file defines a field, no other configuration files later in the process will be able to override its value. If a field is never provided an explicit value, the hard-coded defaults will be used.</p>
<blockquote>
<p><strong>Tip:</strong> You can modify some values in the configuration file through the command-line by using the <code>orbit config</code> command.</p>
</blockquote>
<p>Every configuration file consists of the following sections:</p>
<ul>
<li><a href="reference/configuration.html#the-include-field">include</a> - Lists other <code>config.toml</code> files to process.</li>
<li><a href="reference/configuration.html#the-general-section">[general]</a> - The general settings.
<ul>
<li><a href="reference/configuration.html#the-build-dir-field">build-dir</a> - Default build directory.</li>
<li><a href="reference/configuration.html#the-language-mode-field">language-mode</a> - HDL language(s) to enable.</li>
</ul>
</li>
<li><a href="reference/configuration.html#the-vhdl-format-section">[vhdl-format]</a> - VHDL code formatting.</li>
<li><a href="reference/configuration.html#the-env-section">[env]</a> - The runtime environment variables.</li>
<li><a href="reference/configuration.html#the-plugin-array">[[plugin]]</a> - Define a plugin.
<ul>
<li><a href="reference/configuration.html#the-name-field">name</a> - The name of the plugin.</li>
<li><a href="reference/configuration.html#the-description-field">description</a> - A short description of the plugin.</li>
<li><a href="reference/configuration.html#the-command-field">command</a> - The command to execute the plugin.</li>
<li><a href="reference/configuration.html#the-args-field">args</a> - Arguments to pass to the command.</li>
<li><a href="reference/configuration.html#the-fileset-section">[fileset]</a> - Filesets to collect for the plugin.</li>
<li><a href="reference/configuration.html#the-explanation-field">explanation</a> - A detailed description of the plugin. </li>
</ul>
</li>
<li><a href="reference/configuration.html#the-protocol-array">[[protocol]]</a> - Define a protocol.
<ul>
<li><a href="reference/configuration.html#the-name-field">name</a> - The name of the protocol.</li>
<li><a href="reference/configuration.html#the-description-field">description</a> - A short description of the protocol.</li>
<li><a href="reference/configuration.html#the-command-field">command</a> - The command to execute the protocol.</li>
<li><a href="reference/configuration.html#the-args-field">args</a> - Arguments to pass to the command.</li>
<li><a href="reference/configuration.html#the-explanation-field">explanation</a> - A detailed description of the protocol.</li>
</ul>
</li>
</ul>
<h3 id="the-include-field"><a class="header" href="#the-include-field">The <code>include</code> field</a></h3>
<pre><code class="language-toml">include = [
    &quot;profiles/p1/config.toml&quot;,
    &quot;profiles/p2/config.toml&quot;
]
</code></pre>
<h3 id="the-general-section"><a class="header" href="#the-general-section">The <code>[general]</code> section</a></h3>
<h3 id="the-build-dir-field"><a class="header" href="#the-build-dir-field">The <code>build-dir</code> field</a></h3>
<p>Define the default output directory to create for the planning and building phases. This value can be overridden on the command-line when the <code>--build-dir</code> option is available. When this field is not defined, the default value for the build directory is &quot;build&quot;.</p>
<pre><code class="language-toml">[general]
build-dir = &quot;build&quot;
# ...
</code></pre>
<h3 id="the-language-mode-field"><a class="header" href="#the-language-mode-field">The <code>language-mode</code> field</a></h3>
<p>Enable specific HDLs to be read by <code>orbit</code>. Supports the following options: &quot;vhdl&quot;, &quot;verilog&quot;, or &quot;mixed&quot;. When this field is not defined, the default value for the language mode is &quot;mixed&quot; (enabling all supported HDLs).</p>
<pre><code class="language-toml">[general]
language-mode = &quot;mixed&quot;
</code></pre>
<h3 id="the-vhdl-format-section"><a class="header" href="#the-vhdl-format-section">The <code>[vhdl-format]</code> section</a></h3>
<p>The currently supported entries are demonstrated in the following code snippet. Entries not present will be set to their hard-coded default value.</p>
<pre><code class="language-toml">[vhdl-format]
# enable colored output for generated vhdl code
highlight-syntax = true
# number of whitespace characters per tab/indentation
tab-size = 2
# insert a tab before 'generic' and 'port' interface declarations
indent-interface = true
# automatically align a signal or constant's subtype with its other identifiers
type-auto-alignment = false
# number of whitespace characters after alignment (before ':' token)
type-offset = 0
# automatically align a instantiation's mapping with its other identifiers
mapping-auto-alignment = false
# number of whitespace characters after mapping (before '=&gt;' token)
mapping-offset = 1
</code></pre>
<h3 id="the-env-section"><a class="header" href="#the-env-section">The <code>[env]</code> section</a></h3>
<p>The user can define an arbitrary number of their own entries with their determined value represented in string format.</p>
<pre><code class="language-toml">[env]
# accessible as ORBIT_ENV_FOO
foo = &quot;0&quot;
# accessible as ORBIT_ENV_SUPER_BAR
super-bar = &quot;1&quot;
</code></pre>
<h3 id="the-plugin-array"><a class="header" href="#the-plugin-array">The <code>[[plugin]]</code> array</a></h3>
<h3 id="the-name-field-1"><a class="header" href="#the-name-field-1">The <code>name</code> field</a></h3>
<h3 id="the-description-field-1"><a class="header" href="#the-description-field-1">The <code>description</code> field</a></h3>
<h3 id="the-command-field"><a class="header" href="#the-command-field">The <code>command</code> field</a></h3>
<h3 id="the-args-field"><a class="header" href="#the-args-field">The <code>args</code> field</a></h3>
<h3 id="the-explanation-field"><a class="header" href="#the-explanation-field">The <code>explanation</code> field</a></h3>
<h3 id="the-fileset-section"><a class="header" href="#the-fileset-section">The <code>[fileset]</code> section</a></h3>
<h3 id="the-protocol-array"><a class="header" href="#the-protocol-array">The <code>[[protocol]]</code> array</a></h3>
<h3 id="the-name-field-2"><a class="header" href="#the-name-field-2">The <code>name</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-plugin-array">[plugin]</a>'s definition.</p>
<h3 id="the-description-field-2"><a class="header" href="#the-description-field-2">The <code>description</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-plugin-array">[plugin]</a>'s definition.</p>
<h3 id="the-command-field-1"><a class="header" href="#the-command-field-1">The <code>command</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-plugin-array">[plugin]</a>'s definition.</p>
<h3 id="the-args-field-1"><a class="header" href="#the-args-field-1">The <code>args</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-plugin-array">[plugin]</a>'s definition.</p>
<!--
## config.toml

The first config file you may come across is `config.toml`. This file is used to load initial startup settings into orbit and customize a user's program experience.

Here is a very minimal and basic example config file:
``` toml
include = ["profiles/ks-tech/config.toml"]

[env]
QUARTUS_PATH = "C:/IntelFPGA_lite/19.1/quartus/bin64"

[[plugin]]
alias = "zipr"
description = "Compress files into a submission-like format"
command = "python"
args = ["./main/plugins/zipr.py"]
fileset.zip-list = "submission.txt"

[[protocol]]
name = "zip-op"
description = "Handle zip file urls"
command = "python"
args = ["./main/protocols/download.py"]
```

The __home configuration__ is the config.toml file located at your $ORBIT_HOME path.

If you have `cat` installed, you can view your home config file in the console:
```
$ cat "$(orbit env ORBIT_HOME)/config.toml"
```

> __Tip:__ You can modify some values in the configuration file through the command-line by using the `orbit config` command.

## Paths

When specifying a value that is known to be a path, Orbit supports resolving relative paths in relation to the config.toml's path it is currently reading. This allows for a path value to be correct out-of-the-box across users and machines when sharing configurations.

## Precedence

Orbit supports multiple levels of configuration. The order of precedence:

1. local configuration file (located in current IP)

2. global configuration file (located in $ORBIT_HOME)

3. configuration files listed in `include` entry (last has higher precedence than first)

A key's value is overridden upon a configuration file of higher precedence also setting a previously defined key from a lower-precedence file.

## Entries

The following is a list of acceptable entries (key/value pairs) recognized by Orbit in configuration files (`config.toml`).


### `include` : _list_ of _string_
- paths to other configurations files to load before the home configuration
- only supported in the home configuration file

``` toml
include = ["profiles/ks-tech/config.toml"]
```

### `[env]` : _table_
- user-defined additional keys to set as runtime environment variables during build phase
- the following example would set an environment variable ORBIT_ENV_VAR_1 as "100" during runtime

``` toml
[env]
VAR_1 = "100"
# ...
```

<!-- 
### `core.build-dir` : _string_
- directory to create to save blueprint file to
- default is "build"

``` toml
[core]
build-dir = "target"
# ...
```

### `core.user` : _string_
- your name
- useful for template variable substitution

``` toml
[core]
user = "Kepler [KST-001]"
# ...
```

### `core.date-fmt` : _string_
- date formatting for template variable substitution
- default is `"%Y-%m-%d"`
- see chrono's [documentation](https://docs.rs/chrono/0.4.19/chrono/format/strftime/index.html#specifiers) for complete list of formatting specifiers

``` toml
[core]
date-fmt = "%B %e, %Y" # July 8, 2001
# ...
``` 

### `[[plugin]]` : _array of tables_
- `alias` : _string_ 
    - plugin name to reference when invoking
    - required
- `command` : _string_
    - first argument to pass to subprocess
    - required
- `description` : _string_
    - short description about the plugin
- `args` : _array_ of _string_
    - additional arguments to follow command in subprocess  
- `fileset` : _inline table_
    - user-defined additional keys to store glob-style file patterns
- `explanation` : _string_
    - long description about the plugin

``` toml
[[plugin]]
alias   = "vvd"
command = "vivado"
description = "Basic toolflow for Vivado Design Suite"
args    = ["-mode", "batch", "-source", "script.tcl"]
fileset.EDA-FLOW    = "*.tcl"
fileset.CONSTRAINTS = "*.xdc"
explanation = """\
    This plugin runs Vivado in non-project mode to perform its tasks.

Usage:
    orbit build --plugin vvd -- [options]

Options:
    -tclarg mode=<num>      0 - synth, 1 - impl, 2 - bit

Environment:
    ORBIT_ENV_VIVADO_PATH   Local path to Vivado binaries   

Dependencies:
    Vivado Design Suite (tested: 2019.2)
"""
```

### `[[protocol]]` : _array of tables_
- `name` : _string_ 
    - protocol name to reference in an IP's manifest
    - required
- `command` : _string_
    - first argument to pass to subprocess
    - required
- `description` : _string_
    - short description about the protocol
    - optional
- `args` : _array_ of _string_
    - additional arguments to follow command in subprocess 
    - optional 
- `explanation` : _string_
    - long description about the protocol
    - optional

``` toml
[[protocol]]
name = "git-op"
description = "Fetch remote repositories using git"
command = "git"
args = ["clone", "-b", "{{ orbit.ip.version }}", "{{ orbit.ip.source.url }}", "{{ orbit.queue }}/{{ orbit.ip.name }}"]
explanation = """\
This protocol tries to clone a repository defined under the source URL at a tag 
matching the IP's version.

Examples:
    [ip]
    # ...
    name = "lab1"
    version = "1.0.0"
    source = { protocol = "git-op", url = "https://github.com/path/to/lab1.git" }
    # ...

Dependencies:
    git (tested: 2.36.0)
"""
```
--><div style="break-before: page; page-break-before: always;"></div><h1 id="exporting-interfaces"><a class="header" href="#exporting-interfaces">Exporting Interfaces</a></h1>
<p>The <code>orbit get</code> command allows a user to receive various pieces of information related to a design unit, such its component declaration, defined architectures, or entity instantiation.</p>
<p>It also allows users to export the unit's interface with the <code>--json</code> flag. This is convenient when you wish to pass this information in a more machine-readable format to another tool/program.</p>
<h2 id="schema"><a class="header" href="#schema">Schema</a></h2>
<p>The following schema is implemented for the json output:</p>
<pre><code class="language-json">{
  &quot;identifier&quot;: string
  &quot;generics&quot;: [
    {
        &quot;identifier&quot;: string
        &quot;mode&quot;: string
        &quot;type&quot;: string
        &quot;default&quot;: string // null if blank
    }
  ]
  &quot;ports&quot;: [
    {
        &quot;identifier&quot;: string
        &quot;mode&quot;: string
        &quot;type&quot;: string
        &quot;default&quot;: string // null if blank
    }
  ]
  &quot;architectures&quot;: [
      string
  ],
  &quot;language&quot;: string
}
</code></pre>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>Some ideas about exporting json from <code>orbit get</code> can be found at this <a href="https://blog.kellybrazil.com/2021/12/03/tips-on-adding-json-output-to-your-cli-app/">blog post</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line"><a class="header" href="#command-line">Command line</a></h1>
<p>The command line is the main way of interacting with <code>orbit</code>. Let's understand some terminology and rules for communicating to <code>orbit</code> through the command line.</p>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<p>Angular brackets (<code>&lt; &gt;</code>) denotes that a user input is required. The label within the angular brackets gives a hint to the user as to what type of value to enter here.</p>
<p>Square brackets (<code>[ ]</code>) denotes that the input is optional and is not required to get the command to successfully run.</p>
<h2 id="jargon"><a class="header" href="#jargon">Jargon</a></h2>
<p>Orbit uses <em>subcommands</em>, <em>arguments</em>, <em>options</em>, <em>flags</em>, and <em>switches</em>.</p>
<h3 id="subcommand"><a class="header" href="#subcommand"><strong>Subcommand</strong></a></h3>
<p>Subcommands are special keywords to route to a particular action. Each subcommand inherits all supercommand's available options. They are the first positional argument following the call to <code>orbit</code>.</p>
<pre><code>orbit get
</code></pre>
<h3 id="argument"><a class="header" href="#argument"><strong>Argument</strong></a></h3>
<p>An argument is a value interpreted based on its position in the input. Arguments must be included when requested by Orbit within angular brackets (<code>&lt; &gt;</code>).</p>
<pre><code>orbit new &lt;path&gt;
</code></pre>
<p>Arguments may be omitted if they are wrapped with square brackets (<code>[ ]</code>).</p>
<pre><code>orbit search [&lt;ip&gt;]
</code></pre>
<h3 id="flag"><a class="header" href="#flag"><strong>Flag</strong></a></h3>
<p>A flag is a simple boolean on-off conditional to alter a command's behavior, that is true when present and false otherwise. </p>
<pre><code>--help
</code></pre>
<p>Flags are options that do not take an argument and can be omitted.</p>
<h3 id="option"><a class="header" href="#option"><strong>Option</strong></a></h3>
<p>An option is a type of flag that, when provided, is required to have an argument assigned to it. The argument may immediately proceed the option's flag separated by whitespace.</p>
<pre><code>--plugin &lt;name&gt;
</code></pre>
<p>The argument may also be attached to the option's flag with an equal sign <code>=</code>.</p>
<pre><code>--plugin=&lt;name&gt;
</code></pre>
<p>Options are able to be omitted.</p>
<h3 id="switch"><a class="header" href="#switch"><strong>Switch</strong></a></h3>
<p>A switch is a shorthand flag denoted by a single dash and a single character.</p>
<pre><code>-h
</code></pre>
<p>Multiple switches can be chained onto the same dash.</p>
<pre><code>-ci
</code></pre>
<p>If a switch is associated with an option, it must be declared last on a chain with its argument to immediately follow separated by whitespace or an equal sign <code>=</code>.</p>
<pre><code>-o &lt;file&gt;
</code></pre>
<p>Common flags and options may have a shorthand <em>switch</em> associated with them. For example, <code>--help</code> can be alternatively passed with just <code>-h</code>.</p>
<h3 id="argument-terminator"><a class="header" href="#argument-terminator"><strong>Argument terminator</strong></a></h3>
<p>The argument terminator is a special no-op flag <code>--</code> that tells the command-line interpreter to parse up until this symbol.</p>
<p>Some scenarios will allow you to pass arguments through <code>orbit</code> to an internally executed command. You can pass these arguments by using the <em>argument terminator</em>.</p>
<h4 id="examples-1"><a class="header" href="#examples-1">Examples</a></h4>
<p>An example of using the argument terminator is brought up when calling a plugin through <code>orbit</code> during the building step.</p>
<pre><code>$ orbit build --plugin yilinx -- --sram
</code></pre>
<p>In this command, <code>orbit</code> does not interpret the &quot;--sram&quot; flag, but instead passes it to the plugin named &quot;yilinx&quot; to handle.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>Commands are loosely grouped into two types: development and management. The commands are listed below in their group and in a typical order of usage for a possible workflow.</p>
<h2 id="development"><a class="header" href="#development">Development</a></h2>
<ul>
<li><a href="commands/./new.html">orbit new</a></li>
<li><a href="commands/./init.html">orbit init</a></li>
<li><a href="commands/./read.html">orbit read</a></li>
<li><a href="commands/./get.html">orbit get</a></li>
<li><a href="commands/./tree.html">orbit tree</a></li>
<li><a href="commands/./plan.html">orbit plan</a></li>
<li><a href="commands/./build.html">orbit build</a></li>
</ul>
<h2 id="management"><a class="header" href="#management">Management</a></h2>
<ul>
<li><a href="commands/./search.html">orbit search</a></li>
<li><a href="commands/./show.html">orbit show</a></li>
<li><a href="commands/./install.html">orbit install</a></li>
<li><a href="commands/./launch.html">orbit launch</a></li>
<li><a href="commands/./uninstall.html">orbit uninstall</a></li>
<li><a href="commands/./config.html">orbit config</a></li>
<li><a href="commands/./env.html">orbit env</a></li>
</ul>
<h2 id="command-flow"><a class="header" href="#command-flow">Command Flow</a></h2>
<p>A development workflow is illustrated with a typical <code>orbit</code> command flow:</p>
<p><img src="commands/./../images/command-flow.svg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-new"><a class="header" href="#orbit-new"><strong>orbit new</strong></a></h1>
<h2 id="name"><a class="header" href="#name"><strong>NAME</strong></a></h2>
<p>new - create a new ip</p>
<h2 id="synopsis"><a class="header" href="#synopsis"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit new [options] &lt;path&gt;
</code></pre>
<h2 id="description"><a class="header" href="#description"><strong>DESCRIPTION</strong></a></h2>
<p>This command will create a new ip at the target directory <code>&lt;path&gt;</code>. The command
assumes the path does not already exists. It will attempt to create a new 
directory at the destination with a manifest. </p>
<p>If no name is supplied, then the ip's name defaults to the final path component
of the path argument. Use the name option to provide a custom name.</p>
<p>This command fails if the path already exists. See the <code>init</code> command for
initializing an already existing project into an ip.</p>
<h2 id="options"><a class="header" href="#options"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;path&gt;</code><br />
      The new directory to make</p>
<p><code>--name &lt;name&gt;</code><br />
      The ip name to create</p>
<h2 id="examples-2"><a class="header" href="#examples-2"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit new gates
orbit new ./projects/dir7 --name adder
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-init"><a class="header" href="#orbit-init"><strong>orbit init</strong></a></h1>
<h2 id="name-1"><a class="header" href="#name-1"><strong>NAME</strong></a></h2>
<p>init - initialize an ip from an existing project</p>
<h2 id="synopsis-1"><a class="header" href="#synopsis-1"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit init [options] [&lt;path&gt;]
</code></pre>
<h2 id="description-1"><a class="header" href="#description-1"><strong>DESCRIPTION</strong></a></h2>
<p>This command will initialize a new ip at the target directory <code>&lt;path&gt;</code>. If no path
is supplied, then it defaults to the current working directory.</p>
<p>If no name is supplied, then the ip's name defaults to the final path component
of the path argument. Use the name option to provide a custom name.</p>
<p>This command fails if the path does not exist. See the <code>new</code> command for
creating an ip from a non-existing directory.</p>
<h2 id="options-1"><a class="header" href="#options-1"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;path&gt;</code><br />
      The location to initialize an ip</p>
<p><code>--name &lt;name&gt;</code><br />
      The name of the ip</p>
<p><code>--force</code><br />
      Overwrite a manifest if one already exists</p>
<h2 id="examples-3"><a class="header" href="#examples-3"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit init
orbit init ./projects/gates
orbit init --name hello_world
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-show"><a class="header" href="#orbit-show"><strong>orbit show</strong></a></h1>
<h2 id="name-2"><a class="header" href="#name-2"><strong>NAME</strong></a></h2>
<p>show - print information about an ip</p>
<h2 id="synopsis-2"><a class="header" href="#synopsis-2"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit show [options] [&lt;ip&gt;]
</code></pre>
<h2 id="description-2"><a class="header" href="#description-2"><strong>DESCRIPTION</strong></a></h2>
<p>This command retrieves various pieces of information about a particular ip to
gain a better understanding of how to utilize the ip. By default, it displays
the ip's manifest, if and only if the ip is able to be located.</p>
<p>It will first attempt to return the information from a possible installation. If
one does not exist, then it searches the downloads location for the ip.</p>
<p>If <code>--units</code> is specified, then a list of the ip's HDL units are displayed.</p>
<p>If <code>--versions</code> is specified, then a list of the ip's already available versions
are displayed.</p>
<p>If no spec is provided for <code>&lt;ip&gt;</code>, then it will retrieve information based on the
current working ip, if exists.</p>
<h2 id="options-2"><a class="header" href="#options-2"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;ip&gt;</code><br />
      The spec of the ip to query</p>
<p><code>--versions</code><br />
      Display the list of possible versions</p>
<p><code>--units</code><br />
      Display the list of HDL primary design units associated with this ip</p>
<h2 id="examples-4"><a class="header" href="#examples-4"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit show --units
orbit show gates:1.0.0 --units
orbit show gates --versions
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-read"><a class="header" href="#orbit-read"><strong>orbit read</strong></a></h1>
<h2 id="name-3"><a class="header" href="#name-3"><strong>NAME</strong></a></h2>
<p>read - navigate hdl design unit source code</p>
<h2 id="synopsis-3"><a class="header" href="#synopsis-3"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit read [options] &lt;unit&gt;
</code></pre>
<h2 id="description-3"><a class="header" href="#description-3"><strong>DESCRIPTION</strong></a></h2>
<p>This command allows the user to navigate source code to gain a quicker
understanding of the available code. By default, it will display the code to the
console.</p>
<p>If no ip specification is provided through the <code>--ip</code> option, then it will
assume to search the current working ip, if it exists.</p>
<p>If <code>--file</code> is provided, then the source code will be written to a temporary
read-only file. Also providing '--location' in this context will append the
requested code segment's line and column number to the end of the generated
filepath.</p>
<p>The options <code>--start</code>, <code>--end</code>, and <code>--doc</code> all accept valid VHDL code to
search for in the identified source code file. The <code>--doc</code> option will find the
immediate single-line comments preceding the supplied code value.</p>
<p>The <code>read</code> command attempts to clean the temporary directory at every call to
it. To keep existing files alive while allowing new files to appear, use the
<code>--keep</code> flag.</p>
<h2 id="options-3"><a class="header" href="#options-3"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;unit&gt;</code><br />
      Primary design unit identifier</p>
<p><code>--ip &lt;spec&gt;</code><br />
      The ip specification to search in the catalog</p>
<p><code>--file</code><br />
      Copy the source code to a temporary read-only file</p>
<p><code>--location</code><br />
      Append the targeted code segment's line and column number to the resulting filepath </p>
<p><code>--keep</code><br />
      Do not clean the temporary directory of existing files</p>
<p><code>--limit &lt;num&gt;</code><br />
      Set a maximum number of lines to write</p>
<p><code>--start &lt;code&gt;</code><br />
      Start the code navigation upon matching this VHDL segment</p>
<p><code>--end &lt;code&gt;</code><br />
      Stop the code navigation upon matching this VHDL segment</p>
<p><code>--doc &lt;code&gt;</code><br />
      Navigate to the preceding comments of this VHDL segment</p>
<h2 id="examples-5"><a class="header" href="#examples-5"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit read and_gate --ip gates:1.0.0
orbit read math_pkg --ip math --doc &quot;function clog2&quot;
orbit read math_pkg --ip math --start &quot;package math_pkg&quot; --doc &quot;function flog2p1&quot; --location --file
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-get"><a class="header" href="#orbit-get"><strong>orbit get</strong></a></h1>
<h2 id="name-4"><a class="header" href="#name-4"><strong>NAME</strong></a></h2>
<p>get - fetch an hdl entity for code integration</p>
<h2 id="synopsis-4"><a class="header" href="#synopsis-4"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit get [options] &lt;unit&gt;
</code></pre>
<h2 id="description-4"><a class="header" href="#description-4"><strong>DESCRIPTION</strong></a></h2>
<p>This command will provide the relevant information about the requested HDL
entity required to integrate the code into the current design. The command
produces valid HDL code displayed to stdout that allows a user to copy and
paste the results into a new hdl source code file for proper hierarchy code
reuse.</p>
<p>If the spec if not provided with <code>--ip</code>, then it will search the current
working ip for the requested HDL entity.</p>
<p>If the <code>--instance</code> flag is used without the <code>--component</code> flag, then it will
display the direct instantiation style code for VHDL (VHDL-93 feature).</p>
<p>It is important to note that any units referenced from ip outside of the
current working ip are not automatically tracked as a dependency. In order to
add an ip as a dependency to properly reference its source code files, edit
the current working ip's manifest with a new entry under the <code>[dependencies]</code>
table with the dependency ip and its version.</p>
<p>An identifier prefix or suffix can be attached to the signal declarations and
the instantiation's port connection signals by using <code>--signal-prefix</code> and 
<code>--signal-suffix</code> respectively. These optional texts are treated as normal
strings and are not checked for correct syntax.</p>
<p>When no output options are specified, this command by default will display the
entity's component declaration.</p>
<h2 id="options-4"><a class="header" href="#options-4"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;unit&gt;</code><br />
      Primary design unit identifier</p>
<p><code>--ip &lt;spec&gt;</code><br />
      The ip that contains the requested unit</p>
<p><code>--json</code><br />
      Export the entity information as valid json</p>
<p><code>--library, -l</code><br />
      Display the unit's library declaration</p>
<p><code>--component, -c</code><br />
      Display the component declaration</p>
<p><code>--signals, -s</code><br />
      Display the constant and signal declarations</p>
<p><code>--instance, -i</code><br />
      Display the unit's instantiation</p>
<p><code>--architecture, -a</code><br />
      Display the detected architectures</p>
<p><code>--name &lt;identifier&gt;</code><br />
      Set the instance's identifier</p>
<p><code>--signal-prefix &lt;value&gt;</code><br />
      Prepend information to the instance's signals</p>
<p><code>--signal-suffix &lt;value&gt;</code><br />
      Append information to the instance's signals</p>
<h2 id="examples-6"><a class="header" href="#examples-6"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit get and_gate --ip gates:1.0.0 --component
orbit get ram --ip mem:2.0.3 -csi
orbit get uart -si --name u0
orbit get or_gate --ip gates --json
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-tree"><a class="header" href="#orbit-tree"><strong>orbit tree</strong></a></h1>
<h2 id="name-5"><a class="header" href="#name-5"><strong>NAME</strong></a></h2>
<p>tree - view the dependency graph</p>
<h2 id="synopsis-5"><a class="header" href="#synopsis-5"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit tree [options]
</code></pre>
<h2 id="description-5"><a class="header" href="#description-5"><strong>DESCRIPTION</strong></a></h2>
<p>This command will show the hierarchical tree-structure starting from a node.
By default, it will attempt to automatically detect the root if it is
unambiguous and <code>--root</code> is not provided. This command only works when called
from the current working ip.</p>
<p>The hdl-level tree displays the connections between entities. The hdl tree does 
not show how many times an entity is instantiated within a parent entity, and 
all architectures for each entity are analyzed. If an unidentified entity is 
instantiated it will appear as a leaf and is denoted as a black box by a '?' 
character.</p>
<p>An entity is considered a black box if it cannot find that referenced entity's 
hdl source code file.</p>
<p>To view the dependency tree at the ip-level, use <code>--ip</code>.</p>
<h2 id="options-5"><a class="header" href="#options-5"><strong>OPTIONS</strong></a></h2>
<p><code>--root &lt;unit&gt;</code><br />
      The uppermost hdl unit to start the dependency tree</p>
<p><code>--compress</code><br />
      Replace duplicate branches with a label marking</p>
<p><code>--all</code><br />
      Include all possible roots in the tree</p>
<p><code>--format &lt;fmt&gt;</code><br />
      Determine how to display nodes ('long', 'short')</p>
<p><code>--ascii</code><br />
      Limit the textual tree characters to the 128 ASCII set</p>
<p><code>--ip</code><br />
      View the dependency graph at the ip level</p>
<h2 id="examples-7"><a class="header" href="#examples-7"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit tree --ip
orbit tree --root top --format long
orbit tree --ascii --all
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-plan"><a class="header" href="#orbit-plan"><strong>orbit plan</strong></a></h1>
<h2 id="name-6"><a class="header" href="#name-6"><strong>NAME</strong></a></h2>
<p>plan - generate a blueprint file</p>
<h2 id="synopsis-6"><a class="header" href="#synopsis-6"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit plan [options]
</code></pre>
<h2 id="description-6"><a class="header" href="#description-6"><strong>DESCRIPTION</strong></a></h2>
<p>This command carries out the &quot;planning phase&quot;. This phase involves reading
and writing to the lockfile and collecting all necessary files according to 
their defined fileset into a blueprint file for future build processes. This 
command acts upon the current working ip.</p>
<p>By default, the top level unit and testbench are auto-detected according to
the current design heirarchy. If there are multiple candidates for a potential
top level or testbench, it will exit and ask the user to explicitly select
a candidate. To include all top levels and testbenches, use <code>-all</code>.</p>
<p>The top level unit and testbench will be stored in a <code>.env</code> file within the
build directory. This <code>.env</code> file is read during the build command to set
the proper environment variables for downstream plugins and scripts that
may require this information. If a known plugin is provided with <code>--plugin</code>,
then it will also be stored in the <code>.env</code> file to be recalled during the
build phase.</p>
<p>User-defined filesets are only collected within the current working ip's 
path. Plugins may have custom filesets defined in their configuration. When
specifying a known plugin with <code>--plugin</code>, it will collect the filesets 
defined for that plugin. Use <code>--fileset</code> as many times as needed to define
additional filesets.</p>
<p>During the planning phase, a lockfile is produced outlining the exact ip
dependencies required, how to get them, and how to verify them. The lockfile
should be checked into version control and should not manually edited by the 
user.</p>
<p>If the current working ip's manifest data matches its data stored in its
own lockfile, then Orbit will read from the lockfile to create the ip
dependency graph. To force Orbit to build the ip dependency graph from
scratch, use <code>--force</code>.</p>
<p>If only needing to update the lockfile, use <code>--lock-only</code>. This flag does 
not require a toplevel or testbench to be determined. Using <code>--lock-only</code> with
<code>--force</code> will overwrite the lockfile regardless if it is already in sync 
with the current working ip's manifest data.</p>
<p>When updating the lockfile, this command will download and install any new
dependencies if necessary. To only download an ip, see the <code>download</code> command.
To only install an ip, see the <code>install</code> command.</p>
<p>If an installed dependency's computed checksum does not match the checksum
stored in the lockfile, it assumes the installation to be corrupt and will 
re-install the dependency to the cache.</p>
<h2 id="options-6"><a class="header" href="#options-6"><strong>OPTIONS</strong></a></h2>
<p><code>--top &lt;unit&gt;</code><br />
      The top level entity to explicitly define</p>
<p><code>--bench &lt;tb&gt;</code><br />
      The top level testbench to explicitly define</p>
<p><code>--plugin &lt;name&gt;</code><br />
      A plugin to refer to gather its declared filesets</p>
<p><code>--build-dir &lt;dir&gt;</code><br />
      The relative directory to place the blueprint.tsv file</p>
<p><code>--fileset &lt;key=glob&gt;...</code><br />
      A glob-style pattern identified by a name to add into the blueprint</p>
<p><code>--clean</code><br />
      Removes all files from the build directory before execution</p>
<p><code>--list</code><br />
      Display all available plugins and exit</p>
<p><code>--force</code><br />
      Ignore reading the precomputed lock file</p>
<p><code>--lock-only</code><br />
      Create the lock file and exit</p>
<p><code>--all</code><br />
      Include all locally found HDL files</p>
<h2 id="examples-8"><a class="header" href="#examples-8"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit plan --bench my_tb
orbit plan --top and_gate --fileset PIN-PLAN=&quot;*.board&quot;
orbit plan --plugin vivado --clean --bench ram_tb
orbit plan --lock-only
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-build"><a class="header" href="#orbit-build"><strong>orbit build</strong></a></h1>
<h2 id="name-7"><a class="header" href="#name-7"><strong>NAME</strong></a></h2>
<p>build - execute a backend workflow</p>
<h2 id="synopsis-7"><a class="header" href="#synopsis-7"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit build [options] [--] [args]...
</code></pre>
<h2 id="description-7"><a class="header" href="#description-7"><strong>DESCRIPTION</strong></a></h2>
<p>This command carries out the &quot;building phase&quot;. This phase involves running a
user-defined command or plugin as a subprocess. It is required that the
planning phase occurs before the building phase. This command acts upon the 
current working ip.</p>
<p>If a plugin was previously used during the planning phase, then this command
by default will reference and call that plugin after loading the previously
written <code>.env</code> file from the planning phase. Either a plugin from <code>--plugin</code> 
or a command from <code>--command</code> is required if a plugin was not previously
specified during planning.</p>
<p>If <code>--list</code> is used, then it will display a list of the available plugins to
the user. Using <code>--list</code> in combination with a plugin from <code>--plugin</code> will
display any detailed help information the plugin has documented in its 
definition.</p>
<p>As a refresher, a backend workflow typically performs three tasks:</p>
<ol>
<li>Parse the blueprint file</li>
<li>Process the referenced files listed in the blueprint</li>
<li>Generate an output product </li>
</ol>
<p>Any command-line arguments entered after the terminating flag <code>--</code> will be
passed in the received order as arguments to the subprocess's command. If a plugin already
has defined arguments, the additional arguments passed from the command-line
will follow the previously defined arguments.</p>
<p>The subprocess will spawn from the current working ip's build directory.</p>
<h2 id="options-7"><a class="header" href="#options-7"><strong>OPTIONS</strong></a></h2>
<p><code>--plugin &lt;name&gt;</code><br />
      Plugin to execute</p>
<p><code>--command &lt;cmd&gt;</code><br />
      Command to execute</p>
<p><code>--list</code><br />
      View available plugins</p>
<p><code>--force</code><br />
      Execute the command without checking for a blueprint</p>
<p><code>--build-dir &lt;dir&gt;</code><br />
      The relative directory to locate the blueprint file</p>
<p><code>--verbose</code><br />
      Display the command being executed</p>
<p><code>args</code><br />
      Arguments to pass to the plugin or command</p>
<h2 id="examples-9"><a class="header" href="#examples-9"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit build --plugin xsim -- --elab
orbit build --command python -- synth.py
orbit build --verbose
orbit build --plugin xsim --force -- --help
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-launch"><a class="header" href="#orbit-launch"><strong>orbit launch</strong></a></h1>
<h2 id="name-8"><a class="header" href="#name-8"><strong>NAME</strong></a></h2>
<p>launch - release an ip's next version </p>
<h2 id="synopsis-8"><a class="header" href="#synopsis-8"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit launch [options]
</code></pre>
<h2 id="description-8"><a class="header" href="#description-8"><strong>DESCRIPTION</strong></a></h2>
<p>This command will perform a series of checks against the current ip to 
verify it is able to release a new version and the tag the latest git 
commit with the next version number. </p>
<p>By default, it will only perform a dry run of the launch process to verify 
the procedure will run with no errors. To proceed with a launch to tag the
latest commit, include the '--ready' flag.</p>
<p>The next version it will release is the one defined in the Orbit.toml 
manifest file. You can also set the next version on the command-line by 
using the '--next &lt;version&gt;' option. If this option is used, then a new git
commit will be created by Orbit to save the version change it makes to the 
Orbit.toml. To write a custom message for this commit, include the 
'--message &lt;message&gt;' option.</p>
<p>The '--next &lt;version&gt;' option will go off of the previous version defined
in the Orbit.toml manifest to determine the next increment. </p>
<h2 id="options-8"><a class="header" href="#options-8"><strong>OPTIONS</strong></a></h2>
<p><code>--ready</code><br />
      perform a real run through the launch process</p>
<p><code>--next &lt;version&gt;</code><br />
      declare the next version or 'major', 'minor', or 'patch' increment</p>
<p><code>--message, -m &lt;message&gt;</code><br />
      override the default Orbit commit message when using '--next'</p>
<p><code>--no-install</code><br />
      skip installing the newly launched version to the cache</p>
<h2 id="examples-10"><a class="header" href="#examples-10"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit launch --next 1.0.0
orbit launch --next major --ready
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-search"><a class="header" href="#orbit-search"><strong>orbit search</strong></a></h1>
<h2 id="name-9"><a class="header" href="#name-9"><strong>NAME</strong></a></h2>
<p>search - browse the ip catalog</p>
<h2 id="synopsis-9"><a class="header" href="#synopsis-9"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit search [options] [&lt;ip&gt;]
</code></pre>
<h2 id="description-9"><a class="header" href="#description-9"><strong>DESCRIPTION</strong></a></h2>
<p>This command will display a list of all the known ip in the catalog. The catalog
consists of 3 levels: cache, downloads, and channels.</p>
<p>Any ip at the cache level are considered installed. Any ip at the downloads
level are considered downloaded. Any ip at the channels level is considered
available. An ip does not exist in the catalog if it is not found at any one
of the three defined levels.</p>
<p>When a package name is provided for <code>&lt;ip&gt;</code>, it will begin to partially match 
the name with the names of the known ip. If an ip's name begins with <code>&lt;ip&gt;</code>, it
is included in the filtered resultes. To strictly match the argument against an
ip name, use <code>--match</code>.</p>
<h2 id="options-9"><a class="header" href="#options-9"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;ip&gt;</code><br />
      The beginning of a package name</p>
<p><code>--install, -i</code><br />
      Filter ip installed to the cache</p>
<p><code>--download, -d</code><br />
      Filter ip downloaded to the downloads</p>
<p><code>--keyword &lt;term&gt;...</code><br />
      Include ip that contain this keyword</p>
<p><code>--limit &lt;num&gt;</code><br />
      The maximum number of results to return</p>
<p><code>--match</code><br />
      Return results that only pass each filter</p>
<h2 id="examples-11"><a class="header" href="#examples-11"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit search axi
orbit search --keyword memory --keyword ecc
orbit search --keyword RF --limit 20
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-download"><a class="header" href="#orbit-download"><strong>orbit download</strong></a></h1>
<h2 id="name-10"><a class="header" href="#name-10"><strong>NAME</strong></a></h2>
<p>download - fetch packages from the internet</p>
<h2 id="synopsis-10"><a class="header" href="#synopsis-10"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit download [options]
</code></pre>
<h2 id="description-10"><a class="header" href="#description-10"><strong>DESCRIPTION</strong></a></h2>
<p>This command will get a package from the internet using the default protocol
or a user-defined protocol. It places the package in the path defined as
environment variable <code>$ORBIT_DOWNLOADS</code>.</p>
<p>Downloads are vital to Orbit's management system as to avoid having to solely 
rely on accessing the internet to get IP. Downloads allow Orbit to quickly
repair broken installations and allow users to learn about IP before installing.</p>
<p>When using a custom protocol, Orbit expects the final fetched repository to
exist within a special directory called the queue. By default, the queue is set
to a temporary directory, but it can be overridden with <code>--queue</code>. After a 
protocol is executed, Orbit resumes the download process by trying to detect the 
target IP and then performing a compression algorithm on the path to store as a 
single file archive. This final archive is special and packed with additional 
bytes, which makes it unsuitable to easily unzip with existing compression 
tools.</p>
<p>A lockfile is required to exist in the current IP in order to download its 
dependencies.</p>
<p>Variable substitution is supported when specifying the &quot;command&quot; and &quot;args&quot;
fields for a protocol. Most notably, the queue is accessed as 
<code>{{ orbit.queue }}</code>. See <code>orbit help protocols</code> for more information about 
available variables.</p>
<p>This action may automatically run during an install if the package is missing
from the downloads. See <code>orbit help install</code> for more details.</p>
<h2 id="options-10"><a class="header" href="#options-10"><strong>OPTIONS</strong></a></h2>
<p><code>--list</code><br />
      Print URLs and exit</p>
<p><code>--missing</code><br />
      Filter only uninstalled packages (default: true)</p>
<p><code>--all</code><br />
      Gather packages from all dependency types</p>
<p><code>--queue &lt;dir&gt;</code><br />
      Set the destination directory for placing fetched repositories</p>
<p><code>--verbose</code><br />
      Display the custom protocol being executed</p>
<p><code>--force</code><br />
      Download selected packages regardless of status</p>
<h2 id="examples-12"><a class="header" href="#examples-12"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit download --missing --list
orbit download --all --force
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-install"><a class="header" href="#orbit-install"><strong>orbit install</strong></a></h1>
<h2 id="name-11"><a class="header" href="#name-11"><strong>NAME</strong></a></h2>
<p>install - store an immutable reference to an ip</p>
<h2 id="synopsis-11"><a class="header" href="#synopsis-11"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit install [options]
</code></pre>
<h2 id="description-11"><a class="header" href="#description-11"><strong>DESCRIPTION</strong></a></h2>
<p>This command will place an ip into the cache. By default, the specified version
is the 'latest' released version orbit can identify.</p>
<p>When this command is ran without specifying the <ip> or a source (such as
<code>--url</code> or <code>--path</code>), it will attempt to install the current working ip, if it
exists.</p>
<p>By default, any dependencies required only for development by the target ip are
omitted from installation. To also install these dependencies, use <code>--all</code>.</p>
<p>If a protocol is recognized using <code>--protocol</code>, then an optional tag can also 
be supplied to help the protocol with providing any additional information it
may require.</p>
<h2 id="options-11"><a class="header" href="#options-11"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;ip&gt;</code><br />
      Ip specification</p>
<p><code>--url &lt;url&gt;</code><br />
      URL to install the ip from the internet</p>
<p><code>--path &lt;path&gt;</code><br />
      Path to install the ip from local file system</p>
<p><code>--protocol &lt;name&gt;</code><br />
      Use a configured protocol to download ip</p>
<p><code>--tag &lt;tag&gt;</code><br />
      Unique tag to provide to the protocol</p>
<p><code>--force</code><br />
      Install the ip regardless of the cache slot occupancy</p>
<p><code>--list</code><br />
      View available protocols and exit</p>
<p><code>--all</code><br />
      Install all dependencies (including development)</p>
<h2 id="examples-13"><a class="header" href="#examples-13"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit install
orbit install lcd_driver:2.0
orbit install adder:1.0.0 --url https://my.adder/project.zip
orbit install alu:2.3.7 --path ./projects/alu --force
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-env"><a class="header" href="#orbit-env"><strong>orbit env</strong></a></h1>
<h2 id="name-12"><a class="header" href="#name-12"><strong>NAME</strong></a></h2>
<p>env - print orbit environment information</p>
<h2 id="synopsis-12"><a class="header" href="#synopsis-12"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit env [options]
</code></pre>
<h2 id="description-12"><a class="header" href="#description-12"><strong>DESCRIPTION</strong></a></h2>
<p>This command prints environment variables relevant to <code>orbit</code>.</p>
<p>By default, this command prins information as a shell script. If one or more
variable names are given as arguments as <code>&lt;key&gt;</code>, then it will print the value
of each provided variables on its own line.</p>
<h2 id="options-12"><a class="header" href="#options-12"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;key&gt;...</code><br />
      Include this variable's value specifically in the environment information</p>
<h2 id="examples-14"><a class="header" href="#examples-14"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit env
orbit env ORBIT_HOME
orbit env ORBIT_CACHE ORBIT_DOWNLOADS
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-config"><a class="header" href="#orbit-config"><strong>orbit config</strong></a></h1>
<h2 id="name-13"><a class="header" href="#name-13"><strong>NAME</strong></a></h2>
<p>config - modify configuration values</p>
<h2 id="synopsis-13"><a class="header" href="#synopsis-13"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit config [options]
</code></pre>
<h2 id="description-13"><a class="header" href="#description-13"><strong>DESCRIPTION</strong></a></h2>
<p>This command will alter configuration entries in Orbit's settings file named
<code>config.toml</code>. By default, it will modify the user's config file found at
the path read from the environment variable <code>$ORBIT_HOME</code>.</p>
<p>To access an entry (key/value pair), use dots (<code>.</code>) to delimit between 
intermediate table identifiers and the final key identifier.</p>
<p>The command modifies the document in three independent stages. The first stage
modifies the settings by iterating through all defined <code>--append</code> values. Then, 
it will insert all <code>--set</code> values. Lastly, it will remove all <code>--unset</code> entries.</p>
<h2 id="options-13"><a class="header" href="#options-13"><strong>OPTIONS</strong></a></h2>
<p><code>--global</code><br />
      Access the home configuration file</p>
<p><code>--local</code><br />
      Access the current project's configuration file</p>
<p><code>--append &lt;key=value&gt;...</code><br />
      Add a value to the key storing a list</p>
<p><code>--set &lt;key=value&gt;...</code><br />
      Write the value at the key's entry</p>
<p><code>--unset &lt;key&gt;...</code><br />
      Delete the key's entry</p>
<h2 id="examples-15"><a class="header" href="#examples-15"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit config --append include=&quot;~/.orbit/profiles/ks-tech&quot;
orbit config --unset env.VIVADO_PATH --global
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-remove"><a class="header" href="#orbit-remove"><strong>orbit remove</strong></a></h1>
<h2 id="name-14"><a class="header" href="#name-14"><strong>NAME</strong></a></h2>
<p>remove - uninstall an ip from the catalog</p>
<h2 id="synopsis-14"><a class="header" href="#synopsis-14"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit remove [options] &lt;ip&gt;
</code></pre>
<h2 id="description-14"><a class="header" href="#description-14"><strong>DESCRIPTION</strong></a></h2>
<p>This command will remove known ip stored in the catalog. By default, it will
remove the ip from the cache. This include any dynamic entries spawned from the
requested ip to remove.</p>
<p>To remove the ip from the cache and downloads locations, use <code>--all</code>.</p>
<h2 id="options-14"><a class="header" href="#options-14"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;ip&gt;</code><br />
      Ip specification</p>
<p><code>--all</code><br />
      remove the ip from the cache and downloads</p>
<p><code>--recurse</code><br />
      fully remove the ip and its dependencies</p>
<h2 id="examples-16"><a class="header" href="#examples-16"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit remove gates
orbit remove gates:1.0.0 --all
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<h3 id="blueprint-1"><a class="header" href="#blueprint-1">Blueprint</a></h3>
<p>A blueprint is a tab-separated file that lists all the necessary files needed to perform a particular build for the CWIP. HDL files are listed in topologically-sorted order from top to bottom, while other files can be included through user-defined filesets. </p>
<p>Each line in a blueprint consists of 3 values separated by tabs (fileset, identifier, filepath). If the file is an HDL file, the identifier is the HDL library identifier, otherwise, it is the file's name.</p>
<h3 id="cache"><a class="header" href="#cache">Cache</a></h3>
<p>The cache is the location where immutable references to a specific IP's version exist. Dependencies to an IP are referenced from the cache. The IP's at the cache level are considered <em>installed</em>.</p>
<h3 id="catalog"><a class="header" href="#catalog">Catalog</a></h3>
<p>The catalog is the user's entire space of currently known IP to <code>orbit</code>. It consists of 3 main layers: cache, downloads, channels.</p>
<h3 id="channels"><a class="header" href="#channels">Channels</a></h3>
<p>The channels are a set of decentralized registries that store the manifests for versions of IP. No source code is stored in a channel, however, <code>orbit</code> is able to use the manifest as means to <em>download</em> an IP to the downloads for local filesystem access. The IP's at the channels level are considered <em>available</em>. Users are encouraged to create and share their own channels.</p>
<h3 id="current-working-ip-cwip"><a class="header" href="#current-working-ip-cwip">Current Working IP (CWIP)</a></h3>
<p>The current working IP (CWIP) is the IP detected from the current working directory on the command-line. Some commands can only be executed from the CWIP, such as <code>plan</code> and <code>build</code>.</p>
<h3 id="downloads"><a class="header" href="#downloads">Downloads</a></h3>
<p>The downloads is the location where compressed snapshots of a specific IP's version exist. The compressed IP files are unable to be referenced as dependencies, but they are able to be <em>installed</em> to the cache for usage. The IP's at the downloads level are considered <em>downloaded</em>.</p>
<h3 id="fileset"><a class="header" href="#fileset">Fileset</a></h3>
<p>A fileset is a glob-style pattern for collecting files under a given name. Filesets are
used to group common files together into the blueprint during the planning phase
for future processing by a plugin during the building phase.</p>
<h3 id="ip-specification-spec"><a class="header" href="#ip-specification-spec">IP Specification (spec)</a></h3>
<p>The spec describes the format for identifying and referencing an IP. Each IP in the user's catalog must have a unique spec. The complete spec is: <code>&lt;name&gt;[:&lt;version&gt;]</code>.</p>
<h3 id="intellectual-property-ip"><a class="header" href="#intellectual-property-ip">Intellectual Property (IP)</a></h3>
<p>An IP is a project with a manifest file at its root directory. At a minimum, an IP has two attributes: a name and a version.</p>
<h3 id="lockfile"><a class="header" href="#lockfile">Lockfile</a></h3>
<p>A lockfile is a file that exactly describes an IP's dependencies. It is generated and maintained by <code>orbit</code>. The lockfile should be checked into your version control system for reproducible builds. It is not to be manually edited by the user. </p>
<p>From the lockfile, <code>orbit</code> is able to download missing dependencies, install missing dependencies, and verify the data integrity of installed dependencies.</p>
<h3 id="manifest-1"><a class="header" href="#manifest-1">Manifest</a></h3>
<p>A manifest is a file that decscribes an IP recognized by <code>orbit</code>. Manifest files 
are exactly named <code>Orbit.toml</code>. The manifest is intended to be written by the user.</p>
<h3 id="orbitlock-1"><a class="header" href="#orbitlock-1">Orbit.lock</a></h3>
<p>See <a href="glossary.html#lockfile">lockfile</a>.</p>
<h3 id="orbittoml"><a class="header" href="#orbittoml">Orbit.toml</a></h3>
<p>See <a href="glossary.html#manifest">manifest</a>.</p>
<h3 id="package"><a class="header" href="#package">Package</a></h3>
<p>See <a href="glossary.html#intellectual-property-ip">IP</a>.</p>
<h3 id="plugin"><a class="header" href="#plugin">Plugin</a></h3>
<p>A plugin is a user-defined command able to be called during the building phase. A plugin typically follows 3 steps: </p>
<ol>
<li>Parse the blueprint</li>
<li>Process the referenced files</li>
<li>Generate an output product</li>
</ol>
<p>Plugins can accept additional arguments from the command-line and define additional filesets to be collected during the planning phase. Users are encouraged to create and share their own plugins.</p>
<h3 id="profile"><a class="header" href="#profile">Profile</a></h3>
<p>A profile is a user-defined group of plugins, settings, and/or channels under a single directory. A profile does not necessarily have to have all listed aspects in order to be considered a &quot;profile&quot;.</p>
<p>Profiles are useful for quickly sharing and maintaining common development standards and workflows among a team environment.</p>
<h3 id="project"><a class="header" href="#project">Project</a></h3>
<p>A project is a collection of HDL source files and any other required files related to a specific application or library. Placing a manifest in a project makes it an IP.</p>
<h3 id="vhdl"><a class="header" href="#vhdl">VHDL</a></h3>
<p>VHSIC Hardware Design Language (VHDL) is a hardware descrption language to model the behavior of digitally electronic circuits.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
