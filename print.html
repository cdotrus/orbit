<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Book of Orbit</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <style>
            dd {
                margin-bottom: 1em;
            }
        </style>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="starting/starting.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="starting/motivation.html"><strong aria-hidden="true">1.1.</strong> Motivation</a></li><li class="chapter-item expanded "><a href="starting/installing.html"><strong aria-hidden="true">1.2.</strong> Installing</a></li><li class="chapter-item expanded "><a href="starting/upgrading.html"><strong aria-hidden="true">1.3.</strong> Upgrading</a></li></ol></li><li class="chapter-item expanded "><a href="tutorials/tutorials.html"><strong aria-hidden="true">2.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/first_project.html"><strong aria-hidden="true">2.1.</strong> First Project: Gates</a></li><li class="chapter-item expanded "><a href="tutorials/dependencies.html"><strong aria-hidden="true">2.2.</strong> Dependencies: Half adder</a></li><li class="chapter-item expanded "><a href="tutorials/gates_revisited.html"><strong aria-hidden="true">2.3.</strong> Gates: Revisited</a></li><li class="chapter-item expanded "><a href="tutorials/final_project.html"><strong aria-hidden="true">2.4.</strong> Final Project: Full adder</a></li></ol></li><li class="chapter-item expanded "><a href="user/user.html"><strong aria-hidden="true">3.</strong> User Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user/overview.html"><strong aria-hidden="true">3.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="user/managing_ip.html"><strong aria-hidden="true">3.2.</strong> Managing Ip</a></li><li class="chapter-item expanded "><a href="user/targeting_builds.html"><strong aria-hidden="true">3.3.</strong> Targeting Builds</a></li></ol></li><li class="chapter-item expanded "><a href="topic/topic.html"><strong aria-hidden="true">4.</strong> Topic Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="topic/overview.html"><strong aria-hidden="true">4.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="topic/package_management.html"><strong aria-hidden="true">4.2.</strong> Agile Package Management</a></li><li class="chapter-item expanded "><a href="topic/extensible_builds.html"><strong aria-hidden="true">4.3.</strong> Extensible Builds</a></li><li class="chapter-item expanded "><a href="topic/catalog.html"><strong aria-hidden="true">4.4.</strong> Catalog</a></li><li class="chapter-item expanded "><a href="topic/ip.html"><strong aria-hidden="true">4.5.</strong> Ip</a></li><li class="chapter-item expanded "><a href="topic/targets.html"><strong aria-hidden="true">4.6.</strong> Targets</a></li><li class="chapter-item expanded "><a href="topic/protocols.html"><strong aria-hidden="true">4.7.</strong> Protocols</a></li><li class="chapter-item expanded "><a href="topic/channels.html"><strong aria-hidden="true">4.8.</strong> Channels</a></li><li class="chapter-item expanded "><a href="topic/orbitlock.html"><strong aria-hidden="true">4.9.</strong> Orbit.lock</a></li><li class="chapter-item expanded "><a href="topic/orbitignore.html"><strong aria-hidden="true">4.10.</strong> .orbitignore</a></li><li class="chapter-item expanded "><a href="topic/swapping.html"><strong aria-hidden="true">4.11.</strong> String Swapping</a></li><li class="chapter-item expanded "><a href="topic/dst.html"><strong aria-hidden="true">4.12.</strong> Dynamic Symbol Transformation</a></li></ol></li><li class="chapter-item expanded "><a href="reference/reference.html"><strong aria-hidden="true">5.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/manifest.html"><strong aria-hidden="true">5.1.</strong> Manifest</a></li><li class="chapter-item expanded "><a href="reference/names.html"><strong aria-hidden="true">5.2.</strong> Names</a></li><li class="chapter-item expanded "><a href="reference/versions.html"><strong aria-hidden="true">5.3.</strong> Versions</a></li><li class="chapter-item expanded "><a href="reference/filesets.html"><strong aria-hidden="true">5.4.</strong> Filesets</a></li><li class="chapter-item expanded "><a href="reference/blueprint.html"><strong aria-hidden="true">5.5.</strong> Blueprint</a></li><li class="chapter-item expanded "><a href="reference/environment_variables.html"><strong aria-hidden="true">5.6.</strong> Environment Variables</a></li><li class="chapter-item expanded "><a href="reference/configuration.html"><strong aria-hidden="true">5.7.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="reference/json.html"><strong aria-hidden="true">5.8.</strong> JSON Output</a></li><li class="chapter-item expanded "><a href="reference/command_line.html"><strong aria-hidden="true">5.9.</strong> Command Line</a></li></ol></li><li class="chapter-item expanded "><a href="commands/**commands**.html"><strong aria-hidden="true">6.</strong> Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/new.html"><strong aria-hidden="true">6.1.</strong> orbit new</a></li><li class="chapter-item expanded "><a href="commands/init.html"><strong aria-hidden="true">6.2.</strong> orbit init</a></li><li class="chapter-item expanded "><a href="commands/view.html"><strong aria-hidden="true">6.3.</strong> orbit view</a></li><li class="chapter-item expanded "><a href="commands/read.html"><strong aria-hidden="true">6.4.</strong> orbit read</a></li><li class="chapter-item expanded "><a href="commands/get.html"><strong aria-hidden="true">6.5.</strong> orbit get</a></li><li class="chapter-item expanded "><a href="commands/tree.html"><strong aria-hidden="true">6.6.</strong> orbit tree</a></li><li class="chapter-item expanded "><a href="commands/lock.html"><strong aria-hidden="true">6.7.</strong> orbit lock</a></li><li class="chapter-item expanded "><a href="commands/test.html"><strong aria-hidden="true">6.8.</strong> orbit test</a></li><li class="chapter-item expanded "><a href="commands/build.html"><strong aria-hidden="true">6.9.</strong> orbit build</a></li><li class="chapter-item expanded "><a href="commands/launch.html"><strong aria-hidden="true">6.10.</strong> orbit launch</a></li><li class="chapter-item expanded "><a href="commands/search.html"><strong aria-hidden="true">6.11.</strong> orbit search</a></li><li class="chapter-item expanded "><a href="commands/download.html"><strong aria-hidden="true">6.12.</strong> orbit download</a></li><li class="chapter-item expanded "><a href="commands/install.html"><strong aria-hidden="true">6.13.</strong> orbit install</a></li><li class="chapter-item expanded "><a href="commands/env.html"><strong aria-hidden="true">6.14.</strong> orbit env</a></li><li class="chapter-item expanded "><a href="commands/config.html"><strong aria-hidden="true">6.15.</strong> orbit config</a></li><li class="chapter-item expanded "><a href="commands/remove.html"><strong aria-hidden="true">6.16.</strong> orbit remove</a></li></ol></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">7.</strong> Appendix: Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Book of Orbit</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-book-of-orbit"><a class="header" href="#the-book-of-orbit">The Book of Orbit</a></h1>
<p><img src="./images/orbit_logo_128px.png" alt="" /></p>
<p>Orbit is an agile package manager and extensible build tool for hardware description languages (HDL). Its design is driven by two core principles:</p>
<ul>
<li>minimize technical debt associated with evolving HDL codebases</li>
<li>tailor to the wide range of users and their possible workflows with a high degree of modularity and extensibility</li>
</ul>
<p>Orbit's use case is targeted toward anyone interested in developing digital hardware; this includes industrial, academic, and personal settings. Create your next commerical product, university lab assignment, or personal project, using a tool that is tailored to today's advanced development processes.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<p>This "book" is loosely divided into 4 sections:</p>
<ol>
<li><a href="./tutorials/tutorials.html">Tutorials</a> - Step-by-step lessons working with Orbit</li>
<li><a href="./user/user.html">User Guide</a> - General procedures for "how-to" solve common problems</li>
<li><a href="./topic/topic.html">Topic Guide</a> - Explanations that clarify and provide more detail to particular topics</li>
<li><a href="./reference/reference.html">Reference</a> - Technical information</li>
</ol>
<h2 id="about-the-project"><a class="header" href="#about-the-project">About the Project</a></h2>
<p>Orbit is available free to use and open source to encourage adoption, contribution, and integration among the hardware community. We rely on the open source community for feedback and new ideas, while remaining focused on our design goals and principles.</p>
<p>The project is currently open-source under the GPL-3.0 license and is available on <a href="https://github.com/cdotrus/orbit">GitHub</a>.</p>
<h2 id="about-the-documentation"><a class="header" href="#about-the-documentation">About the Documentation</a></h2>
<p>The documentation system and methodology adopted by Orbit is inspired by <a href="https://documentation.divio.com">Divio</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This section walks you the basic steps to get Orbit up and running on your local computer.</p>
<blockquote>
<h3 id="command-line-notation"><a class="header" href="#command-line-notation">Command Line Notation</a></h3>
<p>Throughout the tutorials and the rest of the book, commands will be shown that are used in the terminal. Lines that are entered in a terminal are denoted by starting with a $. The $ is just a special marker; it is not to be entered with the command. Lines that don't start with a $ are typically the output of the previous command.</p>
</blockquote>
<p>There are two processes to obtaining and maintaining Orbit:</p>
<ol>
<li><a href="starting/./installing.html">Installing</a></li>
<li><a href="starting/./upgrading.html">Upgrading</a></li>
</ol>
<h2 id="seeking-help"><a class="header" href="#seeking-help">Seeking Help</a></h2>
<p>Orbit is a package manager and development tool. With learning new tools there is always a learning curve. Orbit tries to make it less intimidating to use by offering help and information in a variety of ways:</p>
<ul>
<li>To see a list of common commands and options, just use <code>orbit</code> with no arguments.</li>
<li>To view quick summaries on commands, use <code>-h, --help</code> flags.</li>
<li>To view more detailed manual pages and information, use <code>orbit help</code>.</li>
</ul>
<p>But since you are here, complete documentation can be found on this website.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>If you work in the realm of computers, you may hear the phrase: "<em>Hardware is hard</em>." But have you ever thought about <strong>why</strong>?</p>
<p>There are many possible answers that may lead to this phrase's existence, such as hardware involves battling real-world physics, or that hardware requires knowledge across a wide range of skills, or that hardware has infinitely many ways to go wrong. However, there is one reason we choose to focus on in the context of digital hardware: <strong>a slow and expensive development cycle</strong>.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>To describe hardware today, you typically use a hardware description language (HDL). The two most promiment HDLs used and supported by electronic design automation (EDA) tools are VHDL and Verilog. HDLs are not software programing languages, but rather a language to describe how a circuit is intended to be structured or function.</p>
<p>The core similarity between describing digital hardware and writing software programs is that the developer must apply the creative process by editing files called <em>source code</em>. Source code is used as the an input to a back end process, whether it be compilation, simulation, or synthesis. Software and hardware both face encounter some similar problems when working with source code, although software already has more of their solutions.</p>
<p>Let's talk about some observations about source code development in the layer above hardware: software. Software development today not only has nice languages to develop with, but the entire ecosystem surrounding that language is a pleasant experience. Take the Rust programming language as an example. Not only does Rust have moden language constructs that forces programmers to rethink how to write their program in a safer way regarding computer memory, but the infrastructure surrounding Rust is very accessible and easy to use, which involves the compiler, code management, and code testing. This is great for software, but does the same hold true for hardware?</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The problem</a></h2>
<p>At the hardware layer, life is unfortunately not so simple. Not only are the promiment languages being used for things outside of their original intention, but the surrounding infrastructure around these languages is very lacking. Proprietary and expensive tools force developers to adapt to non-standardized practices, making it difficult to share code across systems or other tools, leading to the introduction of the concept called <em>vendor lock-in</em>. Vendor lock-in fragments the community and makes it increasingly difficult to find portable and easily usable source code. Hardware does not have as big of a footprint in the open-source world in comparison to software's vibrant open-source community.</p>
<p>Without the right infrastructure and tools to easily share, reuse, and maintain source code, hardware experiences slow and expensive development cycles. At this point, you be wondering what are the right tools and infrastructure that hardware needs? To answer this question, you may have to shift your perspective about hardware. Thinking of hardware with the waterfall approach of being <em>built and done with</em> is the wrong mindset. Hardware is rarely built once and forgotten about. Instead, one must think of hardware with a more agile approach in that it evolves and improves upon many iterations. This concept of hardware evolving over time requires special attention when creating the supportive infrastructure around it. But this infrastructure and tooling is not there for the common HDL languages such as VHDL and Verilog.</p>
<p>Without the right infrastructure and tools, many source code maintenance tasks related to development, also known as <em>technical debt</em>, become exponentially more time-consuming and increasingly difficult as time goes on and the code base grows in size and complexity. The technical debt falls upon the developer to manually handle because there is no automated systematic tool to instead handle it. Large technical debt in turn leads to the long and expensive hardware development cycles, and therefore it is a common goal to strive to minimize technical debt. The solution at this point is not to continue down the dark path ahead, but instead to take a look at how software managed to minimize this problem: package management.</p>
<h2 id="the-solution"><a class="header" href="#the-solution">The solution</a></h2>
<p>With the right tools, hardware development can experience faster development cycles and lower costs. A tool that can make this experience true is a <em>package manager</em>. A package manager's role is to organize and automate the tasks related to source code management. A well-designed package manager can minimize technical debt, while a poorly-designed package manager simply shifts the technical debt to possibly new and different tasks. Software programming languages have become increasingly good at handling source code management through the creation of their own package managers, such as go mod for Go, Cargo for Rust, and pip for Python.</p>
<blockquote>
<p>Having well-designed and easily accessible tools is important to any form of development- creativity's greatest limiting factor is the tools of which are available to turn an idea into a reality.</p>
</blockquote>
<p><em>Orbit</em> is an agile package manager for HDLs. It automates the process of organizing, maintaining, and reusing HDL source code across projects. Since it regularly interacts with the developer, it is designed to be simple and intuitive to use while highly tolerant against errors. Given the HDL landscape is fragmented and requires various EDA tools to carry out different tasks, Orbit is highly flexible- developers can setup their own targets with minimal effort to execute whatever EDA tool they prefer. Orbit operates as the intermediary between the developer's HDL source code and their EDA tools.</p>
<p>One of the major goals behind Orbit is to support the developer in shifting their perspective of hardware toward a more agile approach in being something that lives and evolves over time. By using Orbit as an HDL package manager, hardware development becomes an enjoyable experience with more of the developer's time devoted to <em>actually</em> creating cool things, not racking up technical debt and fighting to manage millions of files. After all, the saying should be "<em>Hardware is cool</em>", right?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing"><a class="header" href="#installing">Installing</a></h1>
<p>There are two main methods for getting Orbit running on your computer: downloading a precompiled binary or by using Cargo.</p>
<blockquote>
<p><strong>Reminder:</strong> By installing and using Orbit, you accept usage under its GPL-3.0 license.</p>
</blockquote>
<h2 id="1-using-a-precompiled-binary"><a class="header" href="#1-using-a-precompiled-binary">1. Using a precompiled binary</a></h2>
<ol>
<li>Visit Orbit's <a href="https://github.com/cdotrus/orbit/releases">releases</a> page on Github to find all of its official releases.</li>
<li>Download the binary for your computer's architecture and operating system.</li>
<li>Install Orbit. Either run the provided <code>install</code> executable or follow the manual instructions for placing Orbit's executable (<code>orbit</code> for Unix and <code>orbit.exe</code> for Windows) in a location recognized by the PATH environment variable.</li>
</ol>
<p>There are multiple solutions to accomplish step 3. The following outlines one way to manually install Orbit depending on the user's operating system.</p>
<h3 id="unix"><a class="header" href="#unix">Unix</a></h3>
<ol>
<li>Open a new terminal (Bash) to where Orbit was downloaded.</li>
<li>Unzip the prebuilt package.</li>
</ol>
<pre><code>$ unzip orbit-0.16.0-x86_64-macos.zip
</code></pre>
<ol start="3">
<li>Move the executable to a location already set in the PATH environment variable.</li>
</ol>
<pre><code>$ mv ./orbit-0.16.0-x86_64-macos/bin/orbit /usr/local/bin/orbit
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<ol>
<li>
<p>Open a new terminal (Powershell) to where Orbit was downloaded.</p>
</li>
<li>
<p>Unzip the prebuilt package.</p>
</li>
</ol>
<pre><code>$ expand-archive "./orbit-0.16.0-x86_64-windows.zip"
</code></pre>
<ol start="3">
<li>Make a new directory to store this package.</li>
</ol>
<pre><code>$ new-item -path "$env:LOCALAPPDATA/Programs/orbit" -itemtype directory
</code></pre>
<ol start="4">
<li>Move the package to the new directory.</li>
</ol>
<pre><code>$ copy-item "./orbit-0.16.0-x86_64-windows/*" -destination "$env:LOCALAPPDATA/Programs/orbit" -recurse
</code></pre>
<ol start="5">
<li>Edit the user-level PATH environment variable in <em><strong>Control Panel</strong></em> by adding <strong>%LOCALAPPDATA%\Programs\orbit\bin</strong>.</li>
</ol>
<h2 id="2-installing-with-cargo"><a class="header" href="#2-installing-with-cargo">2. Installing with Cargo</a></h2>
<p>To install the latest version through Cargo:</p>
<pre><code>$ cargo install --git https://github.com/cdotrus/orbit.git --tag 0.16.0
</code></pre>
<p>This will build the <code>orbit</code> binary and place it a path already set in the PATH environment variable.</p>
<h2 id="checking-if-orbit-is-installed-correctly"><a class="header" href="#checking-if-orbit-is-installed-correctly">Checking if Orbit is installed correctly</a></h2>
<p>To verify Orbit is working correctly on your system, let's open a new terminal session and print it's current version.</p>
<pre><code>$ orbit --version
</code></pre>
<pre><code>orbit 0.16.0
</code></pre>
<p>This should print out your version of Orbit you installed. Congratulations! You are now ready to begin using Orbit.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrading"><a class="header" href="#upgrading">Upgrading</a></h1>
<p>Once Orbit is installed, it can be self-upgraded to the latest official released version found on its Github repository.</p>
<pre><code>$ orbit --upgrade
</code></pre>
<p>This behavior performs the following strategy:</p>
<ol>
<li>
<p>Removes any executable in the executable's directory starting with <code>orbit-</code> (these are considered stale binaries, such as <code>orbit-0.1.0</code>).</p>
</li>
<li>
<p>Connects to <a href="https://github.com/cdotrus/orbit/releases">https://github.com/cdotrus/orbit/releases</a> to find the most recent released version.</p>
</li>
<li>
<p>Checks if the most recent version online is ahead of the currently installed version.</p>
</li>
</ol>
<blockquote>
<p><strong>Note</strong>: If the version online is newer, a prompt will appear to confirm you wish to install the new version. This prompt can be bypassed by adding the <code>--force</code> flag to the previous command.</p>
</blockquote>
<ol start="4">
<li>
<p>Downloads the checksum file to a temporary directory to see if there is a prebuilt package available for the current architecture and operating system.</p>
</li>
<li>
<p>Downloads the package to a temporary directory and computes the checksum to verify the contents.</p>
</li>
<li>
<p>Renames the current executable by appending its version to the name (marking it as a stale binary, such as <code>orbit-0.1.1</code>).</p>
</li>
<li>
<p>Unzips the package and moves the new executable to the original executable's location.</p>
</li>
</ol>
<blockquote>
<p><strong>Note</strong>: If you wish to remove the newly created stale binary after an upgrade, rerunning <code>orbit --upgrade</code> immediately again will perform step 1 and stop at step 3.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>This section provides step-by-step instructions through examples of basic ways for interacting with <code>orbit</code>.</p>
<blockquote>
<h3 id="command-line-notation-1"><a class="header" href="#command-line-notation-1">Command Line Notation</a></h3>
<p>Throughout the tutorials and the rest of the book, commands will be shown that are used in the terminal. Lines that are entered in a terminal are denoted by starting with a $. The $ is just a special marker; it is not to be entered with the command. Lines that don't start with a $ are typically the output of the previous command.</p>
</blockquote>
<p>Before starting the tutorials, it is assumed you possess basic knowledge of the following topics:</p>
<ul>
<li>sending commands through the command-line</li>
<li>digital logic concepts</li>
<li>navigating your computer's local file system</li>
</ul>
<br>
<blockquote>
<p><strong>Note:</strong> The HDL code used for this section may be very didactic in nature and is not intended to reflect production-level code or any particular coding style.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-project-gates"><a class="header" href="#first-project-gates">First Project: Gates</a></h1>
<p>In this tutorial, you will learn how to:</p>
<p><a href="tutorials/first_project.html#creating-an-ip">1.</a> Create an ip from scratch<br />
<a href="tutorials/first_project.html#integrating-design-units">2.</a> Use Orbit to integrate an entity into a larger design<br />
<a href="tutorials/first_project.html#building-an-ip-for-a-scripted-workflow">3.</a> Build a design using a simple target<br />
<a href="tutorials/first_project.html#making-an-ip-and-its-design-units-reusable">4.</a> Release a version of an ip</p>
<h2 id="creating-an-ip"><a class="header" href="#creating-an-ip">Creating an ip</a></h2>
<p>First, navigate to a directory in your file system where you would like to store the project. From there, let's issue our first <code>orbit</code> command:</p>
<pre><code>$ orbit new gates
</code></pre>
<p>A directory called "gates" should now exist and look like the following tree structure:</p>
<pre><code>gates/
├─ .orbitignore
└─ Orbit.toml
</code></pre>
<p>Let's create our first design unit for describing a NAND gate. Feel free to copy the following code into a file called "nand_gate.vhd" that exists in our project directory "/gates".</p>
<p>Filename: nand_gate.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

entity nand_gate is
  port(
    a, b : in std_logic;
    x : out std_logic
  );
end entity;

architecture rtl of nand_gate is
begin
  x &lt;= a nand b;

end architecture;
</code></pre>
<h2 id="integrating-design-units"><a class="header" href="#integrating-design-units">Integrating design units</a></h2>
<p>Consider for an instant that our HDL only supports the <code>nand</code> keyword and is missing the other logic gates such as <code>or</code>, <code>and</code>, and <code>xor</code>.</p>
<p>Recalling our basic knowledge of digital circuits, we know a NAND gate is a universal gate, so let's compose other gates using our newly created <code>nand_gate</code> entity. Create a new file for our next design unit to describe an AND gate.</p>
<p>Filename: and_gate.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

entity and_gate is
  port(
    a, b : in std_logic;
    y : out std_logic
  );
end entity;

architecture rtl of and_gate is
begin
    -- What to put here?

end architecture;
</code></pre>
<p>After some thinking, we realize we can use two NAND gates together to construct an AND gate. Let's use Orbit to help us integrate our <code>nand_gate</code> entity into the <code>and_gate</code>'s architecture.</p>
<pre><code>$ orbit get nand_gate --component --signals --instance
</code></pre>
<pre><code>component nand_gate
  port(
    a : in std_logic;
    b : in std_logic;
    x : out std_logic
  );
end component;

signal a : std_logic;
signal b : std_logic;
signal x : std_logic;

uX : nand_gate
  port map(
    a =&gt; a,
    b =&gt; b,
    x =&gt; x
  );
</code></pre>
<p>With this single command, Orbit provided us with:</p>
<ul>
<li>the component declaration</li>
<li>signals for the port interface</li>
<li>an instantiation template</li>
</ul>
<p>Sweet! After some quick copy/pasting and signal renaming, we have our architecture described for an AND gate.</p>
<p>Filename: and_gate.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

entity and_gate is
  port(
    a, b : in std_logic;
    y : out std_logic
  );
end entity;

architecture rtl of and_gate is
  
  component nand_gate
    port(
      a : in std_logic;
      b : in std_logic;
      x : out std_logic
    );
  end component;

  signal x : std_logic;

begin

  u1 : nand_gate
    port map(
      a =&gt; a,
      b =&gt; b,
      x =&gt; x
    );

  u2 : nand_gate
    port map(
      a =&gt; x,
      b =&gt; x,
      x =&gt; y
    );

end architecture;
</code></pre>
<p>Let's make a quick check to verify our <code>and_gate</code> is using our <code>nand_gate</code>.</p>
<pre><code>$ orbit tree
</code></pre>
<pre><code>and_gate
└─ nand_gate
</code></pre>
<p>Cool! We got a hierarchical view of our top-most design unit.</p>
<h2 id="building-an-ip-for-a-scripted-workflow"><a class="header" href="#building-an-ip-for-a-scripted-workflow">Building an ip for a scripted workflow</a></h2>
<p>After all of our hard work, we are excited to show off our latest design on the newest Yilinx FPGA that just arrived in the mail. You realize you need a way to get your HDL code to the Yilinx synthesis tool in order to generate the final bitstream for your FPGA.</p>
<p>To make this possible, Orbit builds a project through two stages: planning and execution. Although both stages occur together, users must define their own targets to be invoked during execution. This explicit separation of layers between planning and execution enable the user to tailor the build process to their specific requirements.</p>
<h3 id="creating-a-target"><a class="header" href="#creating-a-target">Creating a target</a></h3>
<p>A target is a command invoked by Orbit for execution during the build process. In this example, we will write a script and have our target's command call our script to execute our process. In other words, you could say we are <em>targeting</em> the Yilinx tool. Let's make a simple target for our Yilinx synthesis tool using the Python programming language.</p>
<p>Filename: .orbit/yilinx.py</p>
<pre><code class="language-python">file_order = []
# Read and parse the blueprint file
with open('blueprint.tsv') as blueprint:
    rules = blueprint.readlines()
    for r in rules:
        fileset, lib, path = r.strip().split('\t')
        if fileset == 'VHDL':
            file_order += [(lib, path)]
    pass

# Use the Yilinx tool to perform synthesize on the HDL files
for (lib, path) in file_order:
    print('YILINX:', 'Synthesizing file ' + str(path) +' into ' + str(lib) + '...')

# Use the Yilinx tool to perform placement and routing
print('YILINX:','Performing place-and-route...')

# Use the Yilinx tool to generate the bitstream
print('YILINX:', 'Generating bitstream...')
with open('fpga.bit', 'w') as bitstream:
    bitstream.write('011010101101' * 2)

print('YILINX:','Bitstream saved at: target/yilinx/fpga.bit')

</code></pre>
<p>For Orbit to know about our target, we need to give information to Orbit about the target. This is done in a configuration file. For this example, we edit the project-level configurations.</p>
<p>Filename: .orbit/config.toml</p>
<pre><code class="language-toml">[[target]]
name = "yilinx"
description = "Generate bitstreams for Yilinx FPGAs"
command = "python"
args = ["yilinx.py"]
</code></pre>
<h3 id="calling-a-target"><a class="header" href="#calling-a-target">Calling a target</a></h3>
<pre><code>$ orbit build --target yilinx
</code></pre>
<pre><code>YILINX: Synthesizing file /Users/chase/tutorials/gates/nand_gate.vhd into work...
YILINX: Synthesizing file /Users/chase/tutorials/gates/and_gate.vhd into work...
YILINX: Performing place-and-route...
YILINX: Generating bitstream...
YILINX: Bitstream saved at: target/yilinx/fpga.bit
</code></pre>
<p>Typically, we create targets to interface with EDA tools which will in turn produce desired output files, called artifacts. We see Yilinx saved our bitstream artifact for us to program our FPGA. Cool!</p>
<p>Filename: target/yilinx/fpga.bit</p>
<pre><code class="language-text">011010101101011010101101
</code></pre>
<h2 id="making-an-ip-and-its-design-units-reusable"><a class="header" href="#making-an-ip-and-its-design-units-reusable">Making an ip and its design units reusable</a></h2>
<p>Now we are ready to move on to more advanced topics, so let's go ahead and store an immutable reference to this project to use in other projects in our developer journey.</p>
<pre><code>$ orbit install
</code></pre>
<p>This command ran a series of steps that packaged our project and placed it into our <em>cache</em>. Internally, Orbit knows where our cache is and can reference designs from our cache when we request them. Let's make sure our project was properly installed by viewing our entire ip catalog.</p>
<pre><code>$ orbit search
</code></pre>
<pre><code>gates                       0.1.0     install
</code></pre>
<p>And there it is! Let's continue to the next tutorial, where we introduce dependencies across ips.</p>
<h3 id="additional-notes-on-project-structure"><a class="header" href="#additional-notes-on-project-structure">Additional notes on project structure</a></h3>
<p>Our final project structure looks like the following:</p>
<pre><code>gates/
├─ .orbit/
│  ├─ config.toml
│  └─ yilinx.py
├─ target/
│  ├─ CACHEDIR.TAG
|  └─ yilinx/
│     ├─ .env
│     ├─ blueprint.tsv
│     └─ fpga.bit
├─ Orbit.toml
├─ Orbit.lock
├─ and_gate.vhd
└─ nand_gate.vhd
</code></pre>
<ul>
<li>
<p>The configurations stored in "/.orbit" exist only for this project; to store configurations that persist across projects make changes to the $ORBIT_HOME directory.</p>
</li>
<li>
<p>Orbit creates an output directory to store the blueprint and any tool output files during a build. These files should reside in "/target" and may change often during development (probably don't check this directory into version control).</p>
</li>
<li>
<p>Orbit creates a lock file "Orbit.lock" to store all the information required to manage and recreate the exact state of this project. It is a good idea to always keep it and to not manually edit it (probably be sure to check this file into version control).</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies-half-adder"><a class="header" href="#dependencies-half-adder">Dependencies: Half adder</a></h1>
<p>In this tutorial, you will learn how to:</p>
<p><a href="tutorials/dependencies.html#referencing-external-ips">1.</a> Specify an external ip as a dependency<br />
<a href="tutorials/dependencies.html#learning-about-ips">2.</a> Use Orbit to learn more about external ips and their design units<br />
<a href="tutorials/dependencies.html#integrating-design-units-across-ips">3.</a> Leverage Orbit across ips to integrate an entity into a separate ip</p>
<h2 id="referencing-external-ips"><a class="header" href="#referencing-external-ips">Referencing external ips</a></h2>
<p>After completing the gates project from the previous tutorial ahead of schedule, you take a well deserved vacation. Now you have returned to work and are tasked with building a half adder.</p>
<p>Let's create a new project. Navigate to a directory in your file system where you would like to store the project.</p>
<pre><code>$ orbit new half-add
</code></pre>
<p>For the rest of this tutorial, we will be working relative to the project directory "/half-add" that was created by the previous command.</p>
<p>Remembering our impressive work with the gates project, we realize we can reuse some of the already designed and tested components from there. Let's make sure it's installed so that we can use it.</p>
<pre><code>$ orbit search gates
</code></pre>
<pre><code>gates                       0.1.0     install

</code></pre>
<p>Awesome! Our next step is tell Orbit that our current project, half-add, wants to use gates as a dependency.</p>
<p>Add a new entry for gates to the dependencies table in our project's manifest, Orbit.toml.</p>
<p>Filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
name = "half-add"
version = "0.1.0"

# See more keys and their definitions at https://cdotrus.github.io/orbit/reference/manifest.html

[dependencies]
gates = "0.1.0"
</code></pre>
<p>We've referenced it, now we have to use it!</p>
<h2 id="learning-about-ips"><a class="header" href="#learning-about-ips">Learning about ips</a></h2>
<p>Your memory is a little foggy on what gates actually did, and what entities were available. Luckily, we can query for information through Orbit about ips and their design units.</p>
<p>Let's remember what entities we have at our disposal.</p>
<pre><code>$ orbit view gates --units
</code></pre>
<pre><code>and_gate                            entity        public 
nand_gate                           entity        public 
</code></pre>
<p>Okay, how did we implement the NAND gate architecture?</p>
<pre><code>$ orbit read --ip gates nand_gate --start architecture
</code></pre>
<pre><code>architecture rtl of nand_gate is
begin

  x &lt;= a nand b;

end architecture;
</code></pre>
<p>Cool, we used the VHDL keyword <code>nand</code> to describe that particular circuit. Sometimes it may be insightful to read code snippets and comments from external design units when trying to integrate them into a new project.</p>
<h2 id="integrating-design-units-across-ips"><a class="header" href="#integrating-design-units-across-ips">Integrating design units across ips</a></h2>
<p>Let's use the NAND gate we previously defined to construct a half adder circuit.</p>
<pre><code>$ orbit get --ip gates nand_gate --library --signals --instance
</code></pre>
<pre><code>library work;

signal a : std_logic;
signal b : std_logic;
signal x : std_logic;

uX : entity work.nand_gate
  port map(
    a =&gt; a,
    b =&gt; b,
    x =&gt; x
  );
</code></pre>
<p>A half adder can be constructed with 5 NAND gates. It's time to copy/paste our NAND gate instances into our new file "half_add.vhd".</p>
<p>Filename: half_add.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

library work;

entity half_add is
  port(
    a, b : in std_logic;
    c, s : out std_logic
  );
end entity;

architecture rtl of half_add is
  
  signal x4, x1, x2 : std_logic;

begin

  -- 1st layer: This gate creates the first NAND intermediate output.
  u4 : entity work.nand_gate
    port map(
      a =&gt; a,
      b =&gt; b,
      x =&gt; x4
    );
  
  -- 2nd layer: Perform NAND with input 'a' and the 1st layer's output.
  u1 : entity work.nand_gate
    port map(
      a =&gt; a,
      b =&gt; x4,
      x =&gt; x1
    );

  -- 2nd layer: Perform NAND with input 'b' and the 1st layer's output.
  u2 : entity work.nand_gate
    port map(
      a =&gt; x4,
      b =&gt; b,
      x =&gt; x2
    );

  -- 3rd layer: This gate produces the final sum signal ('a' XOR 'b').
  u3 : entity work.nand_gate
    port map(
      a =&gt; x1,
      b =&gt; x2,
      x =&gt; s
    );

  -- 3rd layer: This gate produces the final carry out signal ('a' AND 'b').
  u5 : entity work.nand_gate
    port map(
      a =&gt; x4,
      b =&gt; x4,
      x =&gt; c
    );

end architecture;
</code></pre>
<p>Let's inspect the design hierarchy to make sure our circuit and its components are identified by Orbit.</p>
<pre><code>$ orbit tree --format long
</code></pre>
<pre><code>half_add (half-add:0.1.0)
└─ nand_gate (gates:0.1.0)
</code></pre>
<p>Finally, let's install this ip to the cache for future reuse as well.</p>
<pre><code>$ orbit install
</code></pre>
<p>Nice, now we have successfully reused designs across ips! However, maybe we should have designed all the logic gates in the gates ip...</p>
<h3 id="additional-notes-on-dependencies"><a class="header" href="#additional-notes-on-dependencies">Additional notes on dependencies</a></h3>
<p>Before integrating a design unit from an external ip into a separate project, it's important to first update the Orbit.toml file. This manifest file has a dependencies section, which allows you to tell Orbit which ips to bring into the current project scope. Without the ips in scope, Orbit may be unable to identify where you got a reference for a particular design unit. Orbit denotes an unknown design unit with a ? when displaying the design hierarchy.</p>
<pre><code>half_add (half-add:0.1.0)
└─ nand_gate ?
</code></pre>
<p>After introducing dependencies at the project level, it's also important to maintain an up-to-date lockfile, Orbit.lock. In most cases, Orbit will automatically generate it when it needs it, however, you as the user can also explicitly request Orbit to update the lockfile.</p>
<pre><code>$ orbit lock
</code></pre>
<p>The lockfile saves information for Orbit to use later when needing to reconstruct the state of an ip. This includes saving information about all ip dependencies, their checksums, and potential sources of retrieval. Remember, the Orbit.lock file is automatically managed by Orbit and does not require direct user editing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gates-revisited"><a class="header" href="#gates-revisited">Gates: Revisited</a></h1>
<p>In this tutorial, you will learn how to:</p>
<p><a href="tutorials/gates_revisited.html#updating-the-gates-ip">1.</a> Edit an existing ip<br />
<a href="tutorials/gates_revisited.html#extending-the-yilinx-target">2.</a> Use environment variables and command-line arguments to create more robust targets<br />
<a href="tutorials/gates_revisited.html#rereleasing-the-gates-ip">3.</a> Release the next version for an existing ip</p>
<h2 id="editing-the-gates-ip"><a class="header" href="#editing-the-gates-ip">Editing the gates ip</a></h2>
<p>It seems we left out some logic gates when we last worked on the gates project, so let's implement them now. Navigate to the directory in your file system where you currently store the gates project.</p>
<p>For the rest of this tutorial, we will be working relative to the project directory "/gates" that currently stores the gates project.</p>
<p>Let's implement the OR gate while restricting our design to only NAND gates like before.</p>
<pre><code>$ orbit get nand_gate --signals --instance
</code></pre>
<pre><code>library work;

signal a : std_logic;
signal b : std_logic;
signal x : std_logic;

uX : entity work.nand_gate
  port map(
    a =&gt; a,
    b =&gt; b,
    x =&gt; x
  );
</code></pre>
<p>An OR gate can be constructed using 3 NAND gates. Let's copy/paste our NAND gate instances into our new file "or_gate.vhd".</p>
<p>Filename: or_gate.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

library work;

entity or_gate is
  port(
    a, b : in std_logic;
    y : out std_logic
  );
end entity;

architecture rtl of or_gate is

  signal x1, x2 : std_logic;

begin
  -- 1st layer: This gate negates the first input 'a'.
  u1 : entity work.nand_gate
    port map(
      a =&gt; a,
      b =&gt; a,
      x =&gt; x1
    );

  -- 1st layer: This gate negates the second input 'b'.
  u2 : entity work.nand_gate
    port map(
      a =&gt; b,
      b =&gt; b,
      x =&gt; x2
    );
    
  -- 2nd layer: This gate produces the final output ('a' OR 'b').
  u3 : entity work.nand_gate
    port map(
      a =&gt; x1,
      b =&gt; x2,
      x =&gt; y
    );

end architecture;
</code></pre>
<p>Showing the list of possible design units for the current project should now include the OR gate entity.</p>
<pre><code>$ orbit view --units
</code></pre>
<pre><code>and_gate                            entity        public
nand_gate                           entity        public 
or_gate                             entity        public 
</code></pre>
<h2 id="extending-the-yilinx-target"><a class="header" href="#extending-the-yilinx-target">Extending the Yilinx target</a></h2>
<p>Next, we want to program our Yilinx FPGA with the OR gate design to test it on the board. However, there are some quick updates we first want to apply to the ".orbit/yilinx.py" script.</p>
<ul>
<li>We want a way to specify which I/O pins of the FPGA will be used during placement and routing</li>
<li>We want a way to specify whether to program the FPGA bitstream to SRAM storage (volatile) or flash storage (nonvolatile).</li>
</ul>
<p>After searching through Yilinx documentation for hours, you learn that the Yilinx design tool can accept .ydc files for FPGA pin assignments. Let's edit our yilinx target to collect any .ydc files our project may have during Orbit's planning step.</p>
<p>Filename: .orbit/config.toml</p>
<pre><code class="language-toml">[[target]]
name = "yilinx"
command = "python"
description = "Generate bitstreams for Yilinx FPGAs"
args = ["yilinx.py"]
# Define the type of extra file(s) to collect during planning
fileset.pinout = "*.ydc"
</code></pre>
<p>Now let's create our pin assignment file for our OR gate design.</p>
<p>Filename: pins.ydc</p>
<pre><code class="language-text">A1=a
A2=b
C7=y
</code></pre>
<p>Next, let's edit the Python script for the yilinx target to allow the Yilinx tool to use our .ydc file if we ever collect one into our blueprint file. We also want to accept command-line arguments to optionally program our FPGA using SRAM or flash storage.</p>
<p>Filename: .orbit/yilinx.py</p>
<pre><code class="language-Python">import sys, os

# Handle command-line arguments
PROG_SRAM = bool(sys.argv.count('--sram') &gt; 0)
PROG_FLASH = bool(sys.argv.count('--flash') &gt; 0)

# Get environment variables set by orbit for this particular build
BLUEPRINT = os.environ.get("ORBIT_BLUEPRINT")
OUTPUT_PATH = os.environ.get("ORBIT_OUTPUT_PATH")
TOP_LEVEL = os.environ.get("ORBIT_TOP")

synth_order = []
constraints_file = None

# Parse the blueprint file created by orbit
with open(BLUEPRINT) as blueprint:
    rules = blueprint.readlines()
    for r in rules:
        fileset, lib, path = r.strip().split('\t')
        if fileset == 'VHDL':
            synth_order += [(lib, path)]
        if fileset == 'PINOUT':
            constraints_file = path
    pass

# Run the Yilinx tool from synthesis to bistream generation
for (lib, path) in synth_order:
    print('YILINX:', 'Synthesizing file ' + str(path) + ' into ' + str(lib) + '...')

print('YILINX:','Performing place-and-route...')

# Read the Yilinx design constraints file to map pins to I/O top-level ports.
if constraints_file != None:
    with open(constraints_file, 'r') as ydc:
        mapping = [x.strip().split('=') for x in ydc.readlines()]
    for pin, port in mapping:
        print('YILINX:', 'Mapping pin ' + str(pin) + ' to port ' + str(port) + '...')
    pass

print('YILINX:', 'Generating bitstream...')

BIT_FILE = TOP_LEVEL + '.bit'
with open(BIT_FILE, 'w') as bitstream:
    for byte in [bin(b)[2:] for b in bytes(TOP_LEVEL, 'utf-8')]:
        bitstream.write(byte)

print('YILINX:','Bitstream saved at: '+ str(OUTPUT_PATH + '/' + BIT_FILE))

# Optionally allow the user to program the FPGA using flash or SRAM configuration
if PROG_FLASH == True and PROG_SRAM == False:
    print('YILINX:', 'Programming bitstream to flash...')
elif PROG_SRAM == True:
    print('YILINX:', 'Programming bitstream to SRAM...')
  
</code></pre>
<p>With all these changes, we can now go ahead and program our FPGA as we want!</p>
<p>To execute our latest changes to our Yilinx target build process, let's use <code>orbit build</code>. Recall that this command can be divided into two distinct stages: planning and execution. Planning is completed by Orbit once it generates a blueprint file. During planning, it looked at what files the target also requests under it's <code>fileset</code> TOML configuration.</p>
<pre><code>$ orbit build --target yilinx --top or_gate -- --flash
</code></pre>
<p>Let's take a look at the blueprint file Orbit created during the build process.</p>
<p>Filename: target/yilinx/blueprint.tsv</p>
<pre><code class="language-text">PINOUT	work	/Users/chase/tutorials/gates/pins.ydc
VHDL	work	/Users/chase/tutorials/gates/nand_gate.vhd
VHDL	work	/Users/chase/tutorials/gates/or_gate.vhd

</code></pre>
<p>Notice also how we passed a command-line argument <code>--flash</code>, to our target process for execution. Any arguments that are found after <code>--</code> are ignored by Orbit and sent directly to the targeted process.</p>
<p>Reviewing the output from our target's execution, we see that our FPGA was programmed successfully.</p>
<pre><code>YILINX: Synthesizing file /Users/chase/tutorials/gates/nand_gate.vhd into work...
YILINX: Synthesizing file /Users/chase/tutorials/gates/or_gate.vhd into work...
YILINX: Performing place-and-route...
YILINX: Mapping pin A1 to port a...
YILINX: Mapping pin A2 to port b...
YILINX: Mapping pin C7 to port y...
YILINX: Generating bitstream...
YILINX: Bitstream saved at: target/or_gate.bit
YILINX: Programming bitstream to flash...
</code></pre>
<p>As expected, the bitstream is also written and saved within our target's output path.</p>
<p>Filename: target/yilinx/or_gate.bit</p>
<pre><code class="language-text">1101111111001010111111100111110000111101001100101
</code></pre>
<p>Awesome! We added some pretty advanced settings to our yilinx target to make it more robust for future use. Let's configure this target to be used with any of our ongoing projects by editing the global configuration file through the command-line.</p>
<pre><code>$ orbit config --global --append include="$(orbit env ORBIT_IP_PATH)/.orbit/config.toml"
</code></pre>
<p>Now when we call Orbit from any directory, we can see our yilinx target is available to use.</p>
<pre><code>$ orbit build --list
</code></pre>
<pre><code>yilinx          Generate bitstreams for Yilinx FPGAs
</code></pre>
<h2 id="rereleasing-the-gates-ip"><a class="header" href="#rereleasing-the-gates-ip">Rereleasing the gates ip</a></h2>
<p>We made changes to the gates ip, and now we want to have the ability to use these new updates or continue using the old changes. To do this, we want to update the version number in the manifest file. Let's edit the Orbit.toml file's version field to contain version "1.0.0".</p>
<p>Filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
name = "gates"
version = "1.0.0"

# See more keys and their definitions at https://cdotrus.github.io/orbit/reference/manifest.html

[dependencies]

</code></pre>
<p>Finally, let's release version 1.0.0 for the gates ip by installing it to our cache.</p>
<pre><code>$ orbit install
</code></pre>
<p>One last look at the catalog shows the latest version of gates we have installed is indeed 1.0.0. Nice work!</p>
<pre><code>$ orbit search gates
</code></pre>
<pre><code>gates                       1.0.0     install
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-project-full-adder"><a class="header" href="#final-project-full-adder">Final Project: Full adder</a></h1>
<p>In this tutorial, you will learn how to:</p>
<p><a href="tutorials/final_project.html#specifying-multiple-dependencies-for-an-ip">1.</a> Depend on multiple ips for a single project<br />
<a href="tutorials/final_project.html#overcoming-hdl-problems-namespace-pollution">2.</a> Use Orbit to overcome namespace pollution<br />
<a href="tutorials/final_project.html#reusing-targets-that-are-globally-configured">3.</a> Build a project with a globally-configured target</p>
<h2 id="specifying-multiple-dependencies-for-an-ip"><a class="header" href="#specifying-multiple-dependencies-for-an-ip">Specifying multiple dependencies for an ip</a></h2>
<p>After the quick detour back to the gates ip, we are ready to tackle our final challenge in this mini tutorial series: the full adder. Like our previous projects, navigate to a directory in your file system where you would like to store the project.</p>
<pre><code>orbit new full-add
</code></pre>
<p>For the rest of this tutorial, we will be working relative to the project directory "/full-add" that currently stores our new full-add project.</p>
<p>For this final project, we will need circuits described in both the gate ip and half-add ip. Let's quickly recall if version 1.0.0 of gates has the OR gate we will need.</p>
<pre><code>$ orbit view gates:1.0.0 --units
</code></pre>
<pre><code>and_gate                            entity        public 
nand_gate                           entity        public 
or_gate                             entity        public 
</code></pre>
<p>Yup! It's there, and we know we will need some half adders as well. Let's add both ips to our manifest file.</p>
<p>filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
name = "full-add"
version = "0.1.0"

# See more keys and their definitions at https://cdotrus.github.io/orbit/reference/manifest.html

[dependencies]
gates = "1.0.0"
half-add = "0.1.0"

</code></pre>
<p>Okay, time to start coding!</p>
<h2 id="overcoming-hdl-problems-namespace-pollution"><a class="header" href="#overcoming-hdl-problems-namespace-pollution">Overcoming HDL problems: Namespace pollution</a></h2>
<p>Our full adder circuit will be constructed of 2 half adders and an OR gate. Let's collect some HDL code snippets to use for our full adder circuit.</p>
<pre><code>$ orbit get half_add --ip half-add --library --instance
</code></pre>
<pre><code>library work;

uX : entity work.half_add
  port map(
    a =&gt; a,
    b =&gt; b,
    c =&gt; c,
    s =&gt; s
  );
</code></pre>
<p>And let's get the code snippet for the OR gate as well.</p>
<pre><code>$ orbit get or_gate --ip gates:1.0.0 --library --instance
</code></pre>
<pre><code>library work;

uX : entity work.or_gate
  port map(
    a =&gt; a,
    b =&gt; b,
    y =&gt; y
  );
</code></pre>
<p>Let's combine these circuits together into our new file for our full adder implementation.</p>
<p>Filename: full_add.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

library work;

entity full_add is
  port(
    a, b, cin : in std_logic;
    cout, s : out std_logic
  );
end entity;

architecture rtl of full_add is
  
  signal c_ha0, s_ha0, c_ha1 : std_logic;

begin

  -- 1st layer: Peform half of the addition operation.
  u_ha0 : entity work.half_add
    port map(
      a =&gt; a,
      b =&gt; b,
      c =&gt; c_ha0,
      s =&gt; s_ha0
    );

  -- 2nd layer: Compute the final sum term.
  u_ha1 : entity work.half_add
    port map(
      a =&gt; s_ha0,
      b =&gt; cin,
      c =&gt; c_ha1,
      s =&gt; s
    );

  -- 3rd layer: Check both c terms from the half adders for the final cout term.
  u_or0 : entity work.or_gate
    port map(
      a =&gt; c_ha0,
      b =&gt; c_ha1,
      y =&gt; cout
    );

end architecture;
</code></pre>
<p>Our design heirarchy is getting more complex; we have full adders constructed of half adders and OR gates, half adders constructed of NAND gates, OR gates constructed of... uh-oh. More NAND gates.</p>
<p>The NAND gate design unit used in the OR gates is different from NAND gates used in the half adders because they reside in different versions of the gates ip (essentially different ips). So did we just define an NAND gate entity twice with the same identifier? Yes, and thanks to Orbit, this situation is okay.</p>
<h3 id="huh"><a class="header" href="#huh">Huh?</a></h3>
<p>Typical EDA tools will complain and error out when primary design units share the same name. How would they know which one is being used where? Fortunately, Orbit is one step ahead of these tools due to implementing an algorithm called <em>dynamic symbol transformation</em>.</p>
<p>Let's take a look at the design tree hierarchy. You may notice something interesting.</p>
<pre><code>$ orbit tree --format long
</code></pre>
<pre><code>full_add (full-add:0.1.0)
├─ or_gate (gates:1.0.0)
│  └─ nand_gate (gates:1.0.0)
└─ half_add (half-add:0.1.0)
   └─ nand_gate_56ade36a78 (gates:0.1.0)
</code></pre>
<p>The entities from gates version 0.1.0 and version 1.0.0 are allowed to co-exist in this design. To circumvent EDA tool problems during builds, Orbit appends the beginning checksum digits from the ip of the unit in conflict to the design unit's identifier. Any design units that referenced the unit in conflict will also be updated to properly reference the new identifier for the unit in conflict.</p>
<p>To us though, these slight identifier renamings remain hidden because they occur among indirect dependencies in relation to our current project. When deciding which design unit to rename, Orbit will always choose to rename the unit that is used as an indirect dependency. This key choice allows us to keep using the original unit name when integrating design units into the current project.</p>
<h3 id="okay-so-what"><a class="header" href="#okay-so-what">Okay, so what?</a></h3>
<p>This may be a silly example, but there is a key takeaway here. Designs are constantly evolving. When creating the latest module, you never know what will come next. By allowing the state of a design to live on while also providing support for new growth, a user no longer spends their time trying to manage compatibility among the increasingly interconnected dependencies. Instead, there exists a freedom to continue to innovate.</p>
<h2 id="reusing-targets-that-are-globally-configured"><a class="header" href="#reusing-targets-that-are-globally-configured">Reusing targets that are globally-configured</a></h2>
<p>To conclude this mini tutorial series, let's generate a bitstream for the Yilinx FPGA with our full adder implementation.</p>
<p>First, let's verify our yilinx target is available to us after appending it to our global configuration file in the previous tutorial.</p>
<pre><code>$ orbit build --list
</code></pre>
<pre><code>yilinx          Generate bitstreams for Yilinx FPGAs
</code></pre>
<p>We can review more details about a particular target by specifying it with the "--target" command-line option while providing "--list" as well.</p>
<pre><code>$ orbit build --list --target yilinx
</code></pre>
<pre><code>Name:    yilinx
Command: python "yilinx.py" 
Root:    /Users/chase/tutorials/gates/.orbit
Filesets:
    PIN-FILE        **/*.ydc

Generate bitstreams for Yilinx FPGAs
</code></pre>
<p>Let's build our current project using the yilinx target for our full adder.</p>
<pre><code>$ orbit build --target yilinx --top full_add
</code></pre>
<p>Opening the blueprint file created by Orbit during the planning stage shows we are indeed using different files for the different NAND gate design units, and the files are in a topologically-sorted order.</p>
<p>Filename: target/yilinx/blueprint.tsv</p>
<pre><code class="language-text">VHDL	work	/Users/chase/.orbit/cache/gates-0.1.0-fe9ec9d99e/nand_gate.vhd
VHDL	work	/Users/chase/.orbit/cache/half-add-0.1.0-1c537df196/half_add.vhd
VHDL	work	/Users/chase/.orbit/cache/gates-1.0.0-4cb065a539/nand_gate.vhd
VHDL	work	/Users/chase/.orbit/cache/gates-1.0.0-4cb065a539/or_gate.vhd
VHDL	work	/Users/chase/tutorials/full-add/full_add.vhd

</code></pre>
<p>Inspecting the output displayed to the console shows our target executed it's process successfully with the creation of a .bit file.</p>
<pre><code>YILINX: Synthesizing file /Users/chase/.orbit/cache/gates-0.1.0-fe9ec9d99e/nand_gate.vhd into work...
YILINX: Synthesizing file /Users/chase/.orbit/cache/half-add-0.1.0-1c537df196/half_add.vhd into work...
YILINX: Synthesizing file /Users/chase/.orbit/cache/gates-1.0.0-4cb065a539/nand_gate.vhd into work...
YILINX: Synthesizing file /Users/chase/.orbit/cache/gates-1.0.0-4cb065a539/or_gate.vhd into work...
YILINX: Synthesizing file /Users/chase/tutorials/full-add/full_add.vhd into work...
YILINX: Performing place-and-route...
YILINX: Generating bitstream...
YILINX: Bitstream saved at: target/yilinx/full_add.bit
</code></pre>
<p>Great work! This marks the end to this tutorial series, but the beginning of your experience with Orbit, an agile package manager and extensible build tool for HDLs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-guide"><a class="header" href="#user-guide">User Guide</a></h1>
<p>This section provides general solutions to common questions when working with <code>orbit</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Users interact with Orbit by issuing commands through the command-line interface.</p>
<p>The following illustrates an example development workflow that identifies where some Orbit commands could be used during an ip's development cycle:</p>
<p><img src="user/./../images/workflow.svg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-ip"><a class="header" href="#managing-ip">Managing Ip</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="targeting-builds"><a class="header" href="#targeting-builds">Targeting Builds</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topic-guide"><a class="header" href="#topic-guide">Topic Guide</a></h1>
<p>This section provides explanations and clarity to the various systems operated by <code>orbit</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>Orbit is an agile package manager and extensible build tool for HDLs.</p>
<p><img src="topic/./../images/architecture.svg" alt="" /></p>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key concepts</a></h2>
<ul>
<li>
<p>Orbit manages your ips using a group of file system directories that together make up the <strong>Catalog</strong>. The catalog has 3 levels that store increasingly more information about a particular ip: <strong>Channels</strong>, the <strong>Archive</strong>, and the <strong>Cache</strong>.</p>
</li>
<li>
<p>An ip's manifest may be stored in a user-defined channel so that a user can find that ip. Running <code>orbit download</code> will download the ip from its defined source found in its channel and create a compressed snapshot of the ip in the archive.</p>
</li>
<li>
<p>A compressed snapshot of an ip is not enough for Orbit to reference it in a local ip. Running <code>orbit install</code> will decompress the archived snapshot stored in the archive into an immutable reference of the ip in the cache. The usage of checksums prevents users from editing ips in the cache.</p>
</li>
<li>
<p>Every ip requires a <strong>Manifest</strong> file, named <code>Orbit.toml</code>. This is a simple TOML file maintained by the user. The manifest file documents basic metadata about the ip, like its name and version, as well as the ip's list of direct dependencies.</p>
</li>
<li>
<p>An ip saves its world state by storing a <strong>Lockfile</strong>, called <code>Orbit.lock</code>, alongside the manifest. A lockfile lists all of the resolved ip dependencies required for the local ip and how to retrieve those ips if necessary again. Running <code>orbit lock</code> will build an ip-level graph to resolve the entire ip-level dependency tree and store this information in the lockfile.</p>
</li>
<li>
<p>Although not explicitly tracked by Orbit, a <strong>Profile</strong> is a collection of <strong>Targets</strong>, <strong>Settings</strong>, and <strong>Protocols</strong>. All of these items are defined in an Orbit configuration file, called <code>config.toml</code>. Structuring your configurations with <strong>Profiles</strong> allows users to reuse and share their workflows across ips.</p>
</li>
<li>
<p>To build (or test) a design within a local ip, Orbit runs a <strong>Build Process</strong>. The build process takes as input the local ip's <strong>Lockfile</strong>, <strong>Source Files</strong> (hdl code), <strong>Auxiliary Files</strong> (any other file types needed), and a specified <strong>Target</strong>. Running <code>orbit build</code> (or <code>orbit test</code>) will enter the build process.</p>
</li>
<li>
<p>The build process occurs in 2 stages: the <strong>Planning Stage</strong> and the <strong>Execution Stage</strong>. During the planning stage, Orbit generates a <strong>Blueprint</strong>, which is a single file that lists all the files required to perform the build. During the execution stage, Orbit calls the specified <strong>Target</strong>'s commmand, which typically reads the previously generated blueprint and processes the files using some user-defined EDA tool. The final output from the build process is typically one or more <strong>Artifacts</strong>, which are one or more files generated from the user-defined EDA tool.</p>
</li>
<li>
<p>Launching a new version of an ip when it is ready by releasing it through a user-defined channel can help other users seamlessly access that new version of the ip. Running <code>orbit launch</code> will run a series of checks and the copy the ip's manifest to its specified channel.</p>
</li>
</ul>
<h2 id="other-notes"><a class="header" href="#other-notes">Other notes</a></h2>
<ul>
<li>
<p>Backend EDA tools and workflows (makefiles, TCL scripts, etc.) are decoupled from ip and are able to be reused across projects by creating targets in the configuration file (<code>config.toml</code>).</p>
</li>
<li>
<p>Orbit does not require a version control system (VCS). Orbit is intended to work with any VCS (git, mercurial, svn, etc.).</p>
</li>
<li>
<p>Orbit solves the namespace collision problem by a variant of name mangling when primary design unit identifiers conflict in the dependency tree (<em>dynamic symbol transformation</em>).</p>
</li>
<li>
<p>Orbit generates a lockfile (<code>Orbit.lock</code>) during the planning stage of the build process. The lockfile saves the entire state such that Orbit can return to this state at a later time or on a different computing system. All necessary data that is required to reproduce the build is stored in the lockfile. The lockfile is maintained by Orbit and should be checked into versionc control.</p>
</li>
<li>
<p>Orbit generates a blueprint during the planning stage of the build process. The blueprint is a single file that lists the HDL source code files required for the particular build in topologically sorted order. Targets can also specify other file types to be collected into the blueprint. The blueprint is an artifact to be consumed by the target's process during the exection stage of the build process. Since it can frequently change with each build, it should not be checked into version control.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="agile-package-management"><a class="header" href="#agile-package-management">Agile Package Management</a></h1>
<p>Orbit is an agile package manager for HDLs. Orbit supports a wide range of commands to the user to automate codebase management processes for installing ip, referencing ip, and removing ip.</p>
<h2 id="installing-1"><a class="header" href="#installing-1">Installing</a></h2>
<p><code>orbit download</code> <code>orbit install</code></p>
<p>Before you can reference an ip in your current project, you must first make sure the ip exists on your local filesystem. Orbit manages ip through its <em>ip catalog</em>. The catalog consists of multiple file paths that Orbit maintains for ips at varying states of accessibility.</p>
<p>To make an ip accessible by another project, it must first be installed to your ip catalog.</p>
<h2 id="referencing"><a class="header" href="#referencing">Referencing</a></h2>
<p><code>orbit view</code>, <code>orbit get</code></p>
<p>Once an ip is installed to your ip catalog, the design units of that ip are available to be referenced in the current design.</p>
<ol>
<li>
<p>Tell Orbit which installed ip you wish to use by providing the name and version under the <code>[dependencies]</code> table in the Orbit.toml file.</p>
</li>
<li>
<p>Instantiate one of the available design units from the dependency in your source code. At this point, any build that uses this HDL source code will be correctly sorted during the planning stage in topological order.</p>
</li>
</ol>
<h2 id="removing"><a class="header" href="#removing">Removing</a></h2>
<p><code>orbit remove</code></p>
<p>An ip can be removed from the catalog when it is no longer supported or needed to be used again. By removing the ip, Orbit deletes the ip's contents stored in the catalog, effectively forgetting that it existed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensible-builds"><a class="header" href="#extensible-builds">Extensible Builds</a></h1>
<p>Orbit is an extensible build tool for HDLs. Orbit separates the build process into two stages: planning and execution. When the build process happens, both stages are operated together in sequential order. Orbit provides two entry points into the build process: <code>orbit test</code> and <code>orbit build</code>.</p>
<p>What makes Orbit extensible? Well, Orbit does not define the execution stage by default. It leaves it upon the user to add their own execution processes, called <em>targets</em>. A target can be added through modifying an Orbit configuration file.</p>
<p>Orbit leaves the execution stage undefined by default because there are a wide range of different backend EDA tools available that enforce different requirements and even change requirements and behaviors across versions. It would be a nightmare to try to design a "one-script-fits-all" approach because everyone's computing system and choice of tool is so diverse.</p>
<h2 id="test-or-build"><a class="header" href="#test-or-build">Test or build?</a></h2>
<p>Orbit provides two entry points into the build process: <code>orbit test</code> and <code>orbit build</code>. Each entry point is suited for a particular type of build process.</p>
<p>If you are trying to run a simulation (accompanied by an HDL testbench), then you should use the <code>orbit test</code> entry. This command allows you to enter the build process by specifying the testbench using <code>--tb &lt;unit&gt;</code> and its design-under-test using <code>--dut &lt;unit&gt;</code>. This entry is typically used for verification workflows, where the end result of the build process is more concerned about making sure all steps in the process complete successfully with no errors.</p>
<p>For any non-testing workflow (one that lacks an HDL testbench), then you should use the <code>orbit build</code> entry. This command allows you to enter the build process by specifying the top level using <code>--top &lt;unit&gt;</code>. This entry is typically used for any workflow where the end result of the build process is more concerned about producing output files (commonly called artifacts), such as a bitstream or synthesis report.</p>
<h2 id="planning"><a class="header" href="#planning">Planning</a></h2>
<p>During the planning stage, Orbit resolves all source code dependencies to generate a single file that lists all the necessary source files in topologically sorted order. This file that stores the ordered list of source file paths is called the <em>blueprint</em>.</p>
<p>Orbit sets runtime environment variables that can be accessed during the execution stage by the specified target.</p>
<h2 id="execution"><a class="header" href="#execution">Execution</a></h2>
<p>The execution stage occurs after the planning stage. During the execution stage, Orbit invokes the specified target's command with its set of determined arguments. The arguments to include are taken from the predefined list in the configuration file as well as any additional arguments found on the command line that appear after an empty double switch (<code>--</code>).</p>
<p>Typically, the target's process involves reading the blueprint previously generated from the planning stage and performing some task to generate an <em>artifact</em>. An artifact is what the build produces at the end of its execution, which may be anything, from a synthesis report to a bitstream file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalog"><a class="header" href="#catalog">Catalog</a></h1>
<p>As a package manager, Orbit must know what ips are available and where ips are stored on your local file system so that they can be operated on. Orbit stores your ips in the <em>catalog</em>. The <em>catalog</em> is a set of directories on your local file system maintained by orbit. These directories are typically hidden from the user because they are not regularly interfacing with the file system contents at these locations and manually tampering the contents may cause trouble for Orbit when it tries to use them.</p>
<p>There are three levels to the catalog: the cache, the archive, and channels.</p>
<h2 id="cache"><a class="header" href="#cache">Cache</a></h2>
<p>The <em>cache</em> maintains the ips that are currently <em>installed</em> on your local file system. Installed ips can be immediately added as a dependency to your current project.</p>
<p>Default location: <code>$ORBIT_HOME/cache</code></p>
<h2 id="archive"><a class="header" href="#archive">Archive</a></h2>
<p>The <em>archive</em> maintains the ips that are currently <em>downloaded</em> on your local file system. Downloaded ips can be added as a dependency to your current project only after being installed to the cache.</p>
<p>Default location: <code>$ORBIT_HOME/archive</code></p>
<h2 id="channels"><a class="header" href="#channels">Channels</a></h2>
<p><em>Channels</em> are user-defined directories to set up as registries to maintain the ips that are currently <em>available</em> to download or install. These ips may require internet to download their contents and then install to your cache.</p>
<p>Default location: <code>$ORBIT_HOME/channels</code></p>
<p>Adding a new channel is as simple as adding a directory to the location where channels are defined.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ip"><a class="header" href="#ip">Ip</a></h1>
<p>Ips are the core component that Orbit operates on as a package manager. First, let's understand some key terms related to ip in the context of Orbit.</p>
<h2 id="anatomy-of-an-ip"><a class="header" href="#anatomy-of-an-ip">Anatomy of an ip</a></h2>
<p>A developer's tasks often involve interfacing with a collection of closely related files (source code, scripts, text files). This collection of closely related files is typically stored under a single directory and is called a <em>project</em>.</p>
<p>The core operations of a package manager revolve around <em>packages</em>. A <em>package</em> is a project <em>with additional information provided by the developer</em>. This "additional information" is called <em>metadata</em>, and it is written to a special file called a <em>manifest</em>. The manifest must be placed at the project's root directory. Without a manifests, a package manager would not know which projects it should manage and what each project's current state is in relation to being a package.</p>
<p>In the context of being a package manager for digital hardware, Orbit calls a package an <em>ip</em>. An ip's manifest file is "Orbit.toml", with case-sensitivity.</p>
<h2 id="working-ip"><a class="header" href="#working-ip">Working ip</a></h2>
<p>Typically, developers work on one project at a given time (while we can work on projects concurrently, we unfortunately are not parallel processors...yet). The <em>working ip</em> is the ip that is currently being developed at a given moment. The working ip is found by Orbit by checking along the working directory and its parent directories. Some Orbit commands only work when they are called within the working ip (<code>orbit lock</code>, <code>orbit build</code>).</p>
<h2 id="types-of-files-inside-an-ip"><a class="header" href="#types-of-files-inside-an-ip">Types of files inside an ip</a></h2>
<p>Since Orbit focuses on digital hardware projects, it automatically detects and manages files that store HDL source code. Files that store HDL source code are called <em>source files</em>. Any other files, such as scripts and test vectors, are considered <em>auxiliary files</em>.</p>
<p>Auxiliary files can be injected into the planning stage by specifying <em>filesets</em> for the given target. A <em>fileset</em> is glob-style pattern that collects matching files under a common name within the working ip. These matched files will appear in the target's generated blueprint file for future execution.</p>
<p>So, what files are inside an ip?</p>
<ul>
<li><em>Source files</em>: Stores HDL source code (VHDL, Verilog)</li>
<li><em>Auxiliary files</em>: Any additional files that do not store source code</li>
<li><em>Manifest file</em> (<code>Orbit.toml</code>): Stores the ip's metadata provided by the user</li>
<li><em>Lock file</em> (<code>Orbit.lock</code>): Saves the ip's world state for reproducibility purposes</li>
<li><em>Ignore file</em> (<code>.orbitignore</code>): Stores a list of file patterns that Orbit uses to ignore matching file paths during file discovery</li>
</ul>
<p>All files <strong>except the lock file</strong> are expected to be edited by the user. Orbit automatically maintains the lock file to ensure it can reproduce the ip's world state in the future.</p>
<h3 id="reserved-names"><a class="header" href="#reserved-names">Reserved names</a></h3>
<p>File names that begin with ".orbit-" are reserved for internal use and are not allowed at the root directory of an ip. Files that are named with this pattern are used by Orbit in the ip catalog to store additional metadata about the ip.</p>
<h2 id="ip-names"><a class="header" href="#ip-names">Ip names</a></h2>
<p>An ip's name is a human-readable name given to an ip so users can easily recall and locate relevant packages.</p>
<pre><code>gates
</code></pre>
<p>An ip's <em>specification</em>, more commonly called a <em>spec</em>, is the full resolved name of an ip. As of now, the spec involves the ip's name and ip's version separated by a <code>:</code> character.</p>
<pre><code>gates:1.0.0
</code></pre>
<p>When asking Orbit to operate on a particular ip outside of the working ip, Orbit will usually ask you to provide the ip's spec. Orbit uses the spec to lookup the ip in the catalog and then continues operation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="targets"><a class="header" href="#targets">Targets</a></h1>
<p>Orbit operates at the <em>front end</em> of hardware development. At the <em>back end</em> of hardware development is where the true "processing" occurs. A particular "process" that occurs in the back end and produces some result is called a <em>target</em>.</p>
<p>Orbit has no built-in targets. Since hardware development varies widely in the tools available, the systems on which it happens, and the processes that occur, Orbit has not built-in targets. This design choice gives users flexibility in configuring the types of workflows that are most important to them.</p>
<p>At the <em>front end</em>, Orbit frequently interacts with the user to handle operations and run processes within their hardware development workflow. The main role of Orbit is to organize, reference, and prepare HDL source code for the <em>back end</em>.</p>
<p>Targets typically take in as input the <em>blueprint</em>, which is the final output file from Orbit that has prepared the list of HDL files for input to the back end.</p>
<h2 id="defining-targets"><a class="header" href="#defining-targets">Defining Targets</a></h2>
<p>Users can setup a target in the configuration file <code>config.toml</code>. For all the available parameters to define a target, see <a href="topic/./../reference/configuration.html#the-target-array">[[target]]</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocols"><a class="header" href="#protocols">Protocols</a></h1>
<p>A <em>protocol</em> is a series of steps requried to get a package from the internet. Protocols exist because there are numerous ways to access data from the internet depending on your development environment. Orbit tries to be as modular and flexible as possible by introducing protocols.</p>
<p>Protocols are required during the download process to acquire a package for potential cache installation.</p>
<h2 id="default-protocol"><a class="header" href="#default-protocol">Default protocol</a></h2>
<p>Orbit has a default protocol that relies on the Rust <a href="https://crates.io/crates/curl"><code>curl</code></a> crate to make HTTP requests. This protocol assumes the provided URLs point to a zip archive containing the targeted package. The protocol will extract the zip file to the <em>queue</em>, which is a special temporary directory handled by Orbit. Orbit generates and manages a different queue directory for each package that must be downloaded.</p>
<h3 id="using-the-default-protocol"><a class="header" href="#using-the-default-protocol">Using the default protocol</a></h3>
<p>To use the default protocol, modify the desired project's manifest to only specify the URL as the source. The default protocol assumes the URL points to a publicly accessible zip archive.</p>
<p>Filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
name = "orbit"
version = "1.0.0"
source = "https://github.com/cdotrus/orbit/archive/refs/tags/1.0.0.zip"
# ...
</code></pre>
<h2 id="custom-protocols"><a class="header" href="#custom-protocols">Custom protocols</a></h2>
<p>A user can define a custom protocol for accessing packages from the internet by modifying the configuration file.</p>
<p>Orbit sets the current directory for the custom protocol execution to already be the queue directory.
This means when a custom protocol is executed, whatever files it downloads and extracts to the current directory is the directory Orbit expects to find the IP.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>One possible protocol relies on using the <code>git</code> command-line tool.</p>
<p>Filename: config.toml</p>
<pre><code class="language-toml">[[protocol]]
name = "gitit"
summary = "Access packages through git to handle remote repositories"
command = "git"
args = ["clone", "-b", "{{ orbit.ip.version }}", "{{ orbit.ip.source.url }}"]
</code></pre>
<p>This protocol calls <code>git</code> and clones from the IP's URL while checking out the branch/tag that matches the IP's version number. These values are resolved at runtime by Orbit through variable substitution.</p>
<p>More complex protocols may require using a scripting language such as Python to perform the necessary steps.</p>
<h3 id="using-a-custom-protocol"><a class="header" href="#using-a-custom-protocol">Using a custom protocol</a></h3>
<p>To use a custom protocol, modify the desired project's manifest file to specify the URL as well as the defined protocol's name. It is each user of the package's responsibility to ensure the necessary protocol(s) are properly configured in their settings.</p>
<p>Filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
name = "orbit"
version = "1.0.0"
source = { url = "https://github.com/cdotrus/orbit.git", protocol = "gitit" }
# ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channels-1"><a class="header" href="#channels-1">Channels</a></h1>
<p>As your codebase evolves over time, you may have accrued a lot of ips. However, an issue arises regarding <em>discovery</em>- how do others quickly find all ips that have been released?</p>
<p>Orbit solves this problem by using channels. A <em>channel</em> is a decentralized registry that agglomerates ip metadata into a single location. With this approach, users only need to specify channels to discover the wide variety of released ips.</p>
<p>Channels can be as manual or automated as you prefer. You can configure commands to run for a channel's synchronization sequence, pre-launch sequence, and post-launch sequence. Channels are encouraged to be as automated as possible by defining these fields the channel's configuration.</p>
<h2 id="adding-a-new-ip-to-a-channel"><a class="header" href="#adding-a-new-ip-to-a-channel">Adding a new ip to a channel</a></h2>
<p>Orbit automates the process of adding an ip to a channel with <code>orbit launch</code>.</p>
<p>The ip's manifest data gets placed in the channel by using the following pattern:</p>
<pre><code>{{orbit.ip.char}}/{{orbit.ip.name}}-{{orbit.ip.version}}-{{orbit.ip.uuid}}.toml
</code></pre>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><code class="language-toml">[[channel]]
name = "hyperspace-labs"
description = "Available ip from hyperspace labs"
root = "." # Optional, default is "."

# If the channel is stored on the internet, synchronize with its remote location
sync.command = "git"
sync.args = ["pull"]

# Issue this command immediately before adding the ip to the channel
pre.command = "git"
pre.args = ["pull"]

# Issue this command immediately after adding the ip to the channel
post.command = "python"
post.args = ["publish.py"]

# Enable Orbit to discover ips from this channel
allow-read = true
# Enable Orbit to add new ips to this channel
allow-write = true

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbitlock"><a class="header" href="#orbitlock">Orbit.lock</a></h1>
<p>A <em>Orbit.lock</em> is a special file automatically created and updated by Orbit. It is not intended to be manually edited. Orbit writes this file every time it needs to prepare for a target's execution (<code>orbit build</code>). The purpose of the lock file is store the information necessary to reproduce the world state around the working ip. Ideally, if a project has a lock file, then the project can be planned again in the same way (and therefore rebuilt in the same way) on any machine. This is highly beneficial when collaboratively working on a project and across different systems because it enables build artifacts and results to be reproduced independent of the system it is available on.</p>
<p>Orbit uses the lock file when it determines the working ip's <code>Orbit.toml</code> manifest data matches with the lock file entry written for the current ip. When this comparison is true, it signals that there has been no change to the state of the system. Any change to <code>Orbit.toml</code> may result in an updated <code>Orbit.lock</code> file.</p>
<p>It is recommended to check in the lock file to version control to ensure the project can be rebuilt on other machines when the repository is cloned.</p>
<blockquote>
<p><strong>Note:</strong> An ip will only read its own lock file and not the lock file of any of its dependencies when needing data to reproduce a build.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbitignore"><a class="header" href="#orbitignore">.orbitignore</a></h1>
<p>A <em>.orbitignore</em> is a file that lists user-defined file patterns for Orbit to ignore during file discovery. Orbit recognizes .orbitignore files that match ".orbitignore" with case-sensitivity.</p>
<p>.orbitignore files are typically encouraged to be checked into version control.</p>
<h2 id="format"><a class="header" href="#format">Format</a></h2>
<p>.orbitignore files follow the same syntax as .gitignore files. See the pattern format for more information:</p>
<ul>
<li><a href="https://git-scm.com/docs/gitignore#_pattern_format">.gitignore pattern format</a></li>
</ul>
<h2 id="resolving-errors"><a class="header" href="#resolving-errors">Resolving errors</a></h2>
<p>Orbit prevents duplicate primary design units to be identified within certain situations. For example, duplicate design unit names are not allowed within the same project because Orbit cannot resolve ambiguity in which unit is used where.</p>
<p>An error may look like the following:</p>
<pre><code>error: duplicate primary design units identified as "foo"

location 1: rtl/foo1.vhd:20:1
location 2: rtl/foo2.vhd:1:1

hint: resolve this error by either
    1) renaming one of the units to a unique identifier
    2) adding one of the file paths to a .orbitignore file
</code></pre>
<p>A .orbitignore file can be used in this scenario to tell Orbit to ignore reading a particular file during HDL source code dependency resolution.</p>
<p>Filename: .orbitignore</p>
<pre><code>rtl/foo2.vhd

</code></pre>
<p>This example .orbitignore will resolve the previous error because it prevents Orbit from seeing the file "rtl/foo2.vhd" during any file discovery operations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-swapping"><a class="header" href="#string-swapping">String Swapping</a></h1>
<p><em>String swapping</em> is the process of injecting runtime information into specific locations of strings.</p>
<p>This process allows permissible strings to become generic enough to avoid having the user frequently update them with redundant information or accidently recall the incorrect value.</p>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<p>String swap works with key-value pairs. When Orbit sees the correct syntax indicating a known key, it will replace the key's contents with its value in its location within the string.</p>
<p>To have a key substituted with its value, use double opening curly brackets <code>{{</code> to denote the beginning of a key and double closing curly brackets <code>}}</code> to end the key. Whitespace is ignored around the  key within the curly bracket sequences.</p>
<p>When Orbit gets a permissible string, it will parse the characters to check if a key exists and should be swapped with its value. If it finds a valid known key, then it replaces everything from and within the curly bracket sequences with the variable's value. If it cannot find a valid key that matches the name, it leaves that sequence of the string unmodified.</p>
<h2 id="permissible-strings"><a class="header" href="#permissible-strings">Permissible strings</a></h2>
<p>Not every string is checked for string swapping. Strings that are not allowed to have string swapping ignore any existing keys in the text, leaving the entire string unmodified.</p>
<p>The following lists the instances when a string is permitted to perform string swapping:</p>
<h3 id="manifest-files"><a class="header" href="#manifest-files">Manifest files</a></h3>
<p>The string pattern for an ip's <code>source.url</code> field is allowed to contain any of the following keys:</p>
<ul>
<li><code>orbit.ip.name</code>: The name of the ip being downloaded.</li>
<li><code>orbit.ip.version</code>: The version of the ip being downloaded.</li>
</ul>
<h3 id="fileset-patterns"><a class="header" href="#fileset-patterns">Fileset patterns</a></h3>
<p>The string pattern for a target's fileset configuration is allowed to contain any of the following keys:</p>
<ul>
<li><code>orbit.top</code>: The top-level design unit name.</li>
<li><code>orbit.bench</code>: The testbench design unit name.</li>
<li><code>orbit.dut</code>: The design-under-test design unit name.</li>
<li><code>orbit.env.*</code>: Any environment variables loaded from configuration files.</li>
</ul>
<h3 id="protocol-arguments"><a class="header" href="#protocol-arguments">Protocol arguments</a></h3>
<p>The argument list defined in a protocol's configuration is allowed to contain any of the following keys:</p>
<ul>
<li><code>orbit.queue</code>: The directory that Orbit expects the ip temporarily placed immediately after download.</li>
<li><code>orbit.ip.name</code>: The name of the ip being downloaded.</li>
<li><code>orbit.ip.version</code>: The version of the ip being downloaded.</li>
<li><code>orbit.ip.source.url</code>: The URL for the ip being downloaded.</li>
<li><code>orbit.ip.source.protocol</code>: The protocol specified by the ip being downloaded</li>
<li><code>orbit.ip.source.tag</code>: The tag (if provided) specified by the ip being downloaded.</li>
<li><code>orbit.env.*</code>: Any environment variables loaded from configuration files.</li>
</ul>
<h3 id="target-arguments"><a class="header" href="#target-arguments">Target arguments</a></h3>
<p>The argument list defined in a target's configuration is allowed to contain any of the following keys:</p>
<ul>
<li><code>orbit.ip.name</code>: The name of the local ip.</li>
<li><code>orbit.ip.library</code>: The HDL library of the local ip.</li>
<li><code>orbit.ip.version</code>: The version of the local ip.</li>
<li><code>orbit.ip.checksum</code>: The truncated most recent checksum of the local ip.</li>
<li><code>orbit.env.*</code>: Any environment variables loaded from configuration files.</li>
<li><code>orbit.top</code>: The top-level design unit name.</li>
<li><code>orbit.bench</code>: The testbench design unit name.</li>
<li><code>orbit.dut</code>: The design-under-test design unit name.</li>
</ul>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p>Consider an ip with the following manifest data:</p>
<pre><code class="language-toml">[ip]
name = "foo"
version = "1.2.0"
source = "https://github.com/hyperspace-labs/foo/archive/refs/tags/{{orbit.ip.version}}.zip
</code></pre>
<p>The <code>source</code> field of an ip's manifest is one string that is allowed to string swap. For its string, we specify a key, "orbit.ip.version", by enclosing it in double curly brackets. This tells Orbit that any time it uses this string, it should replace <code>{{orbit.ip.version}}</code> with <code>1.2.0</code>, the value associated with that key.</p>
<p>By using string swapping, we can reduce the amount of times redundant information has to be maintained, or delay providing information when we may not know the value until runtime.</p>
<h2 id="environment-variable-translation-examples"><a class="header" href="#environment-variable-translation-examples">Environment variable translation examples</a></h2>
<p>A key recognized by Orbit during string swapping can be an environment variable key. For an environment variable key to be recognized as a key in the context of string swapping, the environment variable key is converted to lowercase with each "_" character replaced by a "." character.</p>
<p>Consider the environment variables set in an Orbit configuration file:</p>
<pre><code class="language-toml">[env]
foo = "bar"
github-user = "cdotrus"
Yilinx_Path = "/Users/chase/fpga/bin/yilinx"
</code></pre>
<p>This configuration translates to the following variables:</p>
<div class="table-wrapper"><table><thead><tr><th>TOML <code>[env]</code> entry</th><th>Environment variable</th><th>Substitution variable</th></tr></thead><tbody>
<tr><td><code>foo</code></td><td><code>ORBIT_ENV_FOO</code></td><td><code>orbit.env.foo</code></td></tr>
<tr><td><code>github-user</code></td><td><code>ORBIT_ENV_GITHUB_USER</code></td><td><code>orbit.env.github.user</code></td></tr>
<tr><td><code>Yilinx_Path</code></td><td><code>ORBIT_ENV_YILINX_PATH</code></td><td><code>orbit.env.yilinx.path</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-symbol-transformation"><a class="header" href="#dynamic-symbol-transformation">Dynamic Symbol Transformation</a></h1>
<p>This technique is related to <em>name mangling</em> in programming languages. <em>Name mangling</em> is a technique used to solve problems regarding the need to resolve unique names for programming entities. You can learn more about name mangling <a href="https://en.wikipedia.org/wiki/Name_mangling">here</a>.</p>
<h2 id="problem"><a class="header" href="#problem">Problem</a></h2>
<p>Before we begin, it is important to understand the problem we are trying to solve. An issue inherent to VHDL and many other languages is <em>namespace pollution</em>, which is when many programming language variables/identifiers/units/classes are defined at the global level. To learn more about namespace pollution, <a href="https://stackoverflow.com/questions/8862665/what-does-it-mean-global-namespace-would-be-polluted/13352212">here</a> is a StackOverflow post that explains it in relation to Javascript.</p>
<p>Namespace pollution can lead to <em>namespace clashes</em>. As you define more primary design units at the same scope, you are more likely to have two things that accidently have the same name. This is at the core the problem we are going to solve, because VHDL compilers and synthesizers are not built to gracefully handle clashes and will error out when a primary design unit at the same scope has multiple definitions.</p>
<p>In VHDL, a common example of a namespace clash is when different files define an entity by the same name, which may have different behaviors. Namespace clashes may start to appear when a higher-level IP requires the same entity from an IP but as different versions throughout its dependency tree.</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p>We solve the namespace pollution problem with an algorithm called <em>dynamic symbol transformation</em> (DST). The DST algorithm solves the namespace clashing problem by rewriting conflicts with a new unique identifier without losing information in the original identifier.</p>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p>Orbit automatically handles resolving duplicate identifiers for primary design units due to two design contraints. The limitations are:</p>
<ol>
<li>All primary design unit identifiers in the current ip must be unique within the scope of the ip.</li>
<li>All primary design units identifiers in the current ip must be unique within the scope of the ip's direct dependencies. An identifier can be duplicated for primary design units across indirect dependencies.</li>
</ol>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<p>This section walks through a basic demonstration of the DST algorithm. First, it defines some terminology, and then walks through the algorithm's functionality.</p>
<h3 id="symbols"><a class="header" href="#symbols">Symbols</a></h3>
<p>Within the context of VHDL, let's consider a <em>symbol</em> to be the identifier of a <em>primary design unit</em>. A primary design unit is a VHDL construct that exists at the global namespace. There are four primary design units:</p>
<ul>
<li>entity</li>
<li>package</li>
<li>configuration</li>
<li>context</li>
</ul>
<blockquote>
<p><strong>Note:</strong> VHDL does support the concept of <em>libraries</em>, which can add 1 level of nested scope to a primary design unit, but for this example we will assume the primary design units are defined within the same library/scope.</p>
</blockquote>
<p>In the following code, the symbol <code>and_gate</code> corresponds to an entity.</p>
<p>Filename: lab1/and_gate.vhd</p>
<pre><code class="language-vhdl">entity and_gate is
  port(
    a, b : in bit;
    c : out bit
  );
end entity;
</code></pre>
<p>Remember that this identifier could appear again at the same namespace level as this exsiting entity in a different VHDL file.</p>
<p>Now imagine you are integrating VHDL code from various existing ips. As you instantiate entities within larger entities, you realize there exists another entity named <code>and_gate</code> further down in the hierarchy, but this one has a different behavior and port interface than the previously defined <code>and_gate</code> circuit from the "lab1/" directory.</p>
<p>Filename: lab3/and_gate.vhd</p>
<pre><code class="language-vhdl">entity and_gate is
  port(
    a, b : in bit_vector(3 downto 0);
    c : out bit_vector(3 downto 0)
  );
end entity;
</code></pre>
<p>Since the current ip requires both code segments, then traditionally your EDA tool would complain to you and be unable to resolve which <code>and_gate</code> to be used where. It then falls on the developer to rename one of the entities where it is defined and everywhere it is referenced, which introduces additional overhead in time and possibilities for errors. This problem is solved with DST.</p>
<h3 id="walkthrough"><a class="header" href="#walkthrough">Walkthrough</a></h3>
<p>We present an example project-level ip dependency tree.</p>
<pre><code>final-project
├─ lab3
│  └─ lab2
|     └─ lab1
└─ lab2
</code></pre>
<p>Imagine the <code>final-project</code> ip has an entity called <code>top_level</code> which is the root of circuit hierarchy. From there, it reuses entities from the other ip.</p>
<p>Let's look at the VHDL design tree hierarchy across the ips.</p>
<pre><code>top_level (final-project)
├─ and_gate (lab3)
│  └─ adder (lab2)
|     └─ and_gate (lab1)
└─ mux (lab2)
</code></pre>
<p>Notice lab1 and lab3 both have the <code>and_gate</code> entity, but their interfaces and functionality are different as previously mentioned. How can we allow both units in the hierarchy while resolving the namespace clash?</p>
<p>DST identifies namespace clashes within the current dependency graph and automatically resolve the conflicts to produce a clean unambiguous graph.</p>
<pre><code>top_level (final-project)
├─ and_gate (lab3)
│  └─ adder (lab2)*
|     └─ and_gate_fbe4720d0 (lab1)*
└─ mux (lab2)
</code></pre>
<p>Let's dive into what happened here. DST handled the namespace clash by <em>transforming</em>, or renaming, the entity related to lab1. The entity's identifier in lab1 was appended with the first 10 digits of the original lab1 ip's checksum. This transformation occurred at that ip's source code level (lab1), and in the source code for all dependents of that entity (lab2). Therefore, DST produced new dynamic variants of the lab1 and lab2 ips that properly reference and associate with <code>and_gate_fbe4720d0</code>.</p>
<p>DST specifically chose not to rename the <code>and_gate</code> from lab3, or else the user would have to be burdened with trying to track and maintain the new unique identifier in the currently developed IP (final-project). As a result, DST has no additional overhead to the user and is kept abstracted away by Orbit. Direct dependencies are never chosen for DST.</p>
<h2 id="emphasis"><a class="header" href="#emphasis">Emphasis</a></h2>
<p>Dynamic symbol transformation lets Orbit avoid the major issues and frustrations of package management that stem from dependency incompatibility. As projects grow in complexity and the number of dependencies increases, Orbit can continue to allow users to integrate different verisons of the same package throughout the overall design while retaining dependency compatibility. Conflicts in incompatible versions are avoided within the dependency graph through DST. You can learn more about dependency incompatibility <a href="https://en.wikipedia.org/wiki/Dependency_hell">here</a>.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li>https://stephencoakley.com/2019/04/24/how-rust-solved-dependency-hell</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>This section provides technical information for the various components used throughout <code>orbit</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manifest"><a class="header" href="#manifest">Manifest</a></h1>
<p>The <code>Orbit.toml</code> file for each ip is called its manifest. It is written in the <a href="https://toml.io/en/">TOML</a> format. It is maintained by the developer and contains metadata that is needed to build the ip.</p>
<blockquote>
<p><strong>Note:</strong> The manifest's file name is "Orbit.toml", with respect to case-sensitivity.</p>
</blockquote>
<p>Every manifest file consists of the following sections:</p>
<ul>
<li><a href="reference/manifest.html#the-ip-section">[ip]</a> - Defines an ip.
<ul>
<li><a href="reference/manifest.html#the-name-field">name</a> - The name of the ip.</li>
<li><a href="reference/manifest.html#the-version-field">version</a> - The version of the ip.</li>
<li><a href="reference/manifest.html#the-authors-field">authors</a> - The authors of the ip.</li>
<li><a href="reference/manifest.html#the-library-field">library</a> - The HDL library for the design units within the ip.</li>
<li><a href="reference/manifest.html#the-description-field">description</a> - A short description of the ip.</li>
<li><a href="reference/manifest.html#the-keywords-field">keywords</a> - A list of simple words categorizing the ip.</li>
<li><a href="reference/manifest.html#the-source-field">source</a> - The URL for remotely retrieving the ip.</li>
<li><a href="reference/manifest.html#the-public-field">public</a> - The list of files to be visible to other ip.</li>
<li><a href="reference/manifest.html#the-readme-field">readme</a> - The path to the README file.</li>
<li><a href="reference/manifest.html#the-metadata-section">[metadata]</a> - An unchecked section for custom fields.</li>
</ul>
</li>
<li><a href="reference/manifest.html#the-dependencies-section">[dependencies]</a> - Ip dependencies.</li>
<li><a href="reference/manifest.html#the-dev-dependencies-section">[dev-dependencies]</a> - Ip dependencies only used for ongoing development.</li>
</ul>
<h3 id="the-ip-section"><a class="header" href="#the-ip-section">The <code>[ip]</code> section</a></h3>
<p>The first section in a <code>Orbit.toml</code> file is <code>[ip]</code>.</p>
<pre><code class="language-toml">[ip]
name = "my-ip" # the name of the package
version = "0.1.0" # the current version
</code></pre>
<p>The only fields required by <code>orbit</code> are name and version.</p>
<h3 id="the-name-field"><a class="header" href="#the-name-field">The <code>name</code> field</a></h3>
<pre><code class="language-toml">[ip]
name = "my-ip"
# ...
</code></pre>
<h3 id="the-version-field"><a class="header" href="#the-version-field">The <code>version</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
version = "0.1.0"
</code></pre>
<h3 id="the-authors-field"><a class="header" href="#the-authors-field">The <code>authors</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
authors = ["Duncan Idaho", "Gurney Halleck"]

</code></pre>
<h3 id="the-library-field"><a class="header" href="#the-library-field">The <code>library</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
library = "work"
</code></pre>
<h3 id="the-description-field"><a class="header" href="#the-description-field">The <code>description</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
description = "A short description of the ip"
</code></pre>
<h3 id="the-keywords-field"><a class="header" href="#the-keywords-field">The <code>keywords</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
keywords = ["cpu", "risc"]
</code></pre>
<h3 id="the-source-field"><a class="header" href="#the-source-field">The <code>source</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
source = "https://github.com/cdotrus/orbit/archive/refs/tags/1.0.0.zip"
</code></pre>
<h3 id="the-public-field"><a class="header" href="#the-public-field">The <code>public</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
public = ["/rtl"]
</code></pre>
<p>The <code>public</code> field can be used to explicitly specify which files are visible to other ip when being when being referenced as a dependency. The list contains glob-style patterns that conform to .gitignore file semantics, and are always compared relative that ip's root directory.</p>
<p>If no <code>public</code> field is present, then all files are implicitly specified as visible (public) to other ip when being referenced as a dependency.</p>
<pre><code class="language-toml">[ip]
# ...
source = { url = "https://github.com/cdotrus/orbit.git", protocol = "p-git", tag = "1.0.0" }
</code></pre>
<h3 id="the-readme-field"><a class="header" href="#the-readme-field">The <code>readme</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
readme = "README.md"
</code></pre>
<h3 id="the-metadata-section"><a class="header" href="#the-metadata-section">The <code>[metadata]</code> section</a></h3>
<p>Any type of TOML entry is allowed in this section, as Orbit ignores this section.</p>
<pre><code class="language-toml">[ip.metadata]
my-field-1 = true
my-field-2 = "hello world"
# ...
</code></pre>
<h3 id="the-dependencies-section"><a class="header" href="#the-dependencies-section">The <code>[dependencies]</code> section</a></h3>
<p>The <code>[dependencies]</code> section is a table of direct dependencies required for the current ip.</p>
<pre><code class="language-toml">[dependencies]
gates = "1.0.0"
uart = "2.3.1"
</code></pre>
<p>If the ip has no dependencies, the section can be omitted from the manifest. The ips listed in this section will always be included in the build graph.</p>
<h3 id="the-dev-dependencies-section"><a class="header" href="#the-dev-dependencies-section">The <code>[dev-dependencies]</code> section</a></h3>
<p>The <code>[dev-dependencies]</code> section is a table of direct dependencies required for the current ip.</p>
<pre><code class="language-toml">[dev-dependencies]
testkit = "1.3.7"
logic-analyzer = "4.8.0"
</code></pre>
<p>If the ip has no development dependencies, the section can be omitted from the manifest. The ips listed in this section will not be included in the build graph for when this ip is used as a dependency itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="names"><a class="header" href="#names">Names</a></h1>
<p>In order to identify an ip among others, Orbit requires developers to assign a human-readable name to each created ip.</p>
<p>The ip name is a unique string of characters that abides by a certain set of rules. It is a single name and is defined under the "name" field in an ip's manifest. Every ip is required to have a name.</p>
<h2 id="rules"><a class="header" href="#rules">Rules</a></h2>
<p>The following rules currently apply to a ip name:</p>
<ul>
<li>begins with an ASCII letter (<code>a-z</code>, <code>A-Z</code>)</li>
<li>contains only ASCII letters (<code>a-z</code>, <code>A-Z</code>), ASCII digits (<code>0-9</code>), dashes <code>-</code>, and underscores <code>_</code></li>
<li>cannot end with a dash <code>-</code> or underscore <code>_</code></li>
</ul>
<h2 id="ip-specification"><a class="header" href="#ip-specification">Ip specification</a></h2>
<p>An ip specification, commonly abbreviated to <em>spec</em>, is the total unambiguous reference to a particular ip at a particular version.</p>
<pre><code>spec ::= &lt;name&gt;[:version]
</code></pre>
<h3 id="example-specifications"><a class="header" href="#example-specifications">Example specifications</a></h3>
<p>The following provides various valid inputs when defining an ip's spec and how it decomposes into its parts.</p>
<div class="table-wrapper"><table><thead><tr><th>Spec</th><th>Name</th><th>Version</th></tr></thead><tbody>
<tr><td><code>gates:1.0.0</code></td><td><code>gates</code></td><td><code>1.0.0</code></td></tr>
<tr><td><code>ram</code></td><td><code>ram</code></td><td><code>latest</code></td></tr>
<tr><td><code>fifo:2.3</code></td><td><code>fifo</code></td><td><code>2.3.*</code></td></tr>
</tbody></table>
</div>
<h3 id="namespace-collisions"><a class="header" href="#namespace-collisions">Namespace Collisions</a></h3>
<p>Two different ip's may share a common name within the catalog even though their contents are different. Two names are considered equal if their lowercase mapping is identical, where dashes (<code>-</code>) also map to underscores (<code>_</code>).</p>
<div class="table-wrapper"><table><thead><tr><th>Spec 1</th><th>Spec 2</th><th>Collision</th></tr></thead><tbody>
<tr><td><code>gates</code></td><td><code>GATES</code></td><td>true</td></tr>
<tr><td><code>ram</code></td><td><code>rom</code></td><td>false</td></tr>
<tr><td><code>fifo_cdc</code></td><td><code>Fifo-CDC</code></td><td>true</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Note:</strong> A resolution to this problem is to add an ip's UUID to the ip specification. While each ip already has a UUID auto-assigned in their lock file, this is a proposed feature that has yet to be implemented.</p>
</blockquote>
<h2 id="ip-libraries"><a class="header" href="#ip-libraries">Ip libraries</a></h2>
<p>An ip can optionally belong to a library. An ip's <em>library</em> is a higher-level scope that loosely groups together multiple ips. This library identification is used for grouping the HDL source code itself into their language-defined libraries as well.</p>
<p>A library can be defined through the "library" field in the ip's manifest file. Its format follows the same rules as the ip's name. If no library is defined in the ip's manifest, then the default library is the ip's name.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="versions"><a class="header" href="#versions">Versions</a></h1>
<p>Code evolves over time, and versions provide a method for capturing a project's state at a given time stamp.</p>
<p>Orbit uses the <em>semantic versioning</em> scheme for capturing project's state at given time periods. Semantic versioning uses 3 numeric values to signify different levels of change.</p>
<pre><code>version ::= &lt;major&gt;.&lt;minor&gt;.&lt;micro&gt;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Level</th><th>Explanation</th></tr></thead><tbody>
<tr><td>Major</td><td>Incompatible API changes</td></tr>
<tr><td>Minor</td><td>Adding functionality in backward-compatible way</td></tr>
<tr><td>Micro</td><td>Fixing bugs in backward-compatible way</td></tr>
</tbody></table>
</div>
<p>To learn more about semantic versioning, visit the official <a href="https://semver.org">website</a>.</p>
<p>Determining the next version number based on a project's recent code changes can be an opinionated process, so it's recommended to also keep a changelog highlighting the differences among versions.</p>
<blockquote>
<p><strong>Note:</strong> An alternative to <em>semantic versioning</em> is <em>calender versioning</em>, which
also operates on the basis of using 3 digits. To learn more about <em>calender versioning</em> visit the official <a href="https://calver.org">website</a>.</p>
</blockquote>
<h2 id="rules-1"><a class="header" href="#rules-1">Rules</a></h2>
<ul>
<li>Each level may only contain ASCII digits (<code>0-9</code>).</li>
</ul>
<p>All 3 levels must be given a numeric value consisting of only digits separated by a dot (<code>.</code>) character. This is considered a <em>fully qualified</em> version.</p>
<pre><code>1.0.0
</code></pre>
<p>In some scenarios a <em>partially qualified</em> version can be accepted. This means one or more of the version's levels are omitted.</p>
<pre><code>1
1.0
</code></pre>
<p>When given a partially qualified version, Orbit references the maximum version available that satifies the partially qualified version. If no version is specified, it assumes the request is for the latest known version. The latest known version can also be explicitly requested by inputting <code>latest</code> as the version. Assume the known released versions for a given IP are as listed:</p>
<div class="table-wrapper"><table><thead><tr><th>Versions</th></tr></thead><tbody>
<tr><td><code>2.1.0</code></td></tr>
<tr><td><code>1.5.0</code></td></tr>
<tr><td><code>1.2.1</code></td></tr>
<tr><td><code>1.2.0</code></td></tr>
<tr><td><code>1.0.0</code></td></tr>
</tbody></table>
</div>
<p>The following illustrates the mapping from the partially specified requested version to its fully specified known version that would be returned:</p>
<div class="table-wrapper"><table><thead><tr><th>Requested</th><th>Returned</th></tr></thead><tbody>
<tr><td><code>1</code></td><td><code>1.5.0</code></td></tr>
<tr><td><code>1.1</code></td><td><code>NOT FOUND</code></td></tr>
<tr><td><code>1.2</code></td><td><code>1.2.1</code></td></tr>
<tr><td><code>2</code></td><td><code>2.1.0</code></td></tr>
<tr><td><code>1.2.0</code></td><td><code>1.2.0</code></td></tr>
<tr><td><code>latest</code></td><td><code>2.1.0</code></td></tr>
<tr><td><code>(omitted)</code></td><td><code>2.1.0</code></td></tr>
</tbody></table>
</div>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<p>A fully qualified version must be written in every project's manifest file.</p>
<pre><code class="language-toml">[ip]
# ...
version = "1.5.4"
# ...
</code></pre>
<p>A specific (or partially speific) version can be requested for an IP on the command-line by placing a colon <code>:</code> character between the package's name and the requested version.</p>
<pre><code>$ orbit install gates:1.5.4
$ orbit get nor_gate --ip gates:1.5
</code></pre>
<h2 id="comparing-versions"><a class="header" href="#comparing-versions">Comparing versions</a></h2>
<p>The following pseudocode provides additional help in learning about how versions are compared (selecting a "higher" version).</p>
<pre><code>IF major levels are not equal:
    RETURN version with larger major level value.
ELSE IF minor levels are not equal:
    RETURN version with larger minor level value.
ELSE:
    RETURN version with larger patch level value. 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filesets"><a class="header" href="#filesets">Filesets</a></h1>
<p>A <em>fileset</em> is group of files identified by a common file pattern. Typically they are denoted by a common file extension, such as <code>.txt</code>, but a fileset can more broadly be grouped under any glob-style pattern.</p>
<p>A fileset itself consists of a name and a pattern.</p>
<ul>
<li>The name is a string that is normalized to ALL-UPPERCASE-WITH-HYPENS. It is used to identify which fileset a file belongs to.</li>
<li>The pattern is a glob-style pattern. It is used to perform glob-style matching when searching the file system for files to add to a fileset.</li>
</ul>
<h2 id="built-in-filesets"><a class="header" href="#built-in-filesets">Built-in filesets</a></h2>
<p>There are built-in filesets that <code>orbit</code> uses that have special rules and work across all IP, including dependencies. The filesets built into <code>orbit</code> that are currently supported are:</p>
<ul>
<li><code>VHDL-RTL</code>: VHDL files (.vhd, .vhdl) that contain zero entities without a port interface.</li>
<li><code>VHDL-SIM</code>: VHDL files (.vhd, .vhdl) that contain at least one entity without a port interface.</li>
</ul>
<h2 id="reserved-filesets"><a class="header" href="#reserved-filesets">Reserved filesets</a></h2>
<p>Filesets that are planned to be built into <code>orbit</code> at a later date are:</p>
<ul>
<li><code>VLOG-RTL</code>: SytemVerilog/Verilog files (.v, .sv) that contain zero modules without a port interface.</li>
<li><code>VLOG-SIM</code>: SystemVerilog/Verilog files (.v, .sv) that contain at least one module without a port interface.</li>
</ul>
<h2 id="custom-filesets"><a class="header" href="#custom-filesets">Custom filesets</a></h2>
<p>Custom filesets are filesets that are be defined by the user either for a specific plugin or on the command-line. These filesets are only searched for in the current working IP and do not extend to its dependencies.</p>
<p>If the pattern does not start with an explicit relative path symbol (<code>.</code>), then <code>orbit</code> assumes to look for the fileset across every possible path in the current working IP by implicitly prepending the pattern with <code>**/</code>.</p>
<h2 id="name-normalization-examples"><a class="header" href="#name-normalization-examples">Name normalization examples</a></h2>
<div class="table-wrapper"><table><thead><tr><th>User-defined Fileset</th><th>Normalized Fileset</th></tr></thead><tbody>
<tr><td>GOOD-SET</td><td>GOOD-SET</td></tr>
<tr><td>Set-1</td><td>SET-1</td></tr>
<tr><td>set_2</td><td>SET-2</td></tr>
<tr><td>set_three</td><td>SET-THREE</td></tr>
</tbody></table>
</div>
<p>The normalized fileset name is the name that will be written to the blueprint file when collecting filesets. This design choice is for consistency across plugins when reading and parsing the blueprint.</p>
<h2 id="custom-pattern-assumption-examples"><a class="header" href="#custom-pattern-assumption-examples">Custom pattern assumption examples</a></h2>
<div class="table-wrapper"><table><thead><tr><th>User-defined pattern</th><th>Interpreted pattern</th></tr></thead><tbody>
<tr><td>*.txt</td><td>**/*.txt</td></tr>
<tr><td>Boards/*.toml</td><td>**/Boards/*.toml</td></tr>
<tr><td>./specific/path.log</td><td>./specific/path.log</td></tr>
</tbody></table>
</div>
<p>The custom patterns begin their search for files at the root directory of the current working IP. The interpreted pattern is the actual glob-style pattern used when collecting files for custom filesets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blueprint"><a class="header" href="#blueprint">Blueprint</a></h1>
<p>The <em>blueprint</em> is a file containing a list of files required for a particular back end. This single file is the main method Orbit uses to communicate information to a target's process.</p>
<p>When the blueprint is created, it is saved to the local ip's target output directory.</p>
<h2 id="formats"><a class="header" href="#formats">Formats</a></h2>
<p>The currently supported formats are:</p>
<ul>
<li><a href="reference/blueprint.html#tab-separated-values">Tab-separated values</a>: <code>blueprint.tsv</code></li>
</ul>
<h2 id="specifications"><a class="header" href="#specifications">Specifications</a></h2>
<p>Each blueprint format may contain different information and store it in a different way. Refer to each specification to see exactly how the data is communicated through their blueprint.</p>
<p>Attributes that are consistent across all formats are the fileset, library, and filepath.</p>
<p>The <em>fileset</em> is the group name for the file pattern that matched the given rule's file.</p>
<p>The <em>library</em> is the hdl defined library for the ip which the given file at this particular step was found.</p>
<p>The <em>filepath</em> is the absolute file system path to the given rule's file.</p>
<h3 id="built-in-filesets-1"><a class="header" href="#built-in-filesets-1">Built-in Filesets</a></h3>
<p>The following filesets are already recognized by Orbit and are used for identifying hdl source code:</p>
<div class="table-wrapper"><table><thead><tr><th>Fileset</th><th>Supported file extensions</th></tr></thead><tbody>
<tr><td><code>VHDL</code></td><td>.vhd, .vhdl</td></tr>
<tr><td><code>VLOG</code></td><td>.v, .vl, .verilog, .vlg, .vh</td></tr>
<tr><td><code>SYSV</code></td><td>.sv, .svh</td></tr>
</tbody></table>
</div>
<h2 id="tab-separated-values"><a class="header" href="#tab-separated-values">Tab-separated values</a></h2>
<ul>
<li>Advantages
<ul>
<li>Simple and easy to parse for back ends</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>Limited information is sent</li>
</ul>
</li>
</ul>
<p>The file is divided into a series of <em>steps</em>, each separated by a newline character (<code>\n</code>).</p>
<pre><code>STEP
STEP
...
</code></pre>
<p>A step contains information about a particular file. Every step always has 3 components: a fileset, a library, and a filepath. Each component in a step is separated by a tab character (<code>\t</code>).</p>
<pre><code>FILESET	LIBRARY	FILEPATH
</code></pre>
<h4 id="examples"><a class="header" href="#examples">Examples</a></h4>
<pre><code class="language-text">PYMDL	lc3b	/Users/chase/projects/lc3b/sim/models/alu_tb.py
VHDL	lc3b	/Users/chase/projects/lc3b/rtl/const_pkg.vhd
VHDL	base2	/Users/chase/.orbit/cache/base2-1.0.0-aac9159285/pkg/base2.vhd
VHDL	lc3b	/Users/chase/projects/lc3b/rtl/alu.vhd
VHDL	lc3b	/Users/chase/projects/lc3b/sim/alu_tb.vhd
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h1>
<p>Orbit's configuration can be customized with the setting of specific environment variables.</p>
<ul>
<li>
<p><code>ORBIT_HOME</code> - directory where orbit stores its data. By default it is <code>$HOME/.orbit</code> on Unix systems and <code>%USERPROFILE%/.orbit</code> on Windows systems.</p>
</li>
<li>
<p><code>ORBIT_CACHE</code> - directory where orbit caches installed ip. By default it is <code>$ORBIT_HOME/cache</code>.</p>
</li>
<li>
<p><code>ORBIT_ARCHIVE</code> - directory where orbit saves archived snapshots of ip at a particular version. By default it is <code>$ORBIT_HOME/archive</code>.</p>
</li>
<li>
<p><code>NO_COLOR</code> - does not print colorized output when set to a value.</p>
</li>
<li>
<p><code>EDITOR</code> - chooses this value as the default text editor when no <code>core.editor</code> key is present in the config.toml.</p>
</li>
<li>
<p><code>ORBIT_WIN_LITERAL_CMD</code> - disables default behavior of checking for programs ending with .exe then .bat when a program name without extension is not found on a windows operating system</p>
</li>
</ul>
<h2 id="runtime-environment-variables"><a class="header" href="#runtime-environment-variables">Runtime environment variables</a></h2>
<p>Orbit also sets environment variables during runtime so a plugin has access to runtime information.</p>
<ul>
<li>
<p><code>ORBIT_TARGET_DIR</code> - directory to perform the build process relative to the current ip path. Default is <code>target</code>.</p>
</li>
<li>
<p><code>ORBIT_IP_PATH</code> - path to the ip that is detected under the current working directory. If its not immediately detected at the current directory, it will continue to search the parent directory until it finds a <code>Orbit.toml</code> manifest file.</p>
</li>
<li>
<p><code>ORBIT_TARGET</code> - selected target to plan and execute</p>
</li>
<li>
<p><code>ORBIT_TOP</code> - top level design unit identifier</p>
</li>
<li>
<p><code>ORBIT_BENCH</code> - the testbench identifier</p>
</li>
<li>
<p><code>ORBIT_DUT</code> - the device under test's identifier</p>
</li>
<li>
<p><code>ORBIT_IP_NAME</code> - name field of the manifest for the ip package</p>
</li>
<li>
<p><code>ORBIT_IP_LIBRARY</code> - the HDL library defined in the ip's manifest</p>
</li>
<li>
<p><code>ORBIT_IP_VERSION</code> - specific version of current working directory's ip</p>
</li>
<li>
<p><code>ORBIT_IP_CHECKSUM</code> - the truncated most recent checksum of the local ip</p>
</li>
<li>
<p><code>ORBIT_BLUEPRINT</code> - the filename for the blueprint created during the planning stage</p>
</li>
<li>
<p><code>ORBIT_OUTPUT_PATH</code> - path to the selected target's build process working directory</p>
</li>
</ul>
<h2 id="checking-the-environment"><a class="header" href="#checking-the-environment">Checking the environment</a></h2>
<p>You can review the known environment variables within Orbit with <code>orbit env</code>.</p>
<!--Note about environment variables vs. settings file vs. arguments

precedence:
3. config file
2. env vars
1. command-line
--><div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>The <code>config.toml</code> file stores settings and extends Orbit's functionality. It is written in the <a href="https://toml.io/en/">TOML</a> format. It is maintained by the developer and can be shared across teams for consistent development environments.</p>
<blockquote>
<p><strong>Note:</strong> The configuration's file name is "config.toml", with respect to case-sensitivity.</p>
</blockquote>
<h2 id="paths"><a class="header" href="#paths">Paths</a></h2>
<p>When a field is expected to be a file system path, Orbit has the ability to resolve relative paths. The path is determined in relation to the currently processed <code>config.toml</code>'s parent directory. This design choice was implemented in order to allow for path definitions to be valid across developer machines when sharing configurations. It is recommended to use relative paths when setting a path to a field in a <code>config.toml</code>.</p>
<h2 id="precedence"><a class="header" href="#precedence">Precedence</a></h2>
<p>Orbit supports multiple levels of configuration. Each level has its own order of precedence:</p>
<ol>
<li>
<p>Local configuration file (working ip's directory)</p>
</li>
<li>
<p>Local parent configuration files (parent directories of the working ip's directory)</p>
</li>
<li>
<p>Included configurations (order-preserving) listed in the global <code>config.toml</code>'s <a href="reference/configuration.html#the-include-field"><code>include</code></a></p>
</li>
<li>
<p>Global configuration file (location: <code>$ORBIT_HOME</code>)</p>
</li>
</ol>
<p>The configuration files are processed in the order defined above. When a configuration file defines a field, no other configuration files later in the process will be able to override its value. If a field is never provided an explicit value, the hard-coded defaults will be used.</p>
<blockquote>
<p><strong>Tip:</strong> You can modify some values in the configuration file through the command-line by using the <code>orbit config</code> command.</p>
</blockquote>
<p>Every configuration file consists of the following sections:</p>
<ul>
<li><a href="reference/configuration.html#the-include-field">include</a> - Lists other <code>config.toml</code> files to process.</li>
<li><a href="reference/configuration.html#the-language-section">[language]</a> - The language settings.
<ul>
<li><a href="reference/configuration.html#the-vhdl-field">vhdl</a> - Enable/disable VHDL support.</li>
<li><a href="reference/configuration.html#the-verilog-field">verilog</a> - Enable/disable Verilog support.</li>
<li><a href="reference/configuration.html#the-systemverilog-field">systemverilog</a> - Enable/disable SystemVerilog support.</li>
</ul>
</li>
<li><a href="reference/configuration.html#the-general-section">[general]</a> - The general settings.
<ul>
<li><a href="reference/configuration.html#the-target-dir-field">target-dir</a> - Default target directory.</li>
</ul>
</li>
<li><a href="reference/configuration.html#the-test-section">[test]</a> - The test settings.
<ul>
<li><a href="reference/configuration.html#the-default-target-field">default-target</a> - Set the default target for tests.</li>
</ul>
</li>
<li><a href="reference/configuration.html#the-build-section">[build]</a> - The build settings.
<ul>
<li><a href="reference/configuration.html#the-default-target-field">default-target</a> - Set the default target for builds.</li>
</ul>
</li>
<li><a href="reference/configuration.html#the-vhdl-format-section">[vhdl-format]</a> - VHDL code formatting.</li>
<li><a href="reference/configuration.html#the-env-section">[env]</a> - The runtime environment variables.</li>
<li><a href="reference/configuration.html#the-target-array">[[target]]</a> - Define a target.
<ul>
<li><a href="reference/configuration.html#the-name-field">name</a> - The name of the target.</li>
<li><a href="reference/configuration.html#the-description-field">description</a> - A short description of the target.</li>
<li><a href="reference/configuration.html#the-command-field">command</a> - The command to execute the target.</li>
<li><a href="reference/configuration.html#the-args-field">args</a> - Arguments to pass to the command.</li>
<li><a href="reference/configuration.html#the-plans-field">plans</a> - The list of supported blueprint file formats.</li>
<li><a href="reference/configuration.html#the-fileset-section">[fileset]</a> - Filesets to collect for the target.</li>
<li><a href="reference/configuration.html#the-explanation-field">explanation</a> - A detailed description of the target.</li>
</ul>
</li>
<li><a href="reference/configuration.html#the-protocol-array">[[protocol]]</a> - Define a protocol.
<ul>
<li><a href="reference/configuration.html#the-name-field">name</a> - The name of the protocol.</li>
<li><a href="reference/configuration.html#the-description-field">description</a> - A short description of the protocol.</li>
<li><a href="reference/configuration.html#the-command-field">command</a> - The command to execute the protocol.</li>
<li><a href="reference/configuration.html#the-args-field">args</a> - Arguments to pass to the command.</li>
<li><a href="reference/configuration.html#the-explanation-field">explanation</a> - A detailed description of the protocol.</li>
</ul>
</li>
<li><a href="reference/configuration.html#the-channel-array">[[channel]]</a> - Define a channel.
<ul>
<li><a href="reference/configuration.html#the-name-field">name</a> - The name of the channel.</li>
<li><a href="reference/configuration.html#the-description-field">description</a> - A short description of the channel.</li>
<li><a href="reference/configuration.html#the-root-field">root</a> - The directory where the channel exists.</li>
<li><a href="reference/configuration.html#the-command-field">sync.command</a> - The command to execute when synchronizing the channel.</li>
<li><a href="reference/configuration.html#the-args-field">sync.args</a> - Arguments to pass to the command during synchronization.</li>
<li><a href="reference/configuration.html#the-command-field">pre.command</a> - The command to execute immediately before launch.</li>
<li><a href="reference/configuration.html#the-command-field">pre.args</a> - Arguments to pass to the command immediately before launch.</li>
<li><a href="reference/configuration.html#the-command-field">post.command</a> - The command to execute immediately after launch.</li>
<li><a href="reference/configuration.html#the-args-field">post.args</a> - Arguments to pass to the command immediately after launch.</li>
</ul>
</li>
</ul>
<h3 id="the-include-field"><a class="header" href="#the-include-field">The <code>include</code> field</a></h3>
<pre><code class="language-toml">include = [
    "profiles/p1/config.toml",
    "profiles/p2/config.toml",
    "channels/c1/config.toml"
]
</code></pre>
<h3 id="the-language-section"><a class="header" href="#the-language-section">The <code>[language]</code> section</a></h3>
<h3 id="the-vhdl-field"><a class="header" href="#the-vhdl-field">The <code>vhdl</code> field</a></h3>
<p>Enable or disable VHDL language support. Disabling this field will prevent Orbit from recognizing files with .vhd and .vhdl extensions. If this field is omitted, the default value is <code>true</code>.</p>
<pre><code class="language-toml">[language]
vhdl = true
</code></pre>
<h3 id="the-verilog-field"><a class="header" href="#the-verilog-field">The <code>verilog</code> field</a></h3>
<p>Enable or disable Verilog language support. Disabling this field will prevent Orbit from recognizing files with .v and .vh extensions. If this field is omitted, the default value is <code>true</code>.</p>
<pre><code class="language-toml">[language]
# ...
verilog = true
</code></pre>
<h3 id="the-systemverilog-field"><a class="header" href="#the-systemverilog-field">The <code>systemverilog</code> field</a></h3>
<p>Enable or disable SystemVerilog language support. Disabling this field will prevent Orbit from recognizing files with .sv and .svh extensions. If this field is omitted, the default value is <code>true</code>.</p>
<pre><code class="language-toml">[language]
# ...
systemverilog = true
</code></pre>
<h3 id="the-general-section"><a class="header" href="#the-general-section">The <code>[general]</code> section</a></h3>
<h3 id="the-target-dir-field"><a class="header" href="#the-target-dir-field">The <code>target-dir</code> field</a></h3>
<p>Define the default output directory to create for the planning and building phases. This value can be overridden on the command-line when the <code>--target-dir</code> option is available. When this field is not defined, the default value for the build directory is "target".</p>
<pre><code class="language-toml">[general]
target-dir = "target"
# ...
</code></pre>
<h3 id="the-test-section"><a class="header" href="#the-test-section">The <code>[test]</code> section</a></h3>
<h3 id="the-default-target-field"><a class="header" href="#the-default-target-field">The <code>default-target</code> field</a></h3>
<p>Sets the default target when calling <code>orbit test</code>. If the default target is set to be used and it cannot be found among the known targets, it will error.</p>
<pre><code class="language-toml">[test]
default-target = "foo"
</code></pre>
<h3 id="the-build-section"><a class="header" href="#the-build-section">The <code>[build]</code> section</a></h3>
<h3 id="the-default-target-field-1"><a class="header" href="#the-default-target-field-1">The <code>default-target</code> field</a></h3>
<p>Sets the default target when calling <code>orbit build</code>. If the default target is set to be used and it cannot be found among the known targets, it will error.</p>
<pre><code class="language-toml">[build]
default-target = "bar"
</code></pre>
<h3 id="the-vhdl-format-section"><a class="header" href="#the-vhdl-format-section">The <code>[vhdl-format]</code> section</a></h3>
<p>The currently supported entries are demonstrated in the following code snippet. Entries not present will be set to their hard-coded default value.</p>
<pre><code class="language-toml">[vhdl-format]
# enable colored output for generated vhdl code
highlight-syntax = true
# number of whitespace characters per tab/indentation
tab-size = 2
# insert a tab before 'generic' and 'port' interface declarations
indent-interface = true
# automatically align a signal or constant's subtype with its other identifiers
type-auto-alignment = false
# number of whitespace characters after alignment (before ':' token)
type-offset = 0
# automatically align a instantiation's mapping with its other identifiers
mapping-auto-alignment = false
# number of whitespace characters after mapping (before '=&gt;' token)
mapping-offset = 1
</code></pre>
<h3 id="the-env-section"><a class="header" href="#the-env-section">The <code>[env]</code> section</a></h3>
<p>The user can define an arbitrary number of their own entries with their determined value represented in string format.</p>
<pre><code class="language-toml">[env]
foo = "0" # Accessible as ORBIT_ENV_FOO
super-bar = "1" # Accessible as ORBIT_ENV_SUPER_BAR
</code></pre>
<h3 id="the-target-array"><a class="header" href="#the-target-array">The <code>[[target]]</code> array</a></h3>
<h3 id="the-name-field-1"><a class="header" href="#the-name-field-1">The <code>name</code> field</a></h3>
<pre><code class="language-toml">[[target]]
name = "dump-blueprint"
</code></pre>
<h3 id="the-description-field-1"><a class="header" href="#the-description-field-1">The <code>description</code> field</a></h3>
<pre><code class="language-toml">[[target]]
# ...
description = "Print the blueprint contents to the screen"
</code></pre>
<h3 id="the-command-field"><a class="header" href="#the-command-field">The <code>command</code> field</a></h3>
<pre><code class="language-toml">[[target]]
# ...
command = "cat"
</code></pre>
<h3 id="the-args-field"><a class="header" href="#the-args-field">The <code>args</code> field</a></h3>
<pre><code class="language-toml">[[target]]
# ...
args = ["blueprint.tsv"]
</code></pre>
<h3 id="the-plans-field"><a class="header" href="#the-plans-field">The <code>plans</code> field</a></h3>
<pre><code class="language-toml">[[target]]
# ...
plans = ["tsv"]
</code></pre>
<p>The type of blueprint files supported by the particular target. If a list is provided, the default plan used is the first item in the list. If a plan is provided on the command-line, then it must be a valid plan and found within the target's defined list.</p>
<p>If this field is left blank or not defined, then the default plan is "tsv".</p>
<h3 id="the-explanation-field"><a class="header" href="#the-explanation-field">The <code>explanation</code> field</a></h3>
<pre><code class="language-toml">explanation = """
A very long explanation about what this target does 
and how to possibly get more information about using it.
"""
</code></pre>
<h3 id="the-fileset-section"><a class="header" href="#the-fileset-section">The <code>[fileset]</code> section</a></h3>
<pre><code class="language-toml">[[target]]
# ...
fileset.pymdl = "{{ orbit.bench }}.py"
</code></pre>
<h3 id="the-protocol-array"><a class="header" href="#the-protocol-array">The <code>[[protocol]]</code> array</a></h3>
<h3 id="the-name-field-2"><a class="header" href="#the-name-field-2">The <code>name</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-description-field-2"><a class="header" href="#the-description-field-2">The <code>description</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-command-field-1"><a class="header" href="#the-command-field-1">The <code>command</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-args-field-1"><a class="header" href="#the-args-field-1">The <code>args</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-channel-array"><a class="header" href="#the-channel-array">The <code>[[channel]]</code> array</a></h3>
<h3 id="the-name-field-3"><a class="header" href="#the-name-field-3">The <code>name</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-description-field-3"><a class="header" href="#the-description-field-3">The <code>description</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-root-field"><a class="header" href="#the-root-field">The <code>root</code> field</a></h3>
<p>The file system path where the channel exists, relative to the configuration file where it is defined.</p>
<pre><code class="language-toml">[[channel]]
# ...
root = "./index"
</code></pre>
<h3 id="the-synccommand-field"><a class="header" href="#the-synccommand-field">The <code>sync.command</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-syncargs-field"><a class="header" href="#the-syncargs-field">The <code>sync.args</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-precommand-field"><a class="header" href="#the-precommand-field">The <code>pre.command</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-preargs-field"><a class="header" href="#the-preargs-field">The <code>pre.args</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-postcommand-field"><a class="header" href="#the-postcommand-field">The <code>post.command</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-postargs-field"><a class="header" href="#the-postargs-field">The <code>post.args</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-output"><a class="header" href="#json-output">JSON Output</a></h1>
<p>The <code>orbit get</code> command allows a user to receive various pieces of information related to a design unit, such its component declaration, defined architectures, or entity instantiation.</p>
<p>It also allows users to export the unit's interface with the <code>--json</code> flag. This is convenient when you wish to pass this information in a more machine-readable format to another tool/program.</p>
<h2 id="schema"><a class="header" href="#schema">Schema</a></h2>
<p>The following schema is implemented for the json output:</p>
<pre><code class="language-json">{
  "identifier": string
  "generics": [
    {
        "identifier": string
        "mode": string
        "type": string
        "default": string // null if blank
    }
  ]
  "ports": [
    {
        "identifier": string
        "mode": string
        "type": string
        "default": string // null if blank
    }
  ]
  "architectures": [
      string
  ],
  "language": string
}
</code></pre>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>Some ideas about exporting json from <code>orbit get</code> can be found at this <a href="https://blog.kellybrazil.com/2021/12/03/tips-on-adding-json-output-to-your-cli-app/">blog post</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line"><a class="header" href="#command-line">Command line</a></h1>
<p>The command line is the main way of interacting with <code>orbit</code>. Let's understand some terminology and rules for communicating to <code>orbit</code> through the command line.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>Angular brackets (<code>&lt; &gt;</code>) denotes that a user input is required. The label within the angular brackets gives a hint to the user as to what type of value to enter here.</p>
<p>Square brackets (<code>[ ]</code>) denotes that the input is optional and is not required to get the command to successfully run.</p>
<h2 id="jargon"><a class="header" href="#jargon">Jargon</a></h2>
<p>Orbit uses <em>subcommands</em>, <em>arguments</em>, <em>options</em>, <em>flags</em>, and <em>switches</em>.</p>
<h3 id="subcommand"><a class="header" href="#subcommand"><strong>Subcommand</strong></a></h3>
<p>Subcommands are special keywords to route to a particular action. Each subcommand inherits all supercommand's available options. They are the first positional argument following the call to <code>orbit</code>.</p>
<pre><code>orbit get
</code></pre>
<h3 id="argument"><a class="header" href="#argument"><strong>Argument</strong></a></h3>
<p>An argument is a value interpreted based on its position in the input. Arguments must be included when requested by Orbit within angular brackets (<code>&lt; &gt;</code>).</p>
<pre><code>orbit new &lt;path&gt;
</code></pre>
<p>Arguments may be omitted if they are wrapped with square brackets (<code>[ ]</code>).</p>
<pre><code>orbit search [&lt;ip&gt;]
</code></pre>
<h3 id="flag"><a class="header" href="#flag"><strong>Flag</strong></a></h3>
<p>A flag is a simple boolean on-off conditional to alter a command's behavior, that is true when present and false otherwise.</p>
<pre><code>--help
</code></pre>
<p>Flags are options that do not take an argument and can be omitted.</p>
<h3 id="option"><a class="header" href="#option"><strong>Option</strong></a></h3>
<p>An option is a type of flag that, when provided, is required to have an argument assigned to it. The argument may immediately proceed the option's flag separated by whitespace.</p>
<pre><code>--plugin &lt;name&gt;
</code></pre>
<p>The argument may also be attached to the option's flag with an equal sign <code>=</code>.</p>
<pre><code>--plugin=&lt;name&gt;
</code></pre>
<p>Options are able to be omitted.</p>
<h3 id="switch"><a class="header" href="#switch"><strong>Switch</strong></a></h3>
<p>A switch is a shorthand flag denoted by a single dash and a single character.</p>
<pre><code>-h
</code></pre>
<p>Multiple switches can be chained onto the same dash.</p>
<pre><code>-ci
</code></pre>
<p>If a switch is associated with an option, it must be declared last on a chain with its argument to immediately follow separated by whitespace or an equal sign <code>=</code>.</p>
<pre><code>-o &lt;file&gt;
</code></pre>
<p>Common flags and options may have a shorthand <em>switch</em> associated with them. For example, <code>--help</code> can be alternatively passed with just <code>-h</code>.</p>
<h3 id="argument-terminator"><a class="header" href="#argument-terminator"><strong>Argument terminator</strong></a></h3>
<p>The argument terminator is a special no-op flag <code>--</code> that tells the command-line interpreter to parse up until this symbol.</p>
<p>Some scenarios will allow you to pass arguments through <code>orbit</code> to an internally executed command. You can pass these arguments by using the <em>argument terminator</em>.</p>
<h4 id="examples-1"><a class="header" href="#examples-1">Examples</a></h4>
<p>An example of using the argument terminator is brought up when calling a plugin through <code>orbit</code> during the building step.</p>
<pre><code>$ orbit build --plugin yilinx -- --sram
</code></pre>
<p>In this command, <code>orbit</code> does not interpret the "--sram" flag, but instead passes it to the plugin named "yilinx" to handle.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-new"><a class="header" href="#orbit-new"><strong>orbit new</strong></a></h1>
<h2 id="name"><a class="header" href="#name"><strong>NAME</strong></a></h2>
<p>new - create a new ip</p>
<h2 id="synopsis"><a class="header" href="#synopsis"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit new [options] &lt;path&gt;
</code></pre>
<h2 id="description"><a class="header" href="#description"><strong>DESCRIPTION</strong></a></h2>
<p>This command will create a new ip at the target directory <code>&lt;path&gt;</code>. The command
assumes the path does not already exists. It will attempt to create a new
directory at the destination with a manifest.</p>
<p>If no name is supplied, then the ip's name defaults to the final path component
of the path argument. Use the name option to provide a custom name.</p>
<p>This command fails if the path already exists. See the <code>init</code> command for
initializing an already existing project into an ip.</p>
<h2 id="options"><a class="header" href="#options"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;path&gt;</code><br />
      The new directory to make</p>
<p><code>--name &lt;name&gt;</code><br />
      The ip name to create</p>
<p><code>--library &lt;library&gt;</code><br />
      The ip library</p>
<h2 id="examples-2"><a class="header" href="#examples-2"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit new gates
orbit new ./projects/dir7 --name adder
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-init"><a class="header" href="#orbit-init"><strong>orbit init</strong></a></h1>
<h2 id="name-1"><a class="header" href="#name-1"><strong>NAME</strong></a></h2>
<p>init - initialize an ip from an existing project</p>
<h2 id="synopsis-1"><a class="header" href="#synopsis-1"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit init [options] [&lt;path&gt;]
</code></pre>
<h2 id="description-1"><a class="header" href="#description-1"><strong>DESCRIPTION</strong></a></h2>
<p>This command will initialize a new ip at the target directory <code>&lt;path&gt;</code>. If no path
is supplied, then it defaults to the current working directory.</p>
<p>If no name is supplied, then the ip's name defaults to the final path component
of the path argument. Use the name option to provide a custom name.</p>
<p>This command fails if the path does not exist. See the <code>new</code> command for
creating an ip from a non-existing directory.</p>
<h2 id="options-1"><a class="header" href="#options-1"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;path&gt;</code><br />
      The location to initialize an ip</p>
<p><code>--name &lt;name&gt;</code><br />
      The name of the ip</p>
<p><code>--library &lt;library&gt;</code><br />
      The ip library</p>
<p><code>--force</code><br />
      Overwrite a manifest if one already exists</p>
<h2 id="examples-3"><a class="header" href="#examples-3"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit init
orbit init ./projects/gates
orbit init --name hello_world
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-view"><a class="header" href="#orbit-view"><strong>orbit view</strong></a></h1>
<h2 id="name-2"><a class="header" href="#name-2"><strong>NAME</strong></a></h2>
<p>view - display metadata of an ip</p>
<h2 id="synopsis-2"><a class="header" href="#synopsis-2"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit show [options] [&lt;ip&gt;]
</code></pre>
<h2 id="description-2"><a class="header" href="#description-2"><strong>DESCRIPTION</strong></a></h2>
<p>This command retrieves various pieces of information about a particular ip to
gain a better understanding of how to utilize the ip. By default, it displays
the ip's manifest, if and only if the ip is able to be located.</p>
<p>It will first attempt to return the information from a possible installation. If
one does not exist, then it searches the downloads location for the ip.</p>
<p>If <code>--units</code> is specified, then a list of the ip's HDL units are displayed.</p>
<p>If <code>--versions</code> is specified, then a list of the ip's already available versions
are displayed.</p>
<p>If no spec is provided for <code>&lt;ip&gt;</code>, then it will retrieve information based on the
local ip, if one exists.</p>
<h2 id="options-2"><a class="header" href="#options-2"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;ip&gt;</code><br />
      The spec of the ip to query</p>
<p><code>--versions, -v</code><br />
      Display the list of possible versions</p>
<p><code>--units, -u</code><br />
      Display the list of HDL primary design units associated with this ip</p>
<p><code>--all, -a</code><br />
      Include any private or hidden results</p>
<h2 id="examples-4"><a class="header" href="#examples-4"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit view --units
orbit view gates:1.0.0 -u
orbit view gates --versions
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-read"><a class="header" href="#orbit-read"><strong>orbit read</strong></a></h1>
<h2 id="name-3"><a class="header" href="#name-3"><strong>NAME</strong></a></h2>
<p>read - navigate hdl design unit source code</p>
<h2 id="synopsis-3"><a class="header" href="#synopsis-3"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit read [options] &lt;unit&gt;
</code></pre>
<h2 id="description-3"><a class="header" href="#description-3"><strong>DESCRIPTION</strong></a></h2>
<p>This command allows the user to navigate source code to gain a quicker
understanding of the available code. By default, it will display the code to the
console.</p>
<p>If no ip specification is provided through the <code>--ip</code> option, then it will
assume to search the current working ip, if it exists.</p>
<p>If <code>--file</code> is provided, then the source code will be written to a temporary
read-only file. Also providing '--location' in this context will append the
requested code segment's line and column number to the end of the generated
filepath.</p>
<p>The options <code>--start</code>, <code>--end</code>, and <code>--doc</code> all accept valid VHDL code to
search for in the identified source code file. The <code>--doc</code> option will find the
immediate single-line comments preceding the supplied code value.</p>
<p>The <code>read</code> command attempts to clean the temporary directory at every call to
it. To keep existing files alive while allowing new files to appear, use the
<code>--keep</code> flag.</p>
<h2 id="options-3"><a class="header" href="#options-3"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;unit&gt;</code><br />
      Primary design unit identifier</p>
<p><code>--ip &lt;spec&gt;</code><br />
      The ip specification to search in the catalog</p>
<p><code>--file</code><br />
      Copy the source code to a temporary read-only file</p>
<p><code>--location</code><br />
      Append the targeted code segment's line and column number to the resulting filepath</p>
<p><code>--keep</code><br />
      Do not clean the temporary directory of existing files</p>
<p><code>--limit &lt;num&gt;</code><br />
      Set a maximum number of lines to write</p>
<p><code>--start &lt;code&gt;</code><br />
      Start the code navigation upon matching this VHDL segment</p>
<p><code>--end &lt;code&gt;</code><br />
      Stop the code navigation upon matching this VHDL segment</p>
<p><code>--doc &lt;code&gt;</code><br />
      Navigate to the preceding comments of this VHDL segment</p>
<h2 id="examples-5"><a class="header" href="#examples-5"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit read and_gate --ip gates:1.0.0
orbit read math_pkg --ip math --doc "function clog2"
orbit read math_pkg --ip math --start "package math_pkg" --doc "function flog2p1" --location --file
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-get"><a class="header" href="#orbit-get"><strong>orbit get</strong></a></h1>
<h2 id="name-4"><a class="header" href="#name-4"><strong>NAME</strong></a></h2>
<p>get - fetch an hdl entity for code integration</p>
<h2 id="synopsis-4"><a class="header" href="#synopsis-4"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit get [options] &lt;unit&gt;
</code></pre>
<h2 id="description-4"><a class="header" href="#description-4"><strong>DESCRIPTION</strong></a></h2>
<p>This command will provide the relevant information about the requested HDL
entity required to integrate the code into the current design. The command
produces valid HDL code displayed to stdout that allows a user to copy and
paste the results into a new hdl source code file for proper hierarchy code
reuse.</p>
<p>If the spec if not provided with <code>--ip</code>, then it will search the current
working ip for the requested HDL entity.</p>
<p>If the <code>--instance</code> flag is used without the <code>--component</code> flag, then it will
display the direct instantiation style code for VHDL (VHDL-93 feature).</p>
<p>It is important to note that any units referenced from ip outside of the
current working ip are not automatically tracked as a dependency. In order to
add an ip as a dependency to properly reference its source code files, edit
the current working ip's manifest with a new entry under the <code>[dependencies]</code>
table with the dependency ip and its version.</p>
<p>An identifier prefix or suffix can be attached to the signal declarations and
the instantiation's port connection signals by using <code>--signal-prefix</code> and
<code>--signal-suffix</code> respectively. These optional texts are treated as normal
strings and are not checked for correct syntax.</p>
<p>When no output options are specified, this command by default will display the
entity's component declaration.</p>
<h2 id="options-4"><a class="header" href="#options-4"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;unit&gt;</code><br />
      Primary design unit identifier</p>
<p><code>--ip &lt;spec&gt;</code><br />
      The ip that contains the requested unit</p>
<p><code>--json</code><br />
      Export the entity information as valid json</p>
<p><code>--library, -l</code><br />
      Display the unit's library declaration</p>
<p><code>--component, -c</code><br />
      Display the component declaration</p>
<p><code>--signals, -s</code><br />
      Display the constant and signal declarations</p>
<p><code>--instance, -i</code><br />
      Display the unit's instantiation</p>
<p><code>--architecture, -a</code><br />
      Display the detected architectures</p>
<p><code>--name &lt;identifier&gt;</code><br />
      Set the instance's identifier</p>
<p><code>--signal-prefix &lt;value&gt;</code><br />
      Prepend information to the instance's signals</p>
<p><code>--signal-suffix &lt;value&gt;</code><br />
      Append information to the instance's signals</p>
<h2 id="examples-6"><a class="header" href="#examples-6"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit get and_gate --ip gates:1.0.0 --component
orbit get ram --ip mem:2.0.3 -csi
orbit get uart -si --name u0
orbit get or_gate --ip gates --json
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-tree"><a class="header" href="#orbit-tree"><strong>orbit tree</strong></a></h1>
<h2 id="name-5"><a class="header" href="#name-5"><strong>NAME</strong></a></h2>
<p>tree - view the dependency graph</p>
<h2 id="synopsis-5"><a class="header" href="#synopsis-5"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit tree [options]
</code></pre>
<h2 id="description-5"><a class="header" href="#description-5"><strong>DESCRIPTION</strong></a></h2>
<p>This command will show the hierarchical tree-structure starting from a node.
By default, it will attempt to automatically detect the root if it is
unambiguous and <code>--root</code> is not provided. This command only works when called
from the current working ip.</p>
<p>The hdl-level tree displays the connections between entities. The hdl tree does
not show how many times an entity is instantiated within a parent entity, and
all architectures for each entity are analyzed. If an unidentified entity is
instantiated it will appear as a leaf and is denoted as a black box by a '?'
character.</p>
<p>An entity is considered a black box if it cannot find that referenced entity's
hdl source code file.</p>
<p>To view the dependency tree at the ip-level, use <code>--ip</code>.</p>
<h2 id="options-5"><a class="header" href="#options-5"><strong>OPTIONS</strong></a></h2>
<p><code>--root &lt;unit&gt;</code><br />
      The uppermost hdl unit to start the dependency tree</p>
<p><code>--compress</code><br />
      Replace duplicate branches with a label marking</p>
<p><code>--all</code><br />
      Include all possible roots in the tree</p>
<p><code>--format &lt;fmt&gt;</code><br />
      Determine how to display nodes ('long', 'short')</p>
<p><code>--ascii</code><br />
      Limit the textual tree characters to the 128 ASCII set</p>
<p><code>--ip</code><br />
      View the dependency graph at the ip level</p>
<h2 id="examples-7"><a class="header" href="#examples-7"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit tree --ip
orbit tree --root top --format long
orbit tree --ascii --all
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-lock"><a class="header" href="#orbit-lock"><strong>orbit lock</strong></a></h1>
<h2 id="name-6"><a class="header" href="#name-6"><strong>NAME</strong></a></h2>
<p>lock - save the world state of an ip</p>
<h2 id="synopsis-6"><a class="header" href="#synopsis-6"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit lock [options]
</code></pre>
<h2 id="description-6"><a class="header" href="#description-6"><strong>DESCRIPTION</strong></a></h2>
<p>This command saves the state of the world according to the working ip. To
accomplish this, Orbit reads working ip's manifest file to resolve any
missing dependencies. It's writes all the information that is necessary to
reproduce this state to the ip's lock file, Orbit.lock.</p>
<p>This command can only be ran within a working ip.</p>
<p>It is encouraged to check the lock file into version control such that others
trying to build the ip can reproduce the ip's current state. The lock file
should not be manually edited by the user.</p>
<p>To capture the state of the world according to the ip, this command will
download and install any unresolved dependencies. If an installed dependency's
computed checksum does not match the checksum stored in the lock file, it
assumes the installation to be corrupt and will re-install the dependency to
the cache.</p>
<h2 id="options-6"><a class="header" href="#options-6"><strong>OPTIONS</strong></a></h2>
<p><code>--force</code><br />
      Ignore reading the precomputed lock file</p>
<h2 id="examples-8"><a class="header" href="#examples-8"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit lock
orbit lock --force
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-test"><a class="header" href="#orbit-test"><strong>orbit test</strong></a></h1>
<h2 id="name-7"><a class="header" href="#name-7"><strong>NAME</strong></a></h2>
<p>test - run a test</p>
<h2 id="synopsis-7"><a class="header" href="#synopsis-7"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit test [options] [--] [args]...
</code></pre>
<h2 id="description-7"><a class="header" href="#description-7"><strong>DESCRIPTION</strong></a></h2>
<p>This command prepares a given target and then executes the target.</p>
<p>While this command functions similar to <code>orbit build</code>, the targets that are
encouraged to be used with this command are ones that are designed to either
"pass" or "fail", typically through a return code. This command requires a
testbench, if you do not want to set a testbench, see <code>orbit build</code>.</p>
<p>A target must be provided for the test command to run. A default target can
be specified in a configuration file, which will be used when a target is
omitted from the command-line.</p>
<p>If <code>--list</code> is used, then it will display a list of the available targets to
the user. Using <code>--list</code> in combination with a target from <code>--target</code> will
display any detailed help information the target has documented in its
definition.</p>
<p>A target typically goes through three steps for the testing process:</p>
<ol>
<li>Parse the blueprint file</li>
<li>Process the referenced files listed in the blueprint</li>
<li>Verify the hdl source code passes all tests</li>
</ol>
<p>Any command-line arguments entered after the terminating flag <code>--</code> will be
passed in the received order as arguments to the subprocess's command. If a
target already has defined arguments, the additional arguments passed from the
command-line will follow the previously defined arguments.</p>
<p>The target's process will spawn from the current working ip's output directory,
which is $ORBIT_TARGET_DIR/$ORBIT_TARGET.</p>
<h2 id="options-7"><a class="header" href="#options-7"><strong>OPTIONS</strong></a></h2>
<p><code>--target &lt;name&gt;</code><br />
      Target to execute</p>
<p><code>--dut &lt;unit&gt;</code><br />
      Set the device under test</p>
<p><code>--tb &lt;unit&gt;</code><br />
      Set the top level testbench unit</p>
<p><code>--plan &lt;format&gt;</code><br />
      Set the blueprint file format</p>
<p><code>--target-dir &lt;dir&gt;</code><br />
      The relative directory where the target starts</p>
<p><code>--command &lt;path&gt;</code><br />
      Overwrite the target's command</p>
<p><code>--list</code><br />
      View available targets and exit</p>
<p><code>--all</code><br />
      Include all hdl files of the working ip</p>
<p><code>--fileset &lt;key=glob&gt;...</code><br />
      A glob-style pattern identified by name to include in the blueprint</p>
<p><code>--no-clean</code><br />
      Do not clean the target folder before execution</p>
<p><code>--force</code><br />
      Force the target to execute</p>
<p><code>--verbose</code><br />
      Display the command being executed</p>
<p><code>args</code><br />
      Arguments to pass to the target</p>
<h2 id="examples-9"><a class="header" href="#examples-9"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit test --dut adder --tb adder_tb --target modelsim -- --lint
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-build"><a class="header" href="#orbit-build"><strong>orbit build</strong></a></h1>
<h2 id="name-8"><a class="header" href="#name-8"><strong>NAME</strong></a></h2>
<p>build - plan and execute a target</p>
<h2 id="synopsis-8"><a class="header" href="#synopsis-8"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit build [options] [--] [args]...
</code></pre>
<h2 id="description-8"><a class="header" href="#description-8"><strong>DESCRIPTION</strong></a></h2>
<p>This command prepares a given target and then executes the target.</p>
<p>While this command functions similar to <code>orbit test</code>, the targets that are
encouraged to be used with this command are ones that produce artifacts at the
end of their execution process. This command does not allow the top to be a
testbench, if you want to set a testbench, see <code>orbit test</code>.</p>
<p>A target must be provided for the build command to run. A default target can
be specified in a configuration file, which will be used when a target is
omitted from the command-line.</p>
<p>If <code>--list</code> is used, then it will display a list of the available targets to
the user. Using <code>--list</code> in combination with a target from <code>--target</code> will
display any detailed help information the target has documented in its
definition.</p>
<p>A target typically goes through three steps for the building process:</p>
<ol>
<li>Parse the blueprint file</li>
<li>Process the referenced files listed in the blueprint</li>
<li>Generate a artifact(s)</li>
</ol>
<p>Any command-line arguments entered after the terminating flag <code>--</code> will be
passed in the received order as arguments to the subprocess's command. If a
target already has defined arguments, the additional arguments passed from the
command-line will follow the previously defined arguments.</p>
<p>The target's process will spawn from the current working ip's output directory,
which is $ORBIT_TARGET_DIR/$ORBIT_TARGET.</p>
<h2 id="options-8"><a class="header" href="#options-8"><strong>OPTIONS</strong></a></h2>
<p><code>--target &lt;name&gt;</code><br />
      Target to execute</p>
<p><code>--top &lt;unit&gt;</code><br />
      Set the top level design unit</p>
<p><code>--plan &lt;format&gt;</code><br />
      Set the blueprint file format</p>
<p><code>--target-dir &lt;dir&gt;</code><br />
      The relative directory where the target starts</p>
<p><code>--command &lt;path&gt;</code><br />
      Overwrite the target's command</p>
<p><code>--list</code><br />
      View available targets and exit</p>
<p><code>--all</code><br />
      Include all hdl files of the working ip</p>
<p><code>--fileset &lt;key=glob&gt;...</code><br />
      A glob-style pattern identified by name to include in the blueprint</p>
<p><code>--force</code><br />
      Force the target to execute</p>
<p><code>--no-clean</code><br />
      Do not clean the target folder before execution</p>
<p><code>--verbose</code><br />
      Display the command being executed</p>
<p><code>args</code><br />
      Arguments to pass to the target</p>
<h2 id="examples-10"><a class="header" href="#examples-10"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit build --target xsim -- --elab
orbit build --command python3 --target pysim
orbit build --all --target-dir build --target ghdl
orbit build --target xsim --force -- --help
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-launch"><a class="header" href="#orbit-launch"><strong>orbit launch</strong></a></h1>
<h2 id="name-9"><a class="header" href="#name-9"><strong>NAME</strong></a></h2>
<p>launch - release an ip through a channel</p>
<h2 id="synopsis-9"><a class="header" href="#synopsis-9"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit launch [options]
</code></pre>
<h2 id="description-9"><a class="header" href="#description-9"><strong>DESCRIPTION</strong></a></h2>
<p>Performs a series of checks on a stable version of a local ip to then release it
through a channel.</p>
<p>For an ip to be launched, it must have its source field defined that directs to
a valid internet location.</p>
<p>By default, it operates a dry run, performing all steps in the process except
for the actual release through the channel. To fully run the command, use the
<code>--ready</code> flag. When the ip is launched, it will also be installed to the cache
by default. To skip this behavior, use the <code>--no-install</code> flag.</p>
<h2 id="options-9"><a class="header" href="#options-9"><strong>OPTIONS</strong></a></h2>
<p><code>--ready, -y</code><br />
      Perform a full run</p>
<p><code>--no-install</code><br />
      Skip installing the ip</p>
<p><code>--list</code><br />
      View available channels and exit</p>
<h2 id="examples-11"><a class="header" href="#examples-11"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit launch
orbit launch --ready
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-search"><a class="header" href="#orbit-search"><strong>orbit search</strong></a></h1>
<h2 id="name-10"><a class="header" href="#name-10"><strong>NAME</strong></a></h2>
<p>search - browse the ip catalog</p>
<h2 id="synopsis-10"><a class="header" href="#synopsis-10"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit search [options] [&lt;ip&gt;]
</code></pre>
<h2 id="description-10"><a class="header" href="#description-10"><strong>DESCRIPTION</strong></a></h2>
<p>This command will display a list of all the known ip in the catalog. The catalog
consists of 3 levels: cache, downloads, and channels.</p>
<p>Any ip at the cache level are considered installed. Any ip at the downloads
level are considered downloaded. Any ip at the channels level is considered
available. An ip does not exist in the catalog if it is not found at any one
of the three defined levels.</p>
<p>When a package name is provided for <code>&lt;ip&gt;</code>, it will begin to partially match
the name with the names of the known ip. If an ip's name begins with <code>&lt;ip&gt;</code>, it
is included in the filtered resultes. To strictly match the argument against an
ip name, use <code>--match</code>.</p>
<h2 id="options-10"><a class="header" href="#options-10"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;ip&gt;</code><br />
      The beginning of a package name</p>
<p><code>--install, -i</code><br />
      Filter ip installed to the cache</p>
<p><code>--download, -d</code><br />
      Filter ip downloaded to the downloads</p>
<p><code>--keyword &lt;term&gt;...</code><br />
      Include ip that contain this keyword</p>
<p><code>--limit &lt;num&gt;</code><br />
      The maximum number of results to return</p>
<p><code>--match</code><br />
      Return results that only pass each filter</p>
<h2 id="examples-12"><a class="header" href="#examples-12"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit search axi
orbit search --keyword memory --keyword ecc
orbit search --keyword RF --limit 20
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-download"><a class="header" href="#orbit-download"><strong>orbit download</strong></a></h1>
<h2 id="name-11"><a class="header" href="#name-11"><strong>NAME</strong></a></h2>
<p>download - fetch packages from the internet</p>
<h2 id="synopsis-11"><a class="header" href="#synopsis-11"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit download [options]
</code></pre>
<h2 id="description-11"><a class="header" href="#description-11"><strong>DESCRIPTION</strong></a></h2>
<p>This command will get a package from the internet using the default protocol
or a user-defined protocol. It places the package in the path defined as
environment variable <code>$ORBIT_ARCHIVE</code>.</p>
<p>Downloads are vital to Orbit's management system as to avoid having to solely
rely on accessing the internet to get IP. Downloads allow Orbit to quickly
repair broken installations and allow users to learn about IP before installing.</p>
<p>When using a custom protocol, Orbit expects the final fetched repository to
exist within a special directory called the queue. By default, the queue is set
to a temporary directory, but it can be overridden with <code>--queue</code>. After a
protocol is executed, Orbit resumes the download process by trying to detect the
target IP and then performing a compression algorithm on the path to store as a
single file archive. This final archive is special and packed with additional
bytes, which makes it unsuitable to easily unzip with existing compression
tools.</p>
<p>A lockfile is required to exist in the current IP in order to download its
dependencies.</p>
<p>Variable substitution is supported when specifying the "command" and "args"
fields for a protocol. Most notably, the queue is accessed as
<code>{{ orbit.queue }}</code>. See <code>orbit help protocols</code> for more information about
available variables.</p>
<p>This action may automatically run during an install if the package is missing
from the downloads. See <code>orbit help install</code> for more details.</p>
<h2 id="options-11"><a class="header" href="#options-11"><strong>OPTIONS</strong></a></h2>
<p><code>--list</code><br />
      Print URLs and exit</p>
<p><code>--missing</code><br />
      Filter only uninstalled packages (default: true)</p>
<p><code>--all</code><br />
      Gather packages from all dependency types</p>
<p><code>--queue &lt;dir&gt;</code><br />
      Set the destination directory for placing fetched repositories</p>
<p><code>--verbose</code><br />
      Display the custom protocol being executed</p>
<p><code>--force</code><br />
      Download selected packages regardless of status</p>
<h2 id="examples-13"><a class="header" href="#examples-13"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit download --missing --list
orbit download --all --force
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-install"><a class="header" href="#orbit-install"><strong>orbit install</strong></a></h1>
<h2 id="name-12"><a class="header" href="#name-12"><strong>NAME</strong></a></h2>
<p>install - store an immutable reference to an ip</p>
<h2 id="synopsis-12"><a class="header" href="#synopsis-12"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit install [options]
</code></pre>
<h2 id="description-12"><a class="header" href="#description-12"><strong>DESCRIPTION</strong></a></h2>
<p>This command will place an ip into the cache. By default, the specified version
is the 'latest' released version orbit can identify.</p>
<p>When this command is ran without specifying the <ip> or a source (such as
<code>--url</code> or <code>--path</code>), it will attempt to install the current working ip, if it
exists.</p>
<p>By default, any dependencies required only for development by the target ip are
omitted from installation. To also install these dependencies, use <code>--all</code>.</p>
<p>If a protocol is recognized using <code>--protocol</code>, then an optional tag can also
be supplied to help the protocol with providing any additional information it
may require.</p>
<h2 id="options-12"><a class="header" href="#options-12"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;ip&gt;</code><br />
      Ip specification</p>
<p><code>--url &lt;url&gt;</code><br />
      URL to install the ip from the internet</p>
<p><code>--path &lt;path&gt;</code><br />
      Path to install the ip from local file system</p>
<p><code>--protocol &lt;name&gt;</code><br />
      Use a configured protocol to download ip</p>
<p><code>--tag &lt;tag&gt;</code><br />
      Unique tag to provide to the protocol</p>
<p><code>--force</code><br />
      Install the ip regardless of the cache slot occupancy</p>
<p><code>--list</code><br />
      View available protocols and exit</p>
<p><code>--all</code><br />
      Install all dependencies (including development)</p>
<h2 id="examples-14"><a class="header" href="#examples-14"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit install
orbit install lcd_driver:2.0
orbit install adder:1.0.0 --url https://my.adder/project.zip
orbit install alu:2.3.7 --path ./projects/alu --force
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-env"><a class="header" href="#orbit-env"><strong>orbit env</strong></a></h1>
<h2 id="name-13"><a class="header" href="#name-13"><strong>NAME</strong></a></h2>
<p>env - print orbit environment information</p>
<h2 id="synopsis-13"><a class="header" href="#synopsis-13"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit env [options]
</code></pre>
<h2 id="description-13"><a class="header" href="#description-13"><strong>DESCRIPTION</strong></a></h2>
<p>This command prints environment variables relevant to <code>orbit</code>.</p>
<p>By default, this command prins information as a shell script. If one or more
variable names are given as arguments as <code>&lt;key&gt;</code>, then it will print the value
of each provided variables on its own line.</p>
<h2 id="options-13"><a class="header" href="#options-13"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;key&gt;...</code><br />
      Include this variable's value specifically in the environment information</p>
<h2 id="examples-15"><a class="header" href="#examples-15"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit env
orbit env ORBIT_HOME
orbit env ORBIT_CACHE ORBIT_ARCHIVE
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-config"><a class="header" href="#orbit-config"><strong>orbit config</strong></a></h1>
<h2 id="name-14"><a class="header" href="#name-14"><strong>NAME</strong></a></h2>
<p>config - modify configuration values</p>
<h2 id="synopsis-14"><a class="header" href="#synopsis-14"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit config [options]
</code></pre>
<h2 id="description-14"><a class="header" href="#description-14"><strong>DESCRIPTION</strong></a></h2>
<p>This command will alter configuration entries in Orbit's settings file named
<code>config.toml</code>. By default, it will modify the user's config file found at
the path read from the environment variable <code>$ORBIT_HOME</code>.</p>
<p>To access an entry (key/value pair), use dots (<code>.</code>) to delimit between
intermediate table identifiers and the final key identifier.</p>
<p>The command modifies the document in three independent stages. The first stage
modifies the settings by iterating through all defined <code>--append</code> values. Then,
it will insert all <code>--set</code> values. Lastly, it will remove all <code>--unset</code> entries.</p>
<h2 id="options-14"><a class="header" href="#options-14"><strong>OPTIONS</strong></a></h2>
<p><code>--global</code><br />
      Access the home configuration file</p>
<p><code>--local</code><br />
      Access the current project's configuration file</p>
<p><code>--append &lt;key=value&gt;...</code><br />
      Add a value to the key storing a list</p>
<p><code>--set &lt;key=value&gt;...</code><br />
      Write the value at the key's entry</p>
<p><code>--unset &lt;key&gt;...</code><br />
      Delete the key's entry</p>
<h2 id="examples-16"><a class="header" href="#examples-16"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit config --append include="~/.orbit/profiles/ks-tech"
orbit config --unset env.VIVADO_PATH --global
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-remove"><a class="header" href="#orbit-remove"><strong>orbit remove</strong></a></h1>
<h2 id="name-15"><a class="header" href="#name-15"><strong>NAME</strong></a></h2>
<p>remove - uninstall an ip from the catalog</p>
<h2 id="synopsis-15"><a class="header" href="#synopsis-15"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit remove [options] &lt;ip&gt;
</code></pre>
<h2 id="description-15"><a class="header" href="#description-15"><strong>DESCRIPTION</strong></a></h2>
<p>This command will remove known ip stored in the catalog. By default, it will
remove the ip from the cache. This include any dynamic entries spawned from the
requested ip to remove.</p>
<p>To remove the ip from the cache and downloads locations, use <code>--all</code>.</p>
<h2 id="options-15"><a class="header" href="#options-15"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;ip&gt;</code><br />
      Ip specification</p>
<p><code>--all</code><br />
      remove the ip from the cache and downloads</p>
<p><code>--recurse, -r</code><br />
      fully remove the ip and its dependencies</p>
<h2 id="examples-17"><a class="header" href="#examples-17"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit remove gates
orbit remove gates:1.0.0 --all
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="archive-1"><a class="header" href="#archive-1">Archive</a></h3>
<p>The archive is the location where compressed snapshots of a specific ip's version exist. The compressed ip files are unable to be referenced as dependencies, but they are able to be <em>installed</em> to the cache for usage. The ip's in the archvie are considered <em>downloaded</em>.</p>
<h3 id="blueprint-1"><a class="header" href="#blueprint-1">Blueprint</a></h3>
<p>A blueprint is a single file that lists all the necessary source files and auxiliary files for the build process of a particular target. The source files are listed in topologically-sorted order. The blueprint is generated by Orbit during the planning stage of the build process, and is typically immediately used as input to the execution stage of the build process.</p>
<p>A blueprint can store the information collected from the planning stage in different file formats, called schemes. The default scheme is tab-separated values (TSV).</p>
<h3 id="cache-1"><a class="header" href="#cache-1">Cache</a></h3>
<p>The cache is the location where immutable references to a specific ip's version exist. An ip's dependencies are referenced from the cache. The ip that are found at the cache level are considered <em>installed</em>.</p>
<h3 id="catalog-1"><a class="header" href="#catalog-1">Catalog</a></h3>
<p>The catalog is the user's entire space of currently known ip to Orbit. It consists of 3 main layers: cache, downloads, channels.</p>
<h3 id="channels-2"><a class="header" href="#channels-2">Channels</a></h3>
<p>The channels are a set of decentralized registries that store the manifests for versions of ip. No source code is stored in a channel, however, Orbit is able to use the manifest as means to <em>download</em> that ip to the archive for local filesystem access. The ip that are found at the channels level are considered <em>available</em>. Users are encouraged to create and share their own channels.</p>
<h3 id="fileset"><a class="header" href="#fileset">Fileset</a></h3>
<p>A fileset is a glob-style pattern for collecting files under a given name. Filesets are
used to group common files together into the blueprint during the planning stage of the build process. A target can define its own filesets.</p>
<h3 id="intellectual-property-ip"><a class="header" href="#intellectual-property-ip">Intellectual Property (IP)</a></h3>
<p>An ip is a project with a manifest file at its root directory. At a minimum, an ip has two attributes: a name and a version.</p>
<h3 id="ip-specification-spec"><a class="header" href="#ip-specification-spec">Ip Specification (spec)</a></h3>
<p>The spec describes the format for identifying and referencing an ip. Each ip in the user's catalog must have a unique spec. The format of a ip's spec is: <code>&lt;name&gt;[:&lt;version&gt;]</code>.</p>
<h3 id="local-ip"><a class="header" href="#local-ip">Local Ip</a></h3>
<p>The local ip is the ip detected from the current working directory on the command-line. Some commands can only be executed from the local ip, such as <code>orbit lock</code> and <code>orbit build</code>.</p>
<h3 id="lockfile"><a class="header" href="#lockfile">Lockfile</a></h3>
<p>A lockfile is a file that exactly describes an ip's dependencies. It is generated and maintained by Orbit. The lockfile should be checked into your version control system for reproducible builds. It is not to be manually edited by the user.</p>
<p>From the lockfile, Orbit is able to download missing dependencies, install missing dependencies, and verify the data integrity of installed dependencies.</p>
<h3 id="manifest-1"><a class="header" href="#manifest-1">Manifest</a></h3>
<p>A manifest is a file that decscribes an ip recognized by Orbit. Manifest files
are exactly named <code>Orbit.toml</code>. The manifest is intended to be written by the user.</p>
<h3 id="orbitlock-1"><a class="header" href="#orbitlock-1">Orbit.lock</a></h3>
<p>See <a href="glossary.html#lockfile">lockfile</a>.</p>
<h3 id="orbittoml"><a class="header" href="#orbittoml">Orbit.toml</a></h3>
<p>See <a href="glossary.html#manifest">manifest</a>.</p>
<h3 id="package"><a class="header" href="#package">Package</a></h3>
<p>See <a href="glossary.html#intellectual-property-ip">IP</a>.</p>
<h3 id="profile"><a class="header" href="#profile">Profile</a></h3>
<p>A profile is a user-defined group of plugins, settings, and/or channels under a single directory. A profile does not necessarily have to have all listed aspects in order to be considered a "profile".</p>
<p>Profiles are useful for quickly sharing and maintaining common development standards and workflows among a team environment.</p>
<h3 id="project"><a class="header" href="#project">Project</a></h3>
<p>A project is a collection of HDL source files and any other required files related to a specific application or library. Placing a manifest in a project makes it an ip.</p>
<h3 id="systemverilog"><a class="header" href="#systemverilog">SystemVerilog</a></h3>
<p>SystemVerilog is a hardware description and hardware verification language used to model, design, simulate, test, and implement electronic systems.</p>
<h3 id="target"><a class="header" href="#target">Target</a></h3>
<p>A target is a user-defined command that is to be invoked by Orbit during the execution stage of the build process. A target typically follows 3 steps:</p>
<ol>
<li>Parse the blueprint file generated from the planning stage</li>
<li>Process the listed hdl files using an EDA tool</li>
<li>Test the design or build an output product</li>
</ol>
<p>Targets can accept additional arguments from the command-line and define additional filesets to be collected for the planning stage. Users are encouraged to create and share their own targets.</p>
<h3 id="vhdl"><a class="header" href="#vhdl">VHDL</a></h3>
<p>VHSIC Hardware Design Language (VHDL) is a hardware descrption language to model the behavior of digitally electronic circuits.</p>
<h3 id="verilog"><a class="header" href="#verilog">Verilog</a></h3>
<p>Verilog is a hardware description language to model electronic systems. The final standard (IEEE 1364-2005) for Verilog merged into the SystemVerilog standard. Today, Verilog has been officially part of the SystemVerilog language.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
